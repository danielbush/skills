### Create Effect App using Bun

Source: https://effect.website/docs/getting-started/create-effect-app

Initiates a new Effect application using the create-effect-app CLI via Bun. This command starts an interactive setup process to guide the user through project bootstrapping.

```bash
bunx create-effect-app@latest
```

--------------------------------

### Create Effect App using Deno

Source: https://effect.website/docs/getting-started/create-effect-app

Initiates a new Effect application using the create-effect-app CLI via Deno. This command starts an interactive setup process to guide the user through project bootstrapping.

```bash
deno init --npm effect-app@latest
```

--------------------------------

### Install Effect AI and OpenAI Provider Packages (bun)

Source: https://effect.website/docs/ai/getting-started

Installs the core @effect/ai package for AI abstractions and the @effect/ai-openai package for OpenAI integration, along with the core Effect package using bun. This is the initial setup for using Effect AI with OpenAI.

```bash
# Install the base package for the core abstractions (always required)
bun add @effect/ai

# Install one (or more) provider integrations
bun add @effect/ai-openai

# Also add the core Effect package (if not already installed)
bun add effect
```

--------------------------------

### Create Effect App using npm

Source: https://effect.website/docs/getting-started/create-effect-app

Initiates a new Effect application using the create-effect-app CLI via npm. This command starts an interactive setup process to guide the user through project bootstrapping.

```bash
npx create-effect-app@latest
```

--------------------------------

### Install Effect AI and OpenAI Provider Packages (npm)

Source: https://effect.website/docs/ai/getting-started

Installs the core @effect/ai package for AI abstractions and the @effect/ai-openai package for OpenAI integration, along with the core Effect package. This is the initial setup for using Effect AI with OpenAI.

```bash
# Install the base package for the core abstractions (always required)
npm install @effect/ai

# Install one (or more) provider integrations
npm install @effect/ai-openai

# Also add the core Effect package (if not already installed)
npm install effect
```

--------------------------------

### Install Effect AI and OpenAI Provider Packages (pnpm)

Source: https://effect.website/docs/ai/getting-started

Installs the core @effect/ai package for AI abstractions and the @effect/ai-openai package for OpenAI integration, along with the core Effect package using pnpm. This is the initial setup for using Effect AI with OpenAI.

```bash
# Install the base package for the core abstractions (always required)
pnpm add @effect/ai

# Install one (or more) provider integrations
pnpm add @effect/ai-openai

# Also add the core Effect package (if not already installed)
pnpm add effect
```

--------------------------------

### Install OpenTelemetry Dependencies (Bun)

Source: https://effect.website/docs/observability/tracing

Installs the core library for integrating OpenTelemetry with Effect, along with the necessary OpenTelemetry SDKs for tracing and metrics using Bun.

```bash
# Install the main library for integrating OpenTelemetry with Effect
bun add @effect/opentelemetry

# Install the required OpenTelemetry SDKs for tracing and metrics
bun add @opentelemetry/sdk-trace-base
bun add @opentelemetry/sdk-trace-node
bun add @opentelemetry/sdk-trace-web
bun add @opentelemetry/sdk-metrics
```

--------------------------------

### Create Effect App using pnpm

Source: https://effect.website/docs/getting-started/create-effect-app

Initiates a new Effect application using the create-effect-app CLI via pnpm. This command starts an interactive setup process to guide the user through project bootstrapping.

```bash
pnpm create effect-app@latest
```

--------------------------------

### Install Effect AI and OpenAI Provider Packages (yarn)

Source: https://effect.website/docs/ai/getting-started

Installs the core @effect/ai package for AI abstractions and the @effect/ai-openai package for OpenAI integration, along with the core Effect package using yarn. This is the initial setup for using Effect AI with OpenAI.

```bash
# Install the base package for the core abstractions (always required)
yarn add @effect/ai

# Install one (or more) provider integrations
yarn add @effect/ai-openai

# Also add the core Effect package (if not already installed)
yarn add effect
```

--------------------------------

### Create Effect App using Yarn

Source: https://effect.website/docs/getting-started/create-effect-app

Initiates a new Effect application using the create-effect-app CLI via Yarn. This command starts an interactive setup process to guide the user through project bootstrapping.

```bash
yarn create effect-app@latest
```

--------------------------------

### Install Effect Library using npm, pnpm, Yarn, Bun, or Deno

Source: https://effect.website/docs/micro/new-users

Commands to install the Effect library using various package managers. This is a prerequisite for using the Micro module.

```bash
npm install effect
```

```bash
pnpm add effect
```

```bash
yarn add effect
```

```bash
bun add effect
```

```bash
deno add npm:effect
```

--------------------------------

### Setup EffectJS Project for Deno

Source: https://effect.website/docs/getting-started/installation

Initializes a new Deno project, adds the EffectJS package as a dependency, and creates a basic 'Hello, World!' program to verify the setup. The program is then executed using the Deno runtime.

```bash
mkdir hello-effect
cd hello-effect
deno init
deno add npm:effect
```

```typescript
1 import { Effect, Console } from "effect" 
2 
3 const program = Console.log("Hello, World!") 
4 
5 Effect.runSync(program)
```

```bash
deno run main.ts
```

--------------------------------

### Development Server Start Commands (Shell)

Source: https://effect.website/docs/getting-started/installation

This section provides commands to start the development server for the project using different package managers. These commands are essential for running the application locally and testing changes. Supported package managers include npm, pnpm, Yarn, Bun, and Deno.

```bash
npm run dev
```

```bash
pnpm run dev
```

```bash
yarn run dev
```

```bash
bun run dev
```

```bash
deno run dev
```

--------------------------------

### Install Effect and OpenTelemetry Dependencies with Bun

Source: https://effect.website/docs/observability/tracing

Installs the Effect library, the Effect-OpenTelemetry integration, and necessary OpenTelemetry packages for trace export via HTTP (OTLP) and Node.js/web SDKs using Bun.

```bash
# If not already installed
bun add effect
# Required to integrate Effect with OpenTelemetry
bun add @effect/opentelemetry
# Required to export traces over HTTP in OTLP format
bun add @opentelemetry/exporter-trace-otlp-http
# Required by all applications
bun add @opentelemetry/sdk-trace-base
# For NodeJS applications
bun add @opentelemetry/sdk-trace-node
# For browser applications
bun add @opentelemetry/sdk-trace-web
# If you also need to export metrics
bun add @opentelemetry/sdk-metrics
```

--------------------------------

### Install Effect Package (npm)

Source: https://context7_llms

Instructions for installing the Effect TypeScript package using npm. This is the first step to start building type-safe applications with Effect.

```bash
npm install @effect/io
```

--------------------------------

### Basic Key-Value Store Operations

Source: https://effect.website/docs/platform/key-value-store

Illustrates fundamental operations of the KeyValueStore, including setting, getting, removing, and checking the size of the store. This example uses an in-memory implementation.

```typescript
import {
  KeyValueStore,
  layerMemory
} from "@effect/platform/KeyValueStore"
import { Effect } from "effect"

const program = Effect.gen(function* () {
  const kv = yield* KeyValueStore

  // Store is initially empty
  console.log(yield* kv.size)

  // Set a key-value pair
  yield* kv.set("key", "value")
  console.log(yield* kv.size)

  // Retrieve the value
  const value = yield* kv.get("key")
  console.log(value)

  // Remove the key
  yield* kv.remove("key")
  console.log(yield* kv.size)
})

// Run the p
```

--------------------------------

### Install OpenTelemetry Dependencies (npm)

Source: https://effect.website/docs/observability/tracing

Installs the core library for integrating OpenTelemetry with Effect, along with the necessary OpenTelemetry SDKs for tracing and metrics using npm.

```bash
# Install the main library for integrating OpenTelemetry with Effect
npm install @effect/opentelemetry

# Install the required OpenTelemetry SDKs for tracing and metrics
npm install @opentelemetry/sdk-trace-base
npm install @opentelemetry/sdk-trace-node
npm install @opentelemetry/sdk-trace-web
npm install @opentelemetry/sdk-metrics
```

--------------------------------

### Creating a Client Layer for OpenAI Provider

Source: https://effect.website/docs/ai/getting-started

Shows how to create a Layer that provides an OpenAiClient. This layer requires an HttpClient and configuration (like an API key) to initialize the client, making the program executable.

```typescript
import { OpenAiClient, OpenAiLanguageModel } from "@effect/ai-openai"
import { LanguageModel } from "@effect/ai"
import { Config, Effect } from "effect"

const generateDadJoke = Effect.gen(function* () {
  const response = yield* LanguageModel.generateText({
    prompt: "Generate a dad joke"
  })
  console.log(response.text)
  return response
})

const Gpt4o = OpenAiLanguageModel.model("gpt-4o")

const main = generateDadJoke.pipe(
  Effect.provide(Gpt4o)
)

const OpenAi = OpenAiClient.layerConfig({
  apiKey: Config.redacted("OPENAI_API_KEY")
})
```

--------------------------------

### HashSet - Operations and Examples

Source: https://effect.website/docs/data-types/hash-set

Details the various operations available for HashSet, including construction, element management, set operations, and transformations, with practical code examples.

```APIDOC
## HashSet - Operations and Examples

This section outlines the common operations for `HashSet` and provides illustrative examples.

### Operations

| Category      | Operation    | Description                                     | Time Complexity |
|---------------|--------------|-------------------------------------------------|-----------------|
| Constructors  | `empty`      | Creates an empty HashSet                        | O(1)            |
| Constructors  | `fromIterable`| Creates a HashSet from an iterable              | O(n)            |
| Constructors  | `make`       | Creates a HashSet from multiple values          | O(n)            |
| Elements      | `has`        | Checks if a value exists in the set             | O(1) avg        |
| Elements      | `some`       | Checks if any element satisfies a predicate     | O(n)            |
| Elements      | `every`      | Checks if all elements satisfy a predicate      | O(n)            |
| Elements      | `isSubset`   | Checks if a set is a subset of another          | O(n)            |
| Getters       | `values`     | Gets an `Iterator` of all values                | O(1)            |
| Getters       | `toValues`   | Gets an `Array` of all values                   | O(n)            |
| Getters       | `size`       | Gets the number of elements                     | O(1)            |
| Mutations     | `add`        | Adds a value to the set (returns new set)       | O(1) avg        |
| Mutations     | `remove`     | Removes a value from the set (returns new set)  | O(1) avg        |
| Mutations     | `toggle`     | Toggles a value’s presence (returns new set)    | O(1) avg        |
| Operations    | `difference` | Computes set difference (A - B)                 | O(n)            |
| Operations    | `intersection`| Computes set intersection (A ∩ B)               | O(n)            |
| Operations    | `union`      | Computes set union (A ∪ B)                      | O(n)            |
| Mapping       | `map`        | Transforms each element (returns new set)       | O(n)            |
| Sequencing    | `flatMap`    | Transforms and flattens elements (returns new set)| O(n)            |
| Traversing    | `forEach`    | Applies a function to each element              | O(n)            |
| Folding       | `reduce`     | Reduces the set to a single value               | O(n)            |
| Filtering     | `filter`     | Keeps elements that satisfy a predicate (returns new set)| O(n)            |
| Partitioning  | `partition`  | Splits into two sets by a predicate (returns new sets)| O(n)            |

### Example (Basic Creation and Operations)

```typescript
import { HashSet } from "effect"

// Create an initial set with 3 values
const set1 = HashSet.make(1, 2, 3)

// Add a value (returns a new set)
const set2 = HashSet.add(set1, 4)

// The original set is unchanged
console.log(HashSet.toValues(set1)) // Output: [1, 2, 3]
console.log(HashSet.toValues(set2)) // Output: [1, 2, 3, 4]

// Perform set operations with another set
const set3 = HashSet.make(3, 4, 5)

// Combine both sets
const union = HashSet.union(set2, set3)
console.log(HashSet.toValues(union)) // Output: [1, 2, 3, 4, 5]

// Shared values
const intersection = HashSet.intersection(set2, set3)
console.log(HashSet.toValues(intersection)) // Output: [3, 4]

// Values only in set2
const difference = HashSet.difference(set2, set3)
console.log(HashSet.toValues(difference)) // Output: [1, 2]
```

### Example (Chaining with `pipe`)

```typescript
import { HashSet, pipe } from "effect"

const result = pipe(
  // Duplicates are ignored
  HashSet.make(1, 2, 2, 3, 4, 5, 5),
  // Keep even numbers
  HashSet.filter((n) => n % 2 === 0),
  // Double each value
  HashSet.map((n) => n * 2),
  // Convert to array
  HashSet.toValues
)

console.log(result) // Output: [4, 8]
```
```

--------------------------------

### Await Fiber Completion with Micro.fiberAwait (TypeScript)

Source: https://effect.website/docs/micro/new-users

This example shows how to use `Micro.fiberAwait` to get detailed information about a fiber's completion. `Micro.fiberAwait` returns an effect that yields a `MicroExit` value, which describes whether the fiber succeeded, failed, or was interrupted.

```typescript
import { Micro } from "effect"

const fib = (n: number): Micro.Micro =>
  n < 2 
  ? Micro.succeed(n)
  : Micro.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)

// ┌─── Micro, never, never>
// ▼
const fib10Fiber = Micro.fork(fib(10))

const program = Micro.gen(function* () {
  // Retrieve the fiber
  const fiber = yield* fib10Fiber
  // Await its completion and get the MicroExit result
  const exit = yield* Micro.fiberAwait(fiber)
  console.log(exit)
})

Micro.runPromise(program)
/*
Output:
{
  "_id": "MicroExit",
  "_tag": "Success",
  "value": 55
}
*/
```

--------------------------------

### Install OpenTelemetry Dependencies (pnpm)

Source: https://effect.website/docs/observability/tracing

Installs the core library for integrating OpenTelemetry with Effect, along with the necessary OpenTelemetry SDKs for tracing and metrics using pnpm.

```bash
# Install the main library for integrating OpenTelemetry with Effect
pnpm add @effect/opentelemetry

# Install the required OpenTelemetry SDKs for tracing and metrics
pnpm add @opentelemetry/sdk-trace-base
pnpm add @opentelemetry/sdk-trace-node
pnpm add @opentelemetry/sdk-trace-web
pnpm add @opentelemetry/sdk-metrics
```

--------------------------------

### Recovering from Layer Construction Errors with Layer.catchAll (TypeScript)

Source: https://effect.website/docs/requirements-management/layers

This example shows how to use Layer.catchAll to recover from errors during layer construction. If the initial server layer fails (e.g., due to a missing configuration), it provides a fallback layer that logs the error and starts a server on a default port.

```typescript
import { Config, Context, Effect, Layer } from "effect"

class HTTPServer extends Context.Tag("HTTPServer")() {}

// Simulating an HTTP server
const server = Layer.effect(
  HTTPServer,
  Effect.gen(function* () {
    const host = yield* Config.string("HOST")
    console.log(`Listening on http://localhost:${host}`)
  })
).pipe(
  // Recover from errors during layer construction
  Layer.catchAll((configError) =>
    Layer.effect(
      HTTPServer,
      Effect.gen(function* () {
        console.log(`Recovering from error:\n${configError}`)
        console.log(`Listening on http://localhost:3000`)
      })
    )
  )
)

Effect.runFork(Layer.launch(server))
```

--------------------------------

### Install Effect and OpenTelemetry Dependencies with npm

Source: https://effect.website/docs/observability/tracing

Installs the Effect library, the Effect-OpenTelemetry integration, and necessary OpenTelemetry packages for trace export via HTTP (OTLP) and Node.js/web SDKs using npm.

```bash
# If not already installed
npm install effect
# Required to integrate Effect with OpenTelemetry
npm install @effect/opentelemetry
# Required to export traces over HTTP in OTLP format
npm install @opentelemetry/exporter-trace-otlp-http
# Required by all applications
npm install @opentelemetry/sdk-trace-base
# For NodeJS applications
npm install @opentelemetry/sdk-trace-node
# For browser applications
npm install @opentelemetry/sdk-trace-web
# If you also need to export metrics
npm install @opentelemetry/sdk-metrics
```

--------------------------------

### Install OpenTelemetry Dependencies (Yarn)

Source: https://effect.website/docs/observability/tracing

Installs the core library for integrating OpenTelemetry with Effect, along with the necessary OpenTelemetry SDKs for tracing and metrics using Yarn.

```bash
# Install the main library for integrating OpenTelemetry with Effect
yarn add @effect/opentelemetry

# Install the required OpenTelemetry SDKs for tracing and metrics
yarn add @opentelemetry/sdk-trace-base
yarn add @opentelemetry/sdk-trace-node
yarn add @opentelemetry/sdk-trace-web
yarn add @opentelemetry/sdk-metrics
```

--------------------------------

### Install Effect Platform

Source: https://effect.website/docs/platform/introduction

Installs the core Effect Platform package, enabling cross-platform capabilities. This is the first step before using any Effect Platform modules.

```bash
yarn add @effect/platform
```

```bash
bun add @effect/platform
```

```bash
deno add npm:@effect/platform
```

--------------------------------

### Provide OpenAI Model to LanguageModel Service (Effect)

Source: https://effect.website/docs/ai/getting-started

Shows how to satisfy the `LanguageModel` requirement by providing a concrete implementation using `OpenAiLanguageModel` from `@effect/ai-openai`. This example defines a GPT-4o model and then pipes it into the `generateDadJoke` program using `Effect.provide`.

```typescript
import { OpenAiLanguageModel } from "@effect/ai-openai"
import { LanguageModel } from "@effect/ai"
import { Effect } from "effect"

const generateDadJoke = Effect.gen(function*() {
  const response = yield* LanguageModel.generateText({
    prompt: "Generate a dad joke"
  })
  console.log(response.text)
  return response
})

// Create a `Model` which provides a concrete implementation of
// `LanguageModel` and requires an `OpenAiClient`
const Gpt4o = OpenAiLanguageModel.model("gpt-4o")

// Provide the `Model` to the program
const main = generateDadJoke.pipe(
  Effect.provide(Gpt4o)
)
```

--------------------------------

### Full Game Setup and Execution (TypeScript)

Source: https://effect.website/docs/platform/terminal

An Effect that sets up the game by displaying initial instructions and then starting the game loop with a randomly generated secret number. This Effect orchestrates the entire game flow from start to finish.

```typescript
import { Effect, Option, Random } from "effect"
import { NodeRuntime, NodeTerminal } from "@effect/platform-node"
import { Terminal, PlatformError } from "@effect/platform"

// Full game setup and execution
const game = Effect.gen(function* () {
  yield* display(
    `We have selected a random number between 1 and 100. 
See if you can guess it in 10 turns or fewer. 
We'll tell you if your guess was too high or too low.`
  )
  yield* loop(yield* secret)
})
```

--------------------------------

### Loading Log Level from Configuration

Source: https://effect.website/docs/observability/logging

This example demonstrates how to dynamically load the desired log level from configuration and apply it to the program using the `Logger.minimumLogLevel` layer. This allows for flexible control over logging verbosity based on external settings.

```typescript
import {
  Effect,
  Config,
  Logger,
  Layer,
  ConfigProvider,
  LogLevel
} from "effect"

// Simulate a program with logs
const program = Effect.gen(function* () {
  yield* Effect.logError("ERROR!")
  yield* Effect.logWarning("WARNING!")
  yield* Effect.logInfo("INFO!")
  yield* Effect.logDebug("DEBUG!")
})

// Load the log level from the configuration and apply it as a layer
```

--------------------------------

### Non-Interactive Create Effect App from example

Source: https://effect.website/docs/getting-started/create-effect-app

Demonstrates non-interactive usage of create-effect-app to create a project directly from a public GitHub example, such as 'http-server'.

```bash
create-effect-app (-e, --example http-server)
```

--------------------------------

### Setup EffectJS Project for Bun

Source: https://effect.website/docs/getting-started/installation

Initializes a new Bun project, configures TypeScript with strict mode, adds the EffectJS package, and creates a simple 'Hello, World!' program. The program is executed using the Bun runtime.

```bash
mkdir hello-effect
cd hello-effect
bun init
```

```json
{
  "compilerOptions": {
    "strict": true
  }
}
```

```bash
bun add effect
```

```typescript
1 import { Effect, Console } from "effect" 
2 
3 const program = Console.log("Hello, World!") 
4 
5 Effect.runSync(program)
```

```bash
bun index.ts
```

--------------------------------

### EffectJS Forking a Fiber Example

Source: https://effect.website/docs/micro/new-users

Demonstrates the fundamental way to create a new fiber using `Micro.fork`. This starts an effect on a separate fiber, returning a reference to the new fiber. The example shows forking a recursive Fibonacci calculation.

```typescript
import { Micro } from "effect"

const fib = (n: number): Micro.Micro =>
  n < 2 
  ? Micro.succeed(n)
  : Micro.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)

const fib10Fiber = Micro.fork(fib(10))
```

--------------------------------

### Install Effect and OpenTelemetry Dependencies with pnpm

Source: https://effect.website/docs/observability/tracing

Installs the Effect library, the Effect-OpenTelemetry integration, and necessary OpenTelemetry packages for trace export via HTTP (OTLP) and Node.js/web SDKs using pnpm.

```bash
# If not already installed
pnpm add effect
# Required to integrate Effect with OpenTelemetry
pnpm add @effect/opentelemetry
# Required to export traces over HTTP in OTLP format
pnpm add @opentelemetry/exporter-trace-otlp-http
# Required by all applications
pnpm add @opentelemetry/sdk-trace-base
# For NodeJS applications
pnpm add @opentelemetry/sdk-trace-node
# For browser applications
pnpm add @opentelemetry/sdk-trace-web
# If you also need to export metrics
pnpm add @opentelemetry/sdk-metrics
```

--------------------------------

### Launching an HTTP Server Layer with Layer.launch (TypeScript)

Source: https://effect.website/docs/requirements-management/layers

This example demonstrates how to convert a Layer into an Effect that keeps the layer alive using Layer.launch. It simulates an HTTP server Layer that logs a startup message and then runs this layer indefinitely.

```typescript
import { Console, Context, Effect, Layer } from "effect"

class HTTPServer extends Context.Tag("HTTPServer")() {}

// Simulating an HTTP server
const server = Layer.effect(
  HTTPServer,
  // Log a message to simulate a server starting
  Console.log("Listening on http://localhost:3000")
)

// Converts the layer to an effect and runs it
Effect.runFork(Layer.launch(server))
```

--------------------------------

### Provide Model to Effect Program (Effect)

Source: https://effect.website/docs/ai/getting-started

Demonstrates how to provide a created `Model` (in this case, `Gpt4o` for OpenAI) directly to an Effect program using `Effect.provide`. This makes the services provided by the model available to the program.

```typescript
import { OpenAiLanguageModel } from "@effect/ai-openai"
import { LanguageModel } from "@effect/ai"
import { Effect } from "effect"

// ┌─── Model<"openai", LanguageModel | ProviderName, OpenAiClient>
// ▼
const Gpt4o = OpenAiLanguageModel.model("gpt-4o")

// ┌─── Effect, AiError, OpenAiClient>
// ▼
const program = LanguageModel.generateText({
  prompt: "Generate a dad joke"
}).pipe(Effect.provide(Gpt4o))
```

--------------------------------

### Install Effect and OpenTelemetry Dependencies with Yarn

Source: https://effect.website/docs/observability/tracing

Installs the Effect library, the Effect-OpenTelemetry integration, and necessary OpenTelemetry packages for trace export via HTTP (OTLP) and Node.js/web SDKs using Yarn.

```bash
# If not already installed
yarn add effect
# Required to integrate Effect with OpenTelemetry
yarn add @effect/opentelemetry
# Required to export traces over HTTP in OTLP format
yarn add @opentelemetry/exporter-trace-otlp-http
# Required by all applications
yarn add @opentelemetry/sdk-trace-base
# For NodeJS applications
yarn add @opentelemetry/sdk-trace-node
# For browser applications
yarn add @opentelemetry/sdk-trace-web
# If you also need to export metrics
yarn add @opentelemetry/sdk-metrics
```

--------------------------------

### Install Effect Platform Bun Package

Source: https://effect.website/docs/platform/introduction

Installs the Bun-specific package for Effect Platform, enabling the use of Bun-specific services and contexts.

```bash
bun add @effect/platform-bun
```

--------------------------------

### Basic Configuration Retrieval (Effect-TS)

Source: https://effect.website/docs/configuration

Retrieves 'HOST' and 'PORT' environment variables and logs the application start URL. Requires 'HOST' and 'PORT' to be set in the environment.

```typescript
import { Effect, Config } from "effect"

const program = Effect.gen(function* () {
  const hostPort = yield* Config.all([
    Config.string("HOST"),
    Config.number("PORT")
  ]);
  console.log(`Application started: ${hostPort.url}`)
});

Effect.runPromise(program)
```

--------------------------------

### Start OpenTelemetry Backend with Docker

Source: https://effect.website/docs/observability/tracing

This command starts the OpenTelemetry backend using a preconfigured Grafana Docker image. It exposes ports for OTLP trace and metric collection, and the Grafana UI.

```bash
docker run -p 3000:3000 -p 4317:4317 -p 4318:4318 --rm -it docker.io/grafana/otel-lgtm
```

--------------------------------

### Setting Up and Printing a Span (Effect/TypeScript)

Source: https://effect.website/docs/observability/tracing

This example demonstrates setting up OpenTelemetry tracing and printing spans to the console. It configures `NodeSdk` to use `ConsoleSpanExporter` and `BatchSpanProcessor`, then runs an instrumented effect, providing the tracing layer.

```typescript
import { Effect } from "effect"
import { NodeSdk } from "@effect/opentelemetry"
import {
 ConsoleSpanExporter,
 BatchSpanProcessor
} from "@opentelemetry/sdk-trace-base"

// Define an effect that delays for 100 milliseconds
const program = Effect.void.pipe(Effect.delay("100 millis"))

// Instrument the effect with a span for tracing
const instrumented = program.pipe(Effect.withSpan("myspan"))

// Set up tracing with the OpenTelemetry SDK
const NodeSdkLive = NodeSdk.layer(() => ({
 resource: { serviceName: "example" },
 // Export span data to the console
 spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())
}))

// Run the effect, providing the tracing layer
Effect.runPromise(instrumented.pipe(Effect.provide(NodeSdkLive)))
```

--------------------------------

### Install Effect Package (yarn)

Source: https://context7_llms

Instructions for installing the Effect TypeScript package using yarn. This command ensures you have the necessary Effect modules for your project.

```bash
yarn add @effect/io
```

--------------------------------

### Provide Model to Multiple Programs (Effect)

Source: https://effect.website/docs/ai/getting-started

Shows the reusability of a `Model` by providing it to multiple Effect programs. In this example, the `Gpt4o` model is provided once to a parent effect that executes `generateDadJoke` multiple times, demonstrating flexibility.

```typescript
import { OpenAiLanguageModel } from "@effect/ai-openai"
import { LanguageModel } from "@effect/ai"
import { Effect } from "effect"

const generateDadJoke = Effect.gen(function*() {
  const response = yield* LanguageModel.generateText({
    prompt: "Generate a dad joke"
  })
  console.log(response.text)
  return response
})

const Gpt4o = OpenAiLanguageModel.model("gpt-4o")

const main = Effect.gen(function*() {
  // You can provide the `Model` individually to each
  // program, or to all of them at once (as we do here)
  const res1 = yield* generateDadJoke
  const res2 = yield* generateDadJoke
  const res3 = yield* generateDadJoke
}).pipe(Effect.provide(Gpt4o))
```

--------------------------------

### Install Effect Platform Node.js Package

Source: https://effect.website/docs/platform/introduction

Installs the Node.js-specific package for Effect Platform, enabling the use of Node.js-specific services and contexts.

```bash
npm install @effect/platform-node
```

```bash
pnpm add @effect/platform-node
```

```bash
yarn add @effect/platform-node
```

```bash
deno add npm:@effect/platform-node
```

--------------------------------

### Delay Allows Fiber to Capture All Values - Effect-TS

Source: https://effect.website/docs/concurrency/fibers

This example demonstrates how introducing a delay with Effect.sleep allows a forked fiber to start in time to capture all values from a SubscriptionRef. It contrasts with the previous example where the fiber started too late. Dependencies include Effect, SubscriptionRef, Stream, and Console.

```typescript
import { Effect, SubscriptionRef, Stream, Console } from "effect"

const program = Effect.gen(function* () {
  const ref = yield* SubscriptionRef.make(0)
  yield* ref.changes.pipe(
    // Log each change in SubscriptionRef
    Stream.tap((n) => Console.log(`SubscriptionRef changed to ${n}`)),
    Stream.runDrain,
    // Fork a fiber to run the stream
    Effect.fork
  )

  // Allow the fiber a chance to start
  yield* Effect.sleep("100 millis")

  yield* SubscriptionRef.set(ref, 1)
  yield* SubscriptionRef.set(ref, 2)
})

Effect.runFork(program)
```

--------------------------------

### Async Promise Equivalent with Effect-TS Fork

Source: https://effect.website/docs/additional-resources/effect-vs-promise

This example shows how to replicate the behavior of starting a Promise without immediately awaiting it in Effect-TS. It uses `Effect.fork` to run an effect concurrently and `Fiber.join` to retrieve its result later, mimicking the non-blocking nature of `new Promise()`.

```typescript
import { Effect, Fiber } from "effect"

const task = (delay: number, name: string) =>
  Effect.gen(function* () {
    yield* Effect.sleep(delay)
    console.log(`${name} done`)
    return name
  })

const program = Effect.gen(function* () {
  const r0 = yield* Effect.fork(task(2000, "long running task"))
  const r1 = yield* task(200, "task 2")
  const r2 = yield* task(100, "task 3")
  return {
    r1,
    r2,
    r0: yield* Fiber.join(r0)
  }
})

Effect.runPromise(program).then(console.log)
```

--------------------------------

### Install Effect Package with Bun

Source: https://effect.website/docs/getting-started/importing-effect

Installs the 'effect' package using Bun. This command is suitable for projects using the Bun runtime and package manager.

```bash
bun add effect
```

--------------------------------

### Using Default Clock and Console Services - Effect.js

Source: https://effect.website/docs/requirements-management/default-services

This example demonstrates how to use the default Clock and Console services within an Effect.js program. Effect automatically supplies live versions of these services, simplifying setup. The program retrieves the current time in milliseconds and logs it to the console.

```typescript
import { Effect, Clock, Console } from "effect"

const program = Effect.gen(function* () {
  const now = yield* Clock.currentTimeMillis
  yield* Console.log(`Application started at ${new Date(now)}`)
})

Effect.runFork(program)
```

--------------------------------

### Abstracting LLM Interactions into a Service

Source: https://effect.website/docs/ai/getting-started

Illustrates how to abstract Language Model dependencies into a service, allowing consuming programs to depend only on the service interface, not the underlying AI requirements. This is achieved using Effect's Layer composition.

```typescript
import { AnthropicLanguageModel } from "@effect/ai-anthropic"
import { OpenAiLanguageModel } from "@effect/ai-openai"
import { LanguageModel } from "@effect/ai"
import { Effect } from "effect"

const Gpt4o = OpenAiLanguageModel.model("gpt-4o")
const Claude37 = AnthropicLanguageModel.model("claude-3-7-sonnet-latest")

class DadJokes extends Effect.Service()("app/DadJokes", {
  effect: Effect.gen(function* () {
    const gpt = yield* Gpt4o
    const claude = yield* Claude37

    const generateDadJoke = Effect.gen(function* () {
      const response = yield* LanguageModel.generateText({
        prompt: "Generate a dad joke"
      })
      console.log(response.text)
      return response
    })

    return {
      generateDadJoke: Effect.provide(generateDadJoke, gpt),
      generateBetterDadJoke: Effect.provide(generateDadJoke, claude)
    }
  })
}) {}

const main = Effect.gen(function* () {
  const dadJokes = yield* DadJokes
  const res1 = yield* dadJokes.generateDadJoke
  const res2 = yield* dadJokes.generateBetterDadJoke
})

DadJokes.Default
```

--------------------------------

### Mixing Providers and Models with Effect. AI

Source: https://effect.website/docs/ai/getting-started

Demonstrates how to combine different language models from various providers (Anthropic, OpenAI) within a single Effect program. It shows how Effect's type-level dependency tracking helps manage these integrations.

```typescript
import { AnthropicLanguageModel } from "@effect/ai-anthropic"
import { OpenAiLanguageModel } from "@effect/ai-openai"
import { LanguageModel } from "@effect/ai"
import { Effect } from "effect"

const generateDadJoke = Effect.gen(function* () {
  const response = yield* LanguageModel.generateText({
    prompt: "Generate a dad joke"
  })
  console.log(response.text)
  return response
})

const Gpt4o = OpenAiLanguageModel.model("gpt-4o")
const Claude37 = AnthropicLanguageModel.model("claude-3-7-sonnet-latest")

const main = Effect.gen(function* () {
  const res1 = yield* generateDadJoke
  const res2 = yield* generateDadJoke
  const res3 = yield* Effect.provide(generateDadJoke, Claude37)
}).pipe(Effect.provide(Gpt4o))
```

--------------------------------

### Install Effect Package with Yarn

Source: https://effect.website/docs/getting-started/importing-effect

Installs the 'effect' package using Yarn. Use this command if your project utilizes Yarn for package management.

```bash
yarn add effect
```

--------------------------------

### Install EffectJS with npm/yarn/pnpm

Source: https://effect.website/docs/getting-started/installation

Installs the core EffectJS package using package managers like npm, pnpm, or yarn. This is the foundational step for any EffectJS project.

```bash
pnpm add effect
```

```bash
yarn add effect
```

```bash
npm install effect
```

--------------------------------

### Build a Transaction Pipeline with Effect.js

Source: https://effect.website/docs/getting-started/building-pipelines

This example demonstrates building a transaction processing pipeline using Effect.js. It chains multiple effects together using `pipe`, `Effect.all`, and `Effect.andThen` to fetch data, apply discounts, add service charges, and format the final output. Dependencies include the 'effect' library.

```typescript
import { Effect, pipe } from "effect"

const addServiceCharge = (amount: number) => amount + 1

const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100);

const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100));
const fetchDiscountRate = Effect.promise(() => Promise.resolve(5));

const program = pipe(
  Effect.all([fetchTransactionAmount, fetchDiscountRate]),
  Effect.andThen(([transactionAmount, discountRate]) => 
    applyDiscount(transactionAmount, discountRate)
  ),
  Effect.andThen(addServiceCharge),
  Effect.andThen(
    (finalAmount) => `Final amount to charge: ${finalAmount}`
  )
);

Effect.runPromise(program).then(console.log);
```

--------------------------------

### Install Effect Package with pnpm

Source: https://effect.website/docs/getting-started/importing-effect

Installs the 'effect' package using pnpm. This command is an alternative for projects managed with pnpm.

```bash
pnpm add effect
```

--------------------------------

### Creating a Test Instance of Database Service in Effect.js

Source: https://effect.website/docs/requirements-management/layers

This example demonstrates creating a test instance of the Database service in Effect.js. It simulates a 'query' function that returns an empty array, illustrating how to provide a concrete implementation for a service tag.

```typescript
import { Effect, Context } from "effect"

// Assuming Config, Logger, and Database tags are already declared
class Config extends Context.Tag("Config")() {}
class Logger extends Context.Tag("Logger")() {}
class Database extends Context.Tag("Database")<Database, {
  readonly query: (sql: string) => Effect.Effect
}>() {}

// Declaring a test instance of the Database service
const DatabaseTest = Database.of({
  // Simulating a simple response
  query: (sql: string) => Effect.succeed([])
})
```

--------------------------------

### Late Fiber Start Captures Only One Value - Effect-TS

Source: https://effect.website/docs/concurrency/fibers

This example demonstrates a scenario where a forked fiber, started after a value update, only captures a single value from a SubscriptionRef. It highlights the importance of fiber timing. Dependencies include Effect, SubscriptionRef, Stream, and Console.

```typescript
import { Effect, SubscriptionRef, Stream, Console } from "effect"

const program = Effect.gen(function* () {
  const ref = yield* SubscriptionRef.make(0)
  yield* ref.changes.pipe(
    // Log each change in SubscriptionRef
    Stream.tap((n) => Console.log(`SubscriptionRef changed to ${n}`)),
    Stream.runDrain,
    // Fork a fiber to run the stream
    Effect.fork
  )
  yield* SubscriptionRef.set(ref, 1)
  yield* SubscriptionRef.set(ref, 2)
})

Effect.runFork(program)
```

--------------------------------

### Sequential Effect Execution Example

Source: https://effect.website/docs/concurrency/basic-concurrency

Demonstrates sequential execution of effects using Effect.all. Each effect starts only after the previous one has completed, with logs showing the order of execution. This is the default behavior when no concurrency option is specified.

```typescript
import { Effect, Duration } from "effect"

// Helper function to simulate a task with a delay
const makeTask = (n: number, delay: Duration.DurationInput) =>
  Effect.promise(
    () =>
      new Promise((resolve) => {
        console.log(`start task${n}`)
        setTimeout(() => {
          console.log(`task${n} done`)
          resolve()
        }, Duration.toMillis(delay))
      })
  )

const task1 = makeTask(1, "200 millis")
const task2 = makeTask(2, "100 millis")

const sequential = Effect.all([task1, task2])

Effect.runPromise(sequential)
/*
Output:
start task1
task1 done
start task2 <-- task2 starts only after task1 completes
task2 done
*/
```

--------------------------------

### Install @effect/experimental using npm, pnpm, or yarn

Source: https://effect.website/docs/getting-started/devtools

Commands to install the @effect/experimental package using different JavaScript package managers. This package is necessary for utilizing the experimental DevTools.

```bash
npm install @effect/experimental
```

```bash
pnpm install @effect/experimental
```

```bash
yarn add @effect/experimental
```

```bash
bun add @effect/experimental
```

--------------------------------

### Install Effect Package with npm

Source: https://effect.website/docs/getting-started/importing-effect

Installs the 'effect' package using npm. This is the primary command for integrating the Effect library into your project.

```bash
npm install effect
```

--------------------------------

### Providing Configuration to a Nested Workflow (JavaScript)

Source: https://effect.website/docs/runtime

Demonstrates applying a custom logger configuration only to a specific nested section of a program using Effect.provide. The example highlights how the configuration is localized and reverts after the nested block.

```javascript
import { Logger, Effect } from "effect"

const addSimpleLogger = Logger.replace(
  Logger.defaultLogger,
  Logger.make(({ message }) => console.log(message))
)

const nestedProgram = Effect.gen(function* () {
  yield* Effect.log("Inside nested program")
})

const mainProgram = Effect.gen(function* () {
  yield* Effect.log("Before nested program")
  yield* nestedProgram.pipe(Effect.provide(addSimpleLogger))
  yield* Effect.log("After nested program")
})

Effect.runFork(mainProgram)
/* 
Output:
timestamp=... level=INFO fiber=#0 message="Before nested program"
[ 'Inside nested program' ]
timestamp=... level=INFO fiber=#0 message="After nested program"
*/
```

--------------------------------

### Define OpenAI Model for LanguageModel Service (Effect)

Source: https://effect.website/docs/ai/getting-started

Illustrates the creation of a specific `Model` instance for interacting with OpenAI's GPT-4o model. This `Model` provides the `LanguageModel` service and requires an `OpenAiClient`.

```typescript
import { OpenAiLanguageModel } from "@effect/ai-openai"

// ┌─── Model<"openai", LanguageModel | ProviderName, OpenAiClient>
// ▼
const Gpt4o = OpenAiLanguageModel.model("gpt-4o")
```

--------------------------------

### Configure OpenAI Client Layer with EffectJS

Source: https://effect.website/docs/ai/getting-started

This snippet demonstrates how to create a configurable `OpenAiClient` layer using EffectJS. It utilizes `layerConfig` to read the API key from configuration, ensuring it's handled securely. This layer can then be provided to other effects.

```typescript
import { OpenAiClient } from "@effect/ai-openai"
import { Config, Layer } from "effect"

// Create a `Layer` which produces an `OpenAiClient` and requires
// an `HttpClient`
const OpenAi = OpenAiClient.layerConfig({
  apiKey: Config.redacted("OPENAI_API_KEY")
})
```

--------------------------------

### Provide NodeHttpClient to OpenAI Layer in EffectJS

Source: https://effect.website/docs/ai/getting-started

This code illustrates how to provide a platform-specific `HttpClient` implementation to the `OpenAi` layer. It uses `Layer.provide` to integrate `NodeHttpClient.layerUndici`, making the OpenAI client ready for use in a Node.js environment.

```typescript
import { OpenAiClient } from "@effect/ai-openai"
import { NodeHttpClient } from "@effect/platform-node"
import { Layer } from "effect"

// Assume OpenAi layer is defined as above
const OpenAi = OpenAiClient.layerConfig({
  apiKey: Config.redacted("OPENAI_API_KEY")
})

// Provide a platform-specific implementation of `HttpClient` to our
// OpenAi layer
const OpenAiWithHttp = Layer.provide(OpenAi, NodeHttpClient.layerUndici)
```

--------------------------------

### Create and Run a Basic EffectJS Program (Node.js/tsx)

Source: https://effect.website/docs/getting-started/installation

Sets up a minimal EffectJS project directory and a simple TypeScript file that logs 'Hello, World!' to the console. The program is executed using tsx.

```bash
mkdir src
touch src/index.ts
```

```typescript
1 import { Effect, Console } from "effect" 
2 
3 const program = Console.log("Hello, World!") 
4 
5 Effect.runSync(program)
```

```bash
npx tsx src/index.ts
```

--------------------------------

### Install Effect Package with Deno

Source: https://effect.website/docs/getting-started/importing-effect

Installs the 'effect' package for Deno using npm compatibility. This command allows Deno projects to leverage npm packages.

```bash
deno add npm:effect
```

--------------------------------

### Compose and Provide Layers (Effect.js)

Source: https://effect.website/docs/requirements-management/layers

Demonstrates composing multiple layers using Layer.merge and Layer.provideMerge, then providing the composed layer to an effect. This allows for flexible dependency management and application setup.

```typescript
import { Effect, Context, Layer } from "effect"

// Assuming Config, Logger, and Database layers are defined as above

const ConfigLive = Layer.succeed(class Config extends Context.Tag("Config") {}, {
  getConfig: Effect.succeed({
    logLevel: "INFO",
    connection: "mysql://username:password@hostname:port/database_name"
  })
})

class Logger extends Context.Tag("Logger")<Logger, { readonly log: (message: string) => Effect.Effect }>() {}
const LoggerLive = Layer.effect(Logger, Effect.gen(function* () {
  const config = yield* Config
  return {
    log: (message) => Effect.gen(function* () {
      const { logLevel } = yield* config.getConfig
      console.log(`[${logLevel}] ${message}`)
    })
  }
}))

class Database extends Context.Tag("Database")<Database, { readonly query: (sql: string) => Effect.Effect }>() {}
const DatabaseLive = Layer.effect(Database, Effect.gen(function* () {
  const config = yield* Config
  const logger = yield* Logger
  return {
    query: (sql: string) => Effect.gen(function* () {
      yield* logger.log(`Executing query: ${sql}`)
      const { connection } = yield* config.getConfig
      return { result: `Results from ${connection}` }
    })
  }
}))

const AppConfigLive = Layer.merge(ConfigLive, LoggerLive)

const MainLive = DatabaseLive.pipe(
  Layer.provide(AppConfigLive),
  Layer.provideMerge(ConfigLive)
)

// Example of providing the MainLive layer to an effect
const program = Effect.gen(function* () {
  const db = yield* Database
  return yield* db.query("SELECT * FROM users")
})

Effect.runPromise(Effect.provide(program, MainLive))
```

--------------------------------

### Run a Command and Print Output as String

Source: https://effect.website/docs/platform/command

This example shows how to run a command and capture its output as a string using `Command.string`. It requires a `CommandExecutor` (provided by `@effect/platform-node/NodeContext`) and uses `NodeRuntime.runMain` to execute the Effect program. The output is then logged to the console.

```typescript
import { Command } from "@effect/platform"
import { NodeContext, NodeRuntime } from "@effect/platform-node"
import { Effect } from "effect"

const command = Command.make("ls", "-al")

// The program depends on a CommandExecutor
const program = Effect.gen(function* () {
  // Runs the command returning the output as a string
  const output = yield* Command.string(command)
  console.log(output)
})

// Provide the necessary CommandExecutor
NodeRuntime.runMain(program.pipe(Effect.provide(NodeContext.layer)))
```

--------------------------------

### Test Database Connectivity and Run Startup Checks

Source: https://effect.website/docs/getting-started/building-pipelines

This snippet demonstrates how to test database connectivity using Effect.promise and combine it with other effects like web configuration checks using Effect.all. It then runs these startup checks and logs the results. Dependencies include the 'effect' library.

```typescript
import { Effect } from "effect"

// Assume webConfig is defined elsewhere and is an Effect
const webConfig = Effect.succeed({"dbConnection": "localhost", "port": 8080});

const checkDatabaseConnectivity = Effect.promise(() => 
  Promise.resolve("Connected to Database")
);

const startupChecks = Effect.all([webConfig, checkDatabaseConnectivity]);

Effect.runPromise(startupChecks).then(([config, dbStatus]) => {
  console.log(
    `Configuration: ${JSON.stringify(config)}\nDB Status: ${dbStatus}`
  );
});
```

--------------------------------

### Create and Use Bounded PubSub - Effect.js

Source: https://effect.website/docs/concurrency/pubsub

Demonstrates creating a bounded PubSub and subscribing to it. Messages published to the PubSub are received by all subscribers. This example uses Effect.js's PubSub and Queue APIs.

```typescript
import { Effect, PubSub, Queue } from "effect"

const program = Effect.scoped(
  Effect.gen(function* () {
    const pubsub = yield* PubSub.bounded(2)

    // Two subscribers
    const dequeue1 = yield* PubSub.subscribe(pubsub)
    const dequeue2 = yield* PubSub.subscribe(pubsub)

    // Publish a message to the pubsub
    yield* PubSub.publish(pubsub, "Hello from a PubSub!")

    // Each subscriber receives the message
    console.log("Subscriber 1: " + (yield* Queue.take(dequeue1)))
    console.log("Subscriber 2: " + (yield* Queue.take(dequeue2)))
  })
)

Effect.runFork(program)
/* 
Output:
Subscriber 1: Hello from a PubSub!
Subscriber 2: Hello from a PubSub!
*/
```

--------------------------------

### Install Effect Language Service (Bun)

Source: https://effect.website/docs/getting-started/devtools

Installs the Effect Language Service as a development dependency using Bun. This command should be run in the terminal within your project directory.

```bash
bun add --dev @effect/language-service
```

--------------------------------

### GET /todos

Source: https://effect.website/docs/batching

Fetches a list of todos from an external API.

```APIDOC
## GET /todos

### Description
Fetches a list of todos from an external API.

### Method
GET

### Endpoint
https://api.example.demo/todos

### Parameters

### Request Body
None

### Request Example
None

### Response
#### Success Response (200)
- **Array of Todo objects** (Array<Todo>) - A list of todo items.

#### Response Example
```json
[
  {
    "_tag": "Todo",
    "id": 1,
    "message": "Buy groceries",
    "ownerId": 101
  }
]
```
```

--------------------------------

### Accessing and Running a Service with Effect.Service

Source: https://effect.website/docs/requirements-management/layers

Demonstrates how to access a service defined with Effect.Service within an Effect program and run it with provided dependencies. This example shows accessing the Cache service and handling potential errors during file lookup.

```typescript
import { FileSystem } from "@effect/platform"
import { NodeFileSystem } from "@effect/platform-node"
import { Effect, Console } from "effect"

// Define a Cache service
class Cache extends Effect.Service()("app/Cache", {
  effect: Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem
    const lookup = (key: string) => fs.readFileString(`cache/${key}`)
    return { lookup } as const
  }),
  dependencies: [NodeFileSystem.layer]
}) {}

// Accessing the Cache Service
const program = Effect.gen(function* () {
  const cache = yield* Cache
  const data = yield* cache.lookup("my-key")
  console.log(data)
}).pipe(Effect.catchAllCause((cause) => Console.log(cause)))

const runnable = program.pipe(Effect.provide(Cache.Default))

Effect.runFork(runnable)
```

--------------------------------

### Log at Info Level with Effect.js

Source: https://effect.website/docs/observability/logging

Provides an example of logging messages specifically at the `INFO` level using `Effect.logInfo`. This is the default level and is typically used for general application events.

```typescript
import { Effect } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.logInfo("start")
  yield* Effect.sleep("2 seconds")
  yield* Effect.sleep("1 second")
  yield* Effect.logInfo("done")
})

Effect.runFork(program)
/* 
Output:
timestamp=... level=INFO message=start 
timestamp=... level=INFO message=done <-- 3 seconds later 
*/
```

--------------------------------

### Create a New Effect App

Source: https://context7_llms

Command to quickly set up a new Effect application using a customizable template. This streamlines the initial project configuration.

```bash
npm create effect-app@latest
```

--------------------------------

### Overriding Logger Configuration with Effect.provide (JavaScript)

Source: https://effect.website/docs/runtime

Illustrates how to temporarily override the default logger with a custom implementation using Effect.provide. The example shows a program logging messages with and without timestamps/levels, demonstrating the effect of the provided configuration.

```javascript
import { Logger, Effect } from "effect"

const addSimpleLogger = Logger.replace(
  Logger.defaultLogger,
  // Custom logger implementation
  Logger.make(({ message }) => console.log(message))
)

const program = Effect.gen(function* () {
  yield* Effect.log("Application started!")
  yield* Effect.log("Application is about to exit!")
})

// Running with the default logger
Effect.runFork(program)
/* 
Output:
timestamp=... level=INFO fiber=#0 message="Application started!"
timestamp=... level=INFO fiber=#0 message="Application is about to exit!"
*/

// Overriding the default logger with a custom one
Effect.runFork(program.pipe(Effect.provide(addSimpleLogger)))
/* 
Output:
[ 'Application started!' ]
[ 'Application is about to exit!' ]
*/
```

--------------------------------

### Observe Fiber Completion Without Interruption (TypeScript)

Source: https://effect.website/docs/micro/new-users

This example shows a program running to completion without any interruption. `Micro.runPromiseExit` is used to execute the program and log its final `MicroExit` status, which in this case is 'Success'.

```typescript
import { Micro } from "effect"

const program = Micro.gen(function* () {
  console.log("start")
  yield* Micro.sleep(2000)
  console.log("done")
})

Micro.runPromiseExit(program).then(console.log)
/*
Output:
start
done
{
  "_id": "MicroExit",
  "_tag": "Success"
}
*/
```

--------------------------------

### Configure Logging Level and Test with Mock ConfigProvider

Source: https://effect.website/docs/observability/logging

Demonstrates how to set a minimum log level and provide a mock configuration using ConfigProvider.fromMap for testing purposes. The output shows log messages filtered by the specified log level.

```typescript
const LogLevelLive = Config.logLevel("LOG_LEVEL").pipe(
  Effect.andThen((level) =>
    // Set the minimum log level
    Logger.minimumLogLevel(level)
  ),
  Layer.unwrapEffect // Convert the effect into a layer
)

// Provide the loaded log level to the program
const configured = Effect.provide(program, LogLevelLive)

// Test the program using a mock configuration provider
const test = Effect.provide(
  configured,
  Layer.setConfigProvider(
    ConfigProvider.fromMap(
      new Map([["LOG_LEVEL", LogLevel.Warning.label]])
    )
  )
)

Effect.runFork(test)
/*
Output:
... level=ERROR fiber=#0 message=ERROR!
... level=WARN fiber=#0 message=WARNING!
*/
```

--------------------------------

### Define Schema for Configuration (Effect/TypeScript)

Source: https://effect.website/docs/configuration

Illustrates how to define a configuration schema using Effect's Schema module. This example creates a configuration expecting a string named 'Foo' with a minimum length of 4 characters.

```typescript
import { Effect, Schema } from "effect"

// Define a config that expects a string with at least 4 characters
const myConfig = Schema.Config(
  "Foo",
  Schema.String.pipe(Schema.minLength(4))
)
```

--------------------------------

### Provide Default Configuration Values (Effect/TypeScript)

Source: https://effect.website/docs/configuration

Shows how to provide default values for configuration parameters using Config.withDefault. If an environment variable is not set, the specified default value is used. This example sets a default port of 8080.

```typescript
import { Effect, Config } from "effect"

const program = Effect.gen(function* () {
  const host = yield* Config.string("HOST")
  // Use default 8080 if PORT is not set
  const port = yield* Config.number("PORT").pipe(Config.withDefault(8080))
  console.log(`Application started: ${host}:${port}`)
})

Effect.runPromise(program)
```

--------------------------------

### Generate Dad Joke with LanguageModel Service (Effect)

Source: https://effect.website/docs/ai/getting-started

Demonstrates generating text using the abstract `LanguageModel` service from `@effect/ai`. This code defines the business logic for generating a dad joke without specifying a particular LLM provider. It relies on the `LanguageModel` service being provided to the program.

```typescript
import { LanguageModel } from "@effect/ai"
import { Effect } from "effect"

// Using `LanguageModel` will add it to your program's requirements
const generateDadJoke = Effect.gen(function*() {
  // Use the `LanguageModel` to generate some text
  const response = yield* LanguageModel.generateText({
    prompt: "Generate a dad joke"
  })
  // Log the generated text to the console
  console.log(response.text)
  // Return the response
  return response
})
```

--------------------------------

### Generate Dad Joke with OpenAI and EffectJS

Source: https://effect.website/docs/ai/getting-started

This code defines a function to generate a dad joke using OpenAI's language model through the EffectJS framework. It sets up the necessary layers and provides the specific model to use. The final program executes this generation and runs it as a promise.

```typescript
import { OpenAiClient, OpenAiLanguageModel } from "@effect/ai-openai"
import { LanguageModel } from "@effect/ai"
import { NodeHttpClient } from "@effect/platform-node"
import { Config, Effect, Layer } from "effect"

const generateDadJoke = Effect.gen(function*() {
  const response = yield* LanguageModel.generateText({
    prompt: "Generate a dad joke"
  })
  console.log(response.text)
  return response
})

const Gpt4o = OpenAiLanguageModel.model("gpt-4o")

const main = generateDadJoke.pipe(
  Effect.provide(Gpt4o)
)

const OpenAi = OpenAiClient.layerConfig({
  apiKey: Config.redacted("OPENAI_API_KEY")
})

const OpenAiWithHttp = Layer.provide(OpenAi, NodeHttpClient.layerUndici)

main.pipe(
  Effect.provide(OpenAiWithHttp),
  Effect.runPromise
)
```

--------------------------------

### Spaced Schedule: Recur with Delay Between Executions

Source: https://effect.website/docs/scheduling/built-in-schedules

Demonstrates the `Schedule.spaced` schedule, which repeats indefinitely with a specified duration between the end of one run and the start of the next. The example shows delays when the action takes 100ms and the schedule is spaced by 200ms.

```typescript
import { Array, Chunk, Duration, Effect, Schedule } from "effect"

const log = (
  schedule: Schedule.Schedule,
  delay: Duration.DurationInput = 0
): void => {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () => delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) => {
    console.log(
      i === maxRecurs
        ? "..."
        : i === delays.length - 1
        ? "(end)"
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.spaced("200 millis")

// ┌─── Simulating an effect that takes
// │ 100 milliseconds to complete
// ▼
log(schedule, "100 millis")
```

--------------------------------

### Scaffold Vite + React Project with EffectJS

Source: https://effect.website/docs/getting-started/installation

Creates a new Vite project with the React and TypeScript template. It then installs project dependencies and adds EffectJS as a library. The tsconfig.json is verified for strict mode.

```bash
# npm 6.x
npm create vite@latest hello-effect --template react-ts

# npm 7+, extra double-dash is needed
npm create vite@latest hello-effect -- --template react-ts

pnpm create vite@latest hello-effect -- --template react-ts

yarn create vite@latest hello-effect -- --template react-ts

bun create vite@latest hello-effect -- --template react-ts

denom init --npm vite@latest hello-effect -- --template react-ts
```

```bash
cd hello-effect
npm install

pnpm install

yarn install

bun install

denom install
```

```json
{
  "compilerOptions": {
    "strict": true
  }
}
```

```bash
npm install effect

pnpm add effect

yarn add effect

bun add effect

denom add effect
```

--------------------------------

### Decoding and Encoding Examples with Product Schema

Source: https://effect.website/docs/schema/advanced-usage

Demonstrates decoding unknown data synchronously and encoding a Product schema, including handling null values and empty objects. It shows how 'Schema.NumberFromString' interacts with optional fields.

```javascript
console.log(Schema.decodeUnknownSync(Product)({ quantity: null }))
// Output: {}
```

```javascript
console.log(Schema.encodeSync(Product)({ quantity: 1 }))
// Output: { quantity: "1" }
```

```javascript
console.log(Schema.encodeSync(Product)({}))
// Output: {}
```

--------------------------------

### HashSet - Core Concepts and Usage

Source: https://effect.website/docs/data-types/hash-set

Demonstrates the core concepts of HashSet, including value equality, immutability, and usage with collections like HashSet.

```APIDOC
## HashSet - Core Concepts and Usage

This example illustrates how `HashSet` in Effect-TS handles value equality and immutability.

### Description

`HashSet` ensures that only unique values are stored based on their content, even if they are different object instances. Operations on `HashSet` return new instances, leaving the original unchanged.

### Example (Value Equality and Immutability)

```typescript
import { Equal, HashSet, pipe } from "effect"

// Using Schema.Data for structured data
import { Schema } from "effect"

const PersonSchema = Schema.Data(
  Schema.Struct({
    id: Schema.Number,
    name: Schema.String,
    age: Schema.Number
  })
)

const Person = Schema.decodeSync(PersonSchema)

const person1 = Person({ id: 1, name: "Alice", age: 30 })
const person2 = Person({ id: 1, name: "Alice", age: 30 })

// They are different object references
console.log(Object.is(person1, person2)) // Output: false

// But they are equal in value (based on content)
console.log(Equal.equals(person1, person2)) // Output: true

// Add both to a HashSet — only one will be stored
const set = pipe(
  HashSet.empty<typeof person1>(),
  HashSet.add(person1),
  HashSet.add(person2)
)

console.log(HashSet.size(set)) // Output: 1
```

### Key Features of HashSet

- **Immutable**: Operations return new sets.
- **Unique Values**: Stores only distinct values based on `Equal.equals`.
- **Efficient Operations**: Supports fast lookups, insertions, and deletions.
```

--------------------------------

### Feed Input to Command Standard Input

Source: https://effect.website/docs/platform/command

Illustrates how to provide data to a command's standard input using `Command.feed`. The example uses `cat` and feeds it the string "Hello", which is then echoed back as output.

```typescript
import { Command } from "@effect/platform"
import { NodeContext, NodeRuntime } from "@effect/platform-node"
import { Effect } from "effect"

const command = Command.make("cat").pipe(Command.feed("Hello"))

const program = Effect.gen(function* () {
  console.log(yield* Command.string(command))
})

NodeRuntime.runMain(program.pipe(Effect.provide(NodeContext.layer)))
```

--------------------------------

### Running Effect-TS Notifications Service Example

Source: https://effect.website/docs/runtime

This snippet demonstrates how to set up an Effect-TS runtime with the live Notifications service and execute an effect that uses it. It shows the lifecycle management of the runtime, including creation, running a promise-based effect, and disposal.

```typescript
// Example entry point for an external framework
async function main() {
  // Create a custom runtime using the Notifications layer
  const runtime = ManagedRuntime.make(NotificationsLive.Live)

  // Run the effect
  await runtime.runPromise(Notifications.notify("Hello, world!"))

  // Dispose of the runtime, cleaning up resources
  await runtime.dispose()
}

```

--------------------------------

### Install Effect Language Service (pnpm)

Source: https://effect.website/docs/getting-started/devtools

Installs the Effect Language Service as a development dependency using pnpm. This command should be run in the terminal within your project directory.

```bash
pnpm add -D @effect/language-service
```

--------------------------------

### Load Config from JSON with Nested Namespaces (Effect-TS)

Source: https://effect.website/docs/configuration

Illustrates how to load configuration values from a JSON object using ConfigProvider.fromJson. This example demonstrates reading nested configuration values like 'SERVER.PORT' and 'SERVER.HOST'.

```typescript
import { Config, ConfigProvider, Effect } from "effect"

const program = Effect.gen(function* () {
  // Read SERVER_HOST and SERVER_PORT as nested configuration values
  const port = yield* Config.nested(Config.number("PORT"), "SERVER")
  const host = yield* Config.nested(Config.string("HOST"), "SERVER")
  console.log(`Application started: ${host}:${port}`)
})

Effect.runPromise(
  Effect.withConfigProvider(
    program,
    ConfigProvider.fromJson(
      JSON.parse(`{"SERVER":{"PORT":8080,"HOST":"localhost"}}`)
    )
  )
)
```

--------------------------------

### Access Process Details (Exit Code, Stdout, Stderr)

Source: https://effect.website/docs/platform/command

Demonstrates how to start a command using `Command.start` and then access its `exitCode`, `stdout`, and `stderr` streams. The `stdout` and `stderr` streams are collected into strings for display.

```typescript
import { Command } from "@effect/platform"
import { NodeContext, NodeRuntime } from "@effect/platform-node"
import { Effect, Stream, String, pipe } from "effect"

// Helper function to collect stream output as a string
const runString = (
  stream: Stream.Stream
):
  Effect.Effect =>
  stream.pipe(
    Stream.decodeText(),
    Stream.runFold(String.empty, String.concat)
  )

const program = Effect.gen(function* () {
  const command = Command.make("ls")

  const [exitCode, stdout, stderr] = yield* pipe(
    // Start running the command and return a handle to the running process
    Command.start(command),
    Effect.flatMap((process) =>
      Effect.all (
        [
          // Waits for the process to exit and returns
          // the ExitCode of the command that was run
          process.exitCode,
          // The standard output stream of the process
          runString(process.stdout),
          // The standard error stream of the process
          runString(process.stderr)
        ],
        { concurrency: 3 }
      )
    )
  )
  console.log({ exitCode, stdout, stderr })
})

NodeRuntime.runMain(
  Effect.scoped(program).pipe(Effect.provide(NodeContext.layer))
)
```

--------------------------------

### Install Effect Language Service (npm)

Source: https://effect.website/docs/getting-started/devtools

Installs the Effect Language Service as a development dependency using npm. This command should be run in the terminal within your project directory.

```bash
npm install @effect/language-service --save-dev
```

--------------------------------

### Load Basic Environment Variables (Effect/TypeScript)

Source: https://effect.website/docs/configuration

Demonstrates loading 'HOST' as a string and 'PORT' as a number from environment variables using Effect's Config module. Requires environment variables to be set for successful execution. Errors are thrown if variables are missing.

```typescript
import { Effect, Config } from "effect"

// Define a program that loads HOST and PORT configuration
const program = Effect.gen(function* () {
  const host = yield* Config.string("HOST") // Read as a string
  const port = yield* Config.number("PORT") // Read as a number

  console.log(`Application started: ${host}:${port}`)
})

Effect.runPromise(program)
```

--------------------------------

### Create Effect App with specific template and ESLint

Source: https://effect.website/docs/getting-started/create-effect-app

Creates a new Effect project in a specified directory using a 'basic' template and enables ESLint integration for code quality. This is an example of non-interactive usage.

```bash
npx create-effect-app --template basic --eslint my-effect-app
```

--------------------------------

### Install Effect Language Service (Yarn)

Source: https://effect.website/docs/getting-started/devtools

Installs the Effect Language Service as a development dependency using Yarn. This command should be run in the terminal within your project directory.

```bash
yarn add --dev @effect/language-service
```

--------------------------------

### Basic Cross-Platform Path Handling with Effect Platform

Source: https://effect.website/docs/platform/introduction

A fundamental example using Effect Platform's Path module to join path segments. This code is designed to run across different JavaScript runtimes without modification.

```typescript
1 import { Path } from "@effect/platform"
2 import { Effect } from "effect"
3 
4 const program = Effect.gen(function* () {
5 // Access the Path service
6 const path = yield* Path.Path
7 
8 // Join parts of a path to create a complete file path
9 const mypath = path.join("tmp", "file.txt")
10 
11 console.log(mypath)
12 })

```

--------------------------------

### Effect TS: Automating TypeScript Patching with package.json

Source: https://effect.website/docs/getting-started/devtools

Illustrates how to automatically apply the TypeScript patch for Effect diagnostics during the package installation process by adding a 'prepare' script to package.json.

```json
{
  "scripts": {
    "prepare": "effect-language-service patch"
  }
}
```

--------------------------------

### Create and Use Summary for Response Times (TypeScript)

Source: https://effect.website/docs/observability/metrics

This snippet demonstrates how to create a Summary metric in TypeScript to track response times. It configures the summary with a maximum age, size, error margin, and specific quantiles. The example then applies this summary to an effect that simulates response times and logs the resulting state.

```typescript
import { Metric, Random, Effect } from "effect"

// Define the summary for response times
const responseTimeSummary = Metric.summary({
  name: "response_time_summary", // Name of the summary metric
  maxAge: "1 day", // Maximum sample age
  maxSize: 100, // Maximum number of samples to retain
  error: 0.03, // Error margin for quantile calculation
  quantiles: [0.1, 0.5, 0.9], // Quantiles to observe (10%, 50%, 90%)
  // Optional
  description: "Measures the distribution of response times"
})

const program = Effect.gen(function* () {
  // Record 100 random response times between 1 and 120 ms
  yield* responseTimeSummary(Random.nextIntBetween(1, 120)).pipe(
    Effect.repeatN(99)
  )

  // Retrieve and log the current state of the summary
  const state = yield* Metric.value(responseTimeSummary)
  console.log("%o", state)
})

Effect.runPromise(program)
```

--------------------------------

### Run a Successful Program with runMain (Node.js)

Source: https://effect.website/docs/platform/runtime

This example demonstrates how to use `runMain` from `@effect/platform-node` to execute a successful Effect. `runMain` handles the execution and ensures proper finalization. No output is produced for a successful run.

```typescript
import { NodeRuntime } from "@effect/platform-node"
import { Effect } from "effect"

const success = Effect.succeed("Hello, World!")

NodeRuntime.runMain(success)
// No Output
```

--------------------------------

### Effect.gen Example: Transactions with Discounts

Source: https://effect.website/docs/getting-started/using-generators

This example demonstrates using Effect.gen to orchestrate a series of asynchronous operations, including fetching transaction amounts and discount rates, and then applying a discount. It showcases error handling for invalid discount rates. The code relies on the 'effect' library.

```typescript
import { Effect } from "effect"

// Function to add a small service charge to a transaction amount
const addServiceCharge = (amount: number) => amount + 1

// Function to apply a discount safely to a transaction amount
const applyDiscount = (
    total: number,
    discountRate: number
): Effect.Effect =>
    discountRate === 0
        ? Effect.fail(new Error("Discount rate cannot be zero"))
        : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from a
// database
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

// Simulated asynchronous task to fetch a discount rate from a
// configuration file
const fetchDiscountRate = Effect.promise(() => Promise.resolve(5))

// Assembling the program using a generator function
const program = Effect.gen(function* () {
    // Retrieve the transaction amount
    const transactionAmount = yield* fetchTransactionAmount

    // Retrieve the discount rate
    const discountRate = yield* fetchDiscountRate

    // Calculate discounted
```

--------------------------------

### Disabling Logging with Logger.withMinimumLogLevel

Source: https://effect.website/docs/observability/logging

This example demonstrates how to disable all logging output by setting the minimum log level to `LogLevel.None` using `Logger.withMinimumLogLevel`. This is useful during testing or when no log output is desired.

```typescript
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.log("Executing task...")
  yield* Effect.sleep("100 millis")
  console.log("task done")
})

// Default behavior: logging enabled
// Effect.runFork(program)

// Disable logging by setting minimum log level to 'None'
Effect.runFork(program.pipe(Logger.withMinimumLogLevel(LogLevel.None)))
```

--------------------------------

### Define a Simple Resource with Acquire and Release

Source: https://effect.website/docs/micro/new-users

Demonstrates defining a resource using `Micro.acquireRelease`. It includes acquiring the resource, simulating its use, and releasing it. The `acquire` operation is uninterruptible, guaranteeing the `release` operation will run if acquisition succeeds.

```typescript
import { Micro } from "effect"

interface MyResource {
  readonly contents: string
  readonly close: () => Promise<void>
}

const getMyResource = (): Promise<MyResource> =>
  Promise.resolve({
    contents: "lorem ipsum",
    close: () =>
      new Promise((resolve) => {
        console.log("Resource released")
        resolve()
      })
  })

const acquire = Micro.tryPromise({
  try: () =>
    getMyResource().then((res) => {
      console.log("Resource acquired")
      return res
    }),
  catch: () => new Error("getMyResourceError")
})

const release = (res: MyResource) => Micro.promise(() => res.close())

const resource = Micro.acquireRelease(acquire, release)

const program = Micro.scoped(
  Micro.gen(function* () {
    const res = yield* resource
    console.log(`content is ${res.contents}`)
  })
)

Micro.runPromise(program)
/* 
Resource acquired
content is lorem ipsum
Resource released
*/
```

--------------------------------

### Creating Basic Effects (TypeScript)

Source: https://effect.website/docs/stream/introduction

Demonstrates the creation of various Effects, including those that fail, produce a single value, a chunk of values, or an optional value. These examples illustrate the single-result nature of Effects.

```typescript
import { Effect, Chunk, Option } from "effect"

// An Effect that fails with a string error
const failedEffect = Effect.fail("fail!")

// An Effect that produces a single number
const oneNumberValue = Effect.succeed(3)

// An Effect that produces a chunk of numbers
const oneListValue = Effect.succeed(Chunk.make(1, 2, 3))

// An Effect that produces an optional number
const oneOption = Effect.succeed(Option.some(1))
```

--------------------------------

### Example: Retain Initial Refinements with encodedBoundSchema - TypeScript

Source: https://effect.website/docs/schema/projections

This example demonstrates the usage of `Schema.encodedBoundSchema`. It shows how the original schema `Original` with a `minLength` refinement and a `Trim` transformation is processed. The resulting `EncodedBoundSchema` retains the `minLength(3)` but omits the `Schema.Trim` transformation, as intended.

```typescript
import { Schema } from "effect"

const Original = Schema.Struct({
  foo: Schema.String.pipe(
    Schema.minLength(3),
    Schema.compose(Schema.Trim)
  )
})

const EncodedBoundSchema = Schema.encodedBoundSchema(Original)

const EncodedBoundSchema2 = Schema.Struct({
  foo: Schema.String.pipe(Schema.minLength(3))
})
```

--------------------------------

### Read File Content as String using Effect Platform

Source: https://effect.website/docs/platform/file-system

Demonstrates how to read the content of a file as a string using the FileSystem service from @effect/platform. This example uses Effect.gen for asynchronous operations and NodeRuntime for execution in a Node.js environment. It requires importing FileSystem, NodeContext, NodeRuntime, and Effect.

```typescript
import { FileSystem } from "@effect/platform"
import { NodeContext, NodeRuntime } from "@effect/platform-node"
import { Effect } from "effect"

const program = Effect.gen(function* () {
  const fs = yield* FileSystem.FileSystem

  const content = yield* fs.readFileString("./index.ts", "utf8")
  console.log(content)
})

NodeRuntime.runMain(program.pipe(Effect.provide(NodeContext.layer)))
```

--------------------------------

### Apply Custom Cache Directly to a Program

Source: https://effect.website/docs/batching

This example shows how to create a custom cache using `Request.makeCache` and then apply it directly to a specific program segment using `Effect.withRequestCache`. This ensures that requests within that segment are managed by the custom cache, assuming caching is enabled.

```typescript
// Assuming 'myProgram' is a defined Effect program
const customCache = Request.makeCache({
  capacity: 128,
  timeToLive: "30 minutes"
});

const programWithDirectCache = Effect.withRequestCache(customCache)(myProgram);
```

--------------------------------

### Effect Logging with structuredLogger in TypeScript

Source: https://effect.website/docs/observability/logging

This example demonstrates the structuredLogger for detailed, object-based logs, useful for traceability and analysis. The Effect program is configured with Logger.structured, outputting logs as JSON objects.

```typescript
import { Effect, Logger } from "effect"

const program = Effect.log("msg1", "msg2", ["msg3", "msg4"]).pipe(
  Effect.delay("100 millis"),
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.structured)))
```

--------------------------------

### Trim Whitespace from String using Schema.Trim

Source: https://effect.website/docs/schema/transformations

Illustrates the `Schema.Trim` utility, which removes leading and trailing whitespace from a string. The examples show its effectiveness on strings with spaces at the beginning, end, or both.

```typescript
import { Schema } from "effect"

const decode = Schema.decodeUnknownSync(Schema.Trim)

console.log(decode("a")) // "a"
console.log(decode(" a")) // "a"
console.log(decode("a ")) // "a"
console.log(decode(" a ")) // "a"
```

--------------------------------

### Simulating Database Connections with Effect Layers

Source: https://effect.website/docs/requirements-management/layers

Demonstrates how to create Effect layers to simulate database connections, including a PostgreSQL connection and an in-memory fallback. This approach allows for flexible dependency management and error handling.

```typescript
import { Effect, Layer, Config, Context } from "effect"

class Database extends Context.Tag("Database")() {}

// Simulating a database connection
const postgresDatabaseLayer = Layer.effect(
  Database,
  Effect.gen(function* () {
    const databaseConnectionString = yield* Config.string(
      "CONNECTION_STRING"
    )
    console.log(
      `Connecting to database with: ${databaseConnectionString}`
    )
  })
)

// Simulating an in-memory database connection
const inMemoryDatabaseLayer = Layer.effect(
  Database,
  Effect.gen(function* () {
    console.log(`Connecting to in-memory database`)
  })
)

// Fallback to in-memory database if PostgreSQL connection fails
const database = postgresDatabaseLayer.pipe(
  Layer.orElse(() => inMemoryDatabaseLayer)
)

Effect.runFork(Layer.launch(database))
```

--------------------------------

### Effect Logging with logfmtLogger in TypeScript

Source: https://effect.website/docs/observability/logging

This example showcases the logfmtLogger for compact, human-readable logs. It configures the Effect program to use logfmt formatting by providing Logger.logFmt. The output is a key-value string format without extra spaces.

```typescript
import { Effect, Logger } from "effect"

const program = Effect.log("msg1", "msg2", ["msg3", "msg4"]).pipe(
  Effect.delay("100 millis"),
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.logFmt)))
```

--------------------------------

### Measuring Task Duration with Log Spans

Source: https://effect.website/docs/observability/logging

This example shows how to use `Effect.withLogSpan` to measure and log the duration of a specific task. A log span is applied to a section of the program, and the duration of that section is automatically logged.

```typescript
import { Effect } from "effect"

const program = Effect.gen(function* () {
  // Simulate a delay to represent a task taking time
  yield* Effect.sleep("1 second")
  // Log a message indicating the job is done
  yield* Effect.log("The job is finished!")
}).pipe(
  // Apply a log span labeled "myspan" to measure
  // the duration of this operation
  Effect.withLogSpan("myspan")
)

Effect.runFork(program)
```

--------------------------------

### Directing Logs to a File with PlatformLogger

Source: https://effect.website/docs/platform/platformlogger

This example demonstrates how to use PlatformLogger.toFile to direct log output to a file. It initializes a logfmtLogger, pipes it through toFile to specify the output file path, and then replaces the default logger with this new file logger. The NodeFileSystem.layer is provided to enable file system access. The program then logs a message, which is written to the specified file instead of the console.

```typescript
import { PlatformLogger } from "@effect/platform"
import { NodeFileSystem } from "@effect/platform-node"
import { Effect, Layer, Logger } from "effect"

// Create a string-based logger (logfmtLogger in this case)
const myStringLogger = Logger.logfmtLogger

// Apply toFile to write logs to "/tmp/log.txt"
const fileLogger = myStringLogger.pipe(
  PlatformLogger.toFile("/tmp/log.txt")
)

// Replace the default logger, providing NodeFileSystem
// to access the file system
const LoggerLive = Logger.replaceScoped(
  Logger.defaultLogger,
  fileLogger
).pipe(Layer.provide(NodeFileSystem.layer))

const program = Effect.log("Hello")

// Run the program, writing logs to /tmp/log.txt
Effect.runFork(program.pipe(Effect.provide(LoggerLive)))
/* 
Logs will be written to "/tmp/log.txt" in the logfmt format,
and won't appear on the console. 
*/
```

--------------------------------

### Simulating User Retrieval with Effect.succeed and Effect.fail

Source: https://effect.website/docs/getting-started/creating-effects

Provides an example of simulating a user retrieval operation, using `Effect.succeed` for successful retrieval and `Effect.fail` when a user is not found.

```APIDOC
## Simulating User Retrieval

### Description
Models a user retrieval operation where a user can either be found successfully (`Effect.succeed`) or not found (`Effect.fail`), useful for testing or mocking data.

### Method
`Effect.succeed`, `Effect.fail`

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
None

### Request Example
```javascript
import { Effect } from "effect"

// Define a User type
interface User {
  readonly id: number
  readonly name: string
}

// A mocked function to simulate fetching a user from a database
const getUser = (userId: number): Effect.Effect<User, Error, never> => {
  // Normally, you would access a database or API here, but we'll mock it
  const userDatabase: Record<number, User> = {
    1: { id: 1, name: "John Doe" },
    2: { id: 2, name: "Jane Smith" }
  }

  // Check if the user exists in our "database" and return appropriately
  const user = userDatabase[userId]
  if (user) {
    return Effect.succeed(user)
  }
  else {
    return Effect.fail(new Error("User not found"))
  }
}

// When executed, this will successfully return the user with id 1
const exampleUserEffect = getUser(1)
```

### Response
#### Success Response (200)
User object if the user ID exists in the mocked database.

#### Response Example
```json
{
  "id": 1,
  "name": "John Doe"
}
```

#### Failure Response
An `Error` object with the message "User not found" if the user ID does not exist.

#### Response Example
```json
{
  "error": {
    "message": "User not found"
  }
}
```
```

--------------------------------

### Forking an Effect into a New Fiber (TypeScript)

Source: https://effect.website/docs/concurrency/fibers

Demonstrates how to use `Effect.fork` to start an Effect computation in a new, independent fiber. This allows the computation to run concurrently and returns a `Fiber` object that can be used to interact with the running effect.

```typescript
import { Effect } from "effect"

const fib = (n: number): Effect.Effect =>
  n < 2 
    ? Effect.succeed(n)
    : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)

// Fork the fib(10) computation into a new fiber
const fib10Fiber = Effect.fork(fib(10))
```

--------------------------------

### Platform: Command Execution

Source: https://context7_llms

Learn how to create, run, and manage command-line commands within Effect applications, including handling arguments, environment variables, and I/O.

```typescript
import * as Command from "@effect/platform/Command"
import * as Effect from "@effect/io/Effect"

const listDirCommand = Command.make("ls", ["-l"])

const runCommand = Command.run(listDirCommand)

Effect.runSync(runCommand)
// Executes the 'ls -l' command and streams its output.
```

--------------------------------

### Join a Fiber and Retrieve its Result with Micro.fiberJoin (TypeScript)

Source: https://effect.website/docs/micro/new-users

This example demonstrates joining a forked fiber using `Micro.fiberJoin`. The `Micro.fiberJoin` function returns a `Micro` that succeeds or fails based on the outcome of the fiber it joins, allowing you to retrieve the computed value.

```typescript
import { Micro } from "effect"

const fib = (n: number): Micro.Micro =>
  n < 2 
  ? Micro.succeed(n)
  : Micro.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)

// ┌─── Micro, never, never>
// ▼
const fib10Fiber = Micro.fork(fib(10))

const program = Micro.gen(function* () {
  // Retrieve the fiber
  const fiber = yield* fib10Fiber
  // Join the fiber and get the result
  const n = yield* Micro.fiberJoin(fiber)
  console.log(n)
})

Micro.runPromise(program)
// Output: 55
```

--------------------------------

### Writing to Standard Output with Effect

Source: https://effect.website/docs/platform/terminal

Shows how to display a message to the terminal using the `display` method of the `Terminal` service. This example utilizes `Effect.provide` with `NodeTerminal.layer` to run the program in a Node.js environment.

```typescript
import { Terminal } from "@effect/platform"
import { NodeRuntime, NodeTerminal } from "@effect/platform-node"
import { Effect } from "effect"

const program = Effect.gen(function* () {
  const terminal = yield* Terminal.Terminal
  yield* terminal.display("a message\n")
})

NodeRuntime.runMain(program.pipe(Effect.provide(NodeTerminal.layer)))
// Output: "a message"
```

--------------------------------

### Customizing Schema with Annotations (TypeScript)

Source: https://effect.website/docs/schema/annotations

This example demonstrates how to use annotations to customize a 'Password' schema. It adds custom error messages for non-string values, required fields, and string length limits. It also includes metadata like 'identifier', 'title', 'description', 'examples', and 'documentation'.

```typescript
import { Schema } from "effect"

// Define a Password schema, starting with a string type
const Password = Schema.String
// Add a custom error message for non-string values
.annotations({ message: () => "not a string" })
.pipe(
// Enforce non-empty strings and provide a custom error message
Schema.nonEmptyString({ message: () => "required" }),
// Restrict the string length to 10 characters or fewer
// with a custom error message for exceeding length
Schema.maxLength(10, {
message: (issue) => `${issue.actual} is too long`
})
)
.annotations({
// Add a unique identifier for the schema
identifier: "Password",
// Provide a title for the schema
title: "password",
// Include a description explaining what this schema represents
description:
"A password is a secret string used to authenticate a user",
// Add examples for better clarity
examples: ["1Ki77y", "jelly22fi$h"],
// Include any additional documentation
documentation: `...technical information on Password schema...`
})
```

--------------------------------

### EffectJS scheduleExponential Example

Source: https://effect.website/docs/micro/new-users

Illustrates a schedule that recurs using exponential backoff, where each delay increases exponentially. The dryRun helper function visualizes this behavior.

```typescript
import { Micro } from "effect"
import * as Option from "effect/Option"

const dryRun = (
  schedule: Micro.MicroSchedule,
  maxAttempt: number = 7
): Array => {
  let attempt = 1
  let elapsed = 0
  const out: Array = []
  let duration = schedule(attempt, elapsed)
  while (Option.isSome(duration) && attempt <= maxAttempt) {
    const value = duration.value
    attempt++
    elapsed += value
    out.push(value)
    duration = schedule(attempt, elapsed)
  }
  return out
}

const policy = Micro.scheduleExponential(10)

console.log(dryRun(policy))
```

--------------------------------

### Effect Metrics: Counters

Source: https://context7_llms

Example of using counters for tracking metrics in Effect applications. Counters are suitable for measuring the frequency of events.

```typescript
import * as Metric from "@effect/io/Metric"
import * as Effect from "@effect/io/Effect"

const requestCounter = Metric.counter("http_requests_total").withLabels({"path": "/"})

const incrementRequest = requestCounter.increment

Effect.runSync(incrementRequest)
// The counter 'http_requests_total' would now be incremented.
```

--------------------------------

### Mocking the File System

Source: https://effect.website/docs/platform/file-system

Demonstrates how to mock the FileSystem service in testing environments using `FileSystem.layerNoop` for isolated testing.

```APIDOC
## Mocking the File System

### Description
In testing environments, you may want to mock the file system to avoid performing actual disk operations. The `FileSystem.layerNoop` provides a no-operation implementation of the `FileSystem` service. Most operations in `FileSystem.layerNoop` return a **failure** (e.g., `Effect.fail` for missing files) or a **defect** (e.g., `Effect.die` for unimplemented features). However, you can override specific behaviors by passing an object to `FileSystem.layerNoop` to define custom return values for selected methods.

### Example (Mocking File System with Custom Behavior)

```typescript
import { FileSystem } from "@effect/platform"
import { Effect } from "effect"

const program = Effect.gen(function* () {
  const fs = yield* FileSystem.FileSystem

  const exists = yield* fs.exists("/some/path")
  console.log(exists)

  const content = yield* fs.readFileString("/some/path")
  console.log(content)
})

// ┌─── Layer
// ▼
const customMock = FileSystem.layerNoop({
  readFileString: () => Effect.succeed("mocked content"),
  exists: (path) => Effect.succeed(path === "/some/path")
})

// Provide the customized FileSystem mock implementation
Effect.runPromise(program.pipe(Effect.provide(customMock)))

/* 
Output:
true 
mocked content 
*/
```
```

--------------------------------

### Transforming Stream Elements with Stream.map (TypeScript)

Source: https://effect.website/docs/stream/operations

Demonstrates the basic usage of Stream.map to apply a function to each element of a stream, producing a new stream with the transformed values. The provided example increments each element by one.

```typescript
import { Stream, Effect } from "effect"

const stream = Stream.make(1, 2, 3).pipe(
  Stream.map((n) => n + 1) // Increment each element by 1
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/*
Output:
{ _id: 'Chunk', values: [ 2, 3, 4 ] }
*/
```

--------------------------------

### Create Effect Queries for API Interactions (TypeScript)

Source: https://effect.website/docs/batching

Demonstrates creating Effect queries for fetching todos, getting a user by ID, and sending emails, utilizing their respective defined resolvers. It also shows composition of these queries to build more complex operations like `sendEmailToUser` and `notifyOwner`.

```typescript
const getTodos: Effect.Effect<Array<Todo>, GetTodosError> = Effect.request(GetTodos({}), GetTodosResolver)

const getUserById = (id: number) =>
  Effect.request(GetUserById({ id }), GetUserByIdResolver)

const sendEmail = (address: string, text: string) =>
  Effect.request(SendEmail({ address, text }), SendEmailResolver)

const sendEmailToUser = (id: number, message: string) =>
  getUserById(id).pipe(
    Effect.andThen((user) => sendEmail(user.email, message))
  )

const notifyOwner = (todo: Todo) =>
  getUserById(todo.ownerId).pipe(
    Effect.andThen((user) =>
      sendEmailToUser(user.id, `hey ${user.name} you got a todo!`) 
    )
  )
```

--------------------------------

### Get Current UTC Time Immediately

Source: https://effect.website/docs/data-types/datetime

Retrieves the current UTC time immediately using Date.now(), without relying on the Clock service. This is a direct and potentially less controlled method for getting the current time. Requires 'effect' library.

```typescript
import { DateTime } from "effect"

const currentTime = DateTime.unsafeNow()
```

--------------------------------

### Use Nested Configuration Namespaces with Environment Variables (Effect-TS)

Source: https://effect.website/docs/configuration

Explains how to use ConfigProvider.nested to group configuration values under a specific namespace, such as 'SERVER'. This example reads 'PORT' and 'HOST' from environment variables prefixed with 'SERVER_'.

```typescript
import { Config, ConfigProvider, Effect } from "effect"

const program = Effect.gen(function* () {
  const port = yield* Config.number("PORT") // Reads SERVER_PORT
  const host = yield* Config.string("HOST") // Reads SERVER_HOST
  console.log(`Application started: ${host}:${port}`)
})

Effect.runPromise(
  Effect.withConfigProvider(
    program,
    ConfigProvider.fromEnv().pipe(
      // Uses SERVER as a namespace
      ConfigProvider.nested("SERVER")
    )
  )
)
```

--------------------------------

### Combining Loggers with Logger.zip in TypeScript

Source: https://effect.website/docs/observability/logging

This example demonstrates combining multiple loggers using Logger.zip. A custom console logger is created and then zipped with the default logger. When the program logs a message, it's processed by both loggers.

```typescript
import { Effect, Logger } from "effect"

// Define a custom logger that logs to the console
const logger = Logger.make(({ logLevel, message }) => {
  globalThis.console.log(`[${logLevel.label}] ${message}`)
})

// Combine the default logger and the custom logger
const combined = Logger.zip(Logger.defaultLogger, logger)

const program = Effect.log("something")

Effect.runFork(
  program.pipe(
    // Replace the default logger with the combined logger
    Effect.provide(Logger.withMinimumLogLevel(combined, 1))
  )
)
```

--------------------------------

### Add Finalizer on Interruption using Effect.gen and pipe

Source: https://effect.website/docs/resource-management/scope

This example demonstrates how to add a finalizer that is executed when an Effect is interrupted. It presents the Effect.gen and pipe implementations, showing that the finalizer logs the interruption status. Similar to other examples, Effect.scoped is used to manage the scope and ensure the finalizer runs.

```typescript
import { Effect, Console } from "effect"

// Using Effect.gen
const programGen = Effect.gen(function* () {
  yield* Effect.addFinalizer((exit) =>
    Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
  )
  return yield* Effect.interrupt
})

const runnableGen = Effect.scoped(programGen)
Effect.runPromiseExit(runnableGen).then(console.log)

// Using pipe
const programPipe = Effect.addFinalizer((exit) =>
  Console.log(`Finalizer executed. Exit status: ${exit._tag}`)
).pipe(
  Effect.andThen(Effect.interrupt)
)

const runnablePipe = Effect.scoped(programPipe)
Effect.runPromiseExit(runnablePipe).then(console.log)
```

--------------------------------

### Coordinating Two Fibers with Deferred

Source: https://effect.website/docs/concurrency/deferred

An example demonstrating how to use a Deferred to coordinate two fibers, allowing one fiber to signal completion and pass a value to another fiber that is waiting.

```typescript
import { Effect, Deferred, Fiber } from "effect"

const program = Effect.gen(function* () {
  const deferred = yield* Deferred.make()

  // Completes the Deferred with a value after a delay
  const taskA = Effect.gen(function* () {
    console.log("Starting task to complete the Deferred")
    yield* Effect.sleep("1 second")
    console.log("Completing the Deferred")
    return yield* Deferred.succeed(deferred, "hello world")
  })

  // Waits for the Deferred and prints the value
  const taskB = Effect.gen(function* () {
```

--------------------------------

### Terminate on Unexpected Errors with Micro.die in Effect.js

Source: https://effect.website/docs/micro/new-users

This example shows how to use Micro.die to immediately terminate a program when an unexpected and critical error (a 'defect') is detected. It's typically used for unrecoverable situations.

```typescript
import { Micro } from "effect"

const divide = (a: number, b: number)
```

--------------------------------

### Running an Effect Using the Default Runtime (JavaScript)

Source: https://effect.website/docs/runtime

Demonstrates how to execute an Effect using the default runtime via Effect.runPromise and contrasts it with explicitly using Runtime.runPromise(Runtime.defaultRuntime). Both methods achieve the same outcome for running effects.

```javascript
import { Effect, Runtime } from "effect"

const program = Effect.log("Application started!")

// Using the default runtime shortcut
Effect.runPromise(program)
/* 
Output:
timestamp=... level=INFO fiber=#0 message="Application started!"
*/

// Explicitly using the default runtime
Runtime.runPromise(Runtime.defaultRuntime)(program)
/* 
Output: 
timestamp=... level=INFO fiber=#0 message="Application started!"
*/
```

--------------------------------

### Disabling Logging with a Custom Runtime

Source: https://effect.website/docs/observability/logging

This example illustrates how to disable logging by creating a custom runtime that is configured to turn off logging. This method provides a global way to control logging behavior for the entire program execution.

```typescript
import { Effect, Logger, LogLevel, ManagedRuntime } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.log("Executing task...")
  yield* Effect.sleep("100 millis")
  console.log("task done")
})

// Create a custom runtime that disables logging
const customRuntime = ManagedRuntime.make(
  Logger.minimumLogLevel(LogLevel.None)
)

// Run the program using the custom runtime
customRuntime.runFork(program)
```

--------------------------------

### Skip First Execution with Effect.schedule

Source: https://effect.website/docs/scheduling/repetition

This example demonstrates how to use Effect.schedule to avoid the initial execution of an effect, allowing it to run according to a defined schedule. It imports Effect, Schedule, and Console from 'effect'.

```typescript
import { Effect, Schedule, Console } from "effect"

const action = Console.log("success")

const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")

const program = Effect.schedule(action, policy)

Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))
```

--------------------------------

### GET /getUserById

Source: https://effect.website/docs/batching

Retrieves a user by their ID from an external API.

```APIDOC
## GET /getUserById

### Description
Retrieves a user by their ID from an external API.

### Method
GET

### Endpoint
https://api.example.demo/getUserById?id={id}

### Parameters
#### Query Parameters
- **id** (number) - Required - The ID of the user to retrieve.

### Request Body
None

### Request Example
None

### Response
#### Success Response (200)
- **User object** (User) - The user object containing id, name, and email.

#### Response Example
```json
{
  "_tag": "User",
  "id": 1,
  "name": "John Doe",
  "email": "john.doe@example.com"
}
```
```

--------------------------------

### Interrupt a Running Fiber with Micro.fiberInterrupt (TypeScript)

Source: https://effect.website/docs/micro/new-users

This example demonstrates interrupting a long-running fiber using `Micro.fiberInterrupt`. The fiber is forked to run indefinitely, and after a delay, it is interrupted, safely terminating its execution and releasing resources.

```typescript
import { Micro } from "effect"

const program = Micro.gen(function* () {
  // Fork a fiber that runs indefinitely, printing "Hi!"
  const fiber = yield* Micro.fork(
    Micro.forever(
      Micro.sync(() => console.log("Hi!")).pipe(Micro.delay(10))
    )
  )
  yield* Micro.sleep(30)
  // Interrupt the fiber
  yield* Micro.fiberInterrupt(fiber)
})

Micro.runPromise(program)
/*
Output:
Hi!
Hi!
*/
```

--------------------------------

### Run Daemon Fiber Independently with Effect.forkDaemon

Source: https://effect.website/docs/concurrency/fibers

This example demonstrates how to fork a daemon fiber using `Effect.forkDaemon`. Daemon fibers run independently of their parent fiber and continue to execute even after the parent has finished or been interrupted. It requires the 'effect' library.

```typescript
import { Effect, Console, Schedule } from "effect"

// Daemon fiber that logs a message repeatedly every second
const daemon = Effect.repeat(
  Console.log("daemon: still running!"),
  Schedule.fixed("1 second")
)

const parent = Effect.gen(function* () {
  console.log("parent: started!")
  // Daemon fiber running independently
  yield* Effect.forkDaemon(daemon)
  yield* Effect.sleep("3 seconds")
  console.log("parent: finished!")
})

Effect.runFork(parent)
```

--------------------------------

### Handle Failures During Effect Repetition

Source: https://effect.website/docs/micro/new-users

This example demonstrates how `Micro.repeat` handles failures when repeating an effect. If an effect fails during repetition, the process stops, and the failure is reported. The `Micro.runPromiseExit` function is used to observe the final outcome.

```typescript
import { Micro } from "effect"

let count = 0

// Define an async effect that simulates an action with potential failure
const action = Micro.async((resume) => {
  if (count > 1) {
    console.log("failure")
    resume(Micro.fail("Uh oh!"))
  } else {
    count++
    console.log("success")
    resume(Micro.succeed("yay!"))
  }
})

// Define a schedule that repeats the action 2 more times with a delay
const policy = Micro.scheduleAddDelay(Micro.scheduleRecurs(2), () => 100)

// Repeat the action according to the schedule
const program = Micro.repeat(action, { schedule: policy })

// Run the program and observe the result on failure
Micro.runPromiseExit(program).then(console.log)
/* 
Output:
success
success
failure
{
  "_id": "MicroExit",
  "_tag": "Failure",
  "cause": {
    "_tag": "Fail",
    "traces": [],
    "name": "MicroCause.Fail",
    "error": "Uh oh!"
  }
}
*/
```

--------------------------------

### Example of Unintended Type Compatibility (TypeScript)

Source: https://effect.website/docs/code-style/branded-types

Illustrates a common issue with TypeScript's structural typing where types with the same underlying structure are treated as interchangeable, potentially leading to bugs. This example shows a UserId being incorrectly passed to a function expecting a ProductId.

```typescript
type UserId = number;
type ProductId = number;

const getUserById = (id: UserId) => {
  // Logic to retrieve user
};

const getProductById = (id: ProductId) => {
  // Logic to retrieve product
};

const id: UserId = 1;

getProductById(id) // No type error, but incorrect usage
```

--------------------------------

### MutableHashSet Example with Schema.Data

Source: https://effect.website/docs/data-types/hash-set

Illustrates the use of Effect's MutableHashSet in conjunction with Schema.Data. It shows how to create a mutable set and add elements decoded from plain objects, demonstrating that duplicate values based on schema equality are automatically handled.

```typescript
import { Schema, MutableHashSet } from "effect"

// Define a schema that describes the structure of a Person
const PersonSchema = Schema.Data(
  Schema.Struct({
    id: Schema.Number,
    name: Schema.String,
    age: Schema.Number
  })
)

// Decode values from plain objects
const Person = Schema.decodeSync(PersonSchema)

const person1 = Person({ id: 1, name: "Alice", age: 30 })
const person2 = Person({ id: 1, name: "Alice", age: 30 })

// Add both to a MutableHashSet — only one will be stored
const set = MutableHashSet.empty().pipe(
  MutableHashSet.add(person1),
  MutableHashSet.add(person2)
)

console.log(MutableHashSet.size(set))
// Output: 1
```

--------------------------------

### Control Flow: `ifEffect`

Source: https://context7_llms

Example of using the `ifEffect` operator for conditional branching based on the result of another Effect. This ensures type-safe conditional execution.

```typescript
import * as Effect from "@effect/io/Effect"

const condition = Effect.succeed(true)
const onTrue = Effect.succeed("Condition met")
const onFalse = Effect.succeed("Condition not met")

const result = Effect.ifEffect(condition)(
  () => onTrue,
  () => onFalse
)

Effect.runSync(result) // "Condition met"
```

--------------------------------

### Non-Interactive Create Effect App with template and options

Source: https://effect.website/docs/getting-started/create-effect-app

Demonstrates non-interactive usage of create-effect-app, allowing users to specify templates (e.g., 'basic', 'cli', 'monorepo') and additional configurations like '--changesets', '--flake', '--eslint', and '--workflows'.

```bash
create-effect-app (-t, --template basic | cli | monorepo) [--changesets] [--flake] [--eslint] [--workflows]
```

--------------------------------

### Chaining HashSet Operations with pipe

Source: https://effect.website/docs/data-types/hash-set

Demonstrates a functional approach to manipulating an immutable HashSet using the `pipe` function. This example shows how to chain multiple operations like filtering, mapping, and converting to an array, processing data immutably.

```typescript
import { HashSet, pipe } from "effect"

const result = pipe(
  // Duplicates are ignored
  HashSet.make(1, 2, 2, 3, 4, 5, 5),
  // Keep even numbers
  HashSet.filter((n) => n % 2 === 0),
  // Double each value
  HashSet.map((n) => n * 2),
  // Convert to array
  HashSet.toValues
)

console.log(result)
// Output: [4, 8]
```

--------------------------------

### EffectJS scheduleSpaced Example

Source: https://effect.website/docs/micro/new-users

Demonstrates a schedule that repeats indefinitely, with each repetition spaced a specified duration from the last run. It uses a dryRun helper function to visualize the schedule's behavior up to a maximum number of attempts.

```typescript
import { Micro } from "effect"
import * as Option from "effect/Option"

const dryRun = (
  schedule: Micro.MicroSchedule,
  maxAttempt: number = 7
): Array => {
  let attempt = 1
  let elapsed = 0
  const out: Array = []
  let duration = schedule(attempt, elapsed)
  while (Option.isSome(duration) && attempt <= maxAttempt) {
    const value = duration.value
    attempt++
    elapsed += value
    out.push(value)
    duration = schedule(attempt, elapsed)
  }
  return out
}

const policy = Micro.scheduleSpaced(10)

console.log(dryRun(policy))
```

--------------------------------

### Get Value from Cache (Compute if Missing)

Source: https://effect.website/docs/caching/cache

Illustrates the idiomatic way to retrieve a value from a cache using the `get` method. If the value for the given key exists in the cache and is still valid, it's returned directly. Otherwise, the `lookup` function is invoked to compute the value, which is then stored in the cache before being returned. This method ensures that even with multiple concurrent requests for the same key, the value is computed only once.

```typescript
interface Cache<Key, Value, Requirements, Error> {
  readonly get: (key: Key) => Effect<Value, Error, Requirements>
}
```

--------------------------------

### EffectJS scheduleIntersect Example

Source: https://effect.website/docs/micro/new-users

Shows how to combine two schedules using intersection. The resulting schedule recurs only if both input schedules want to continue, using the maximum delay between them. The dryRun helper function visualizes the intersection.

```typescript
import { Micro } from "effect"
import * as Option from "effect/Option"

const dryRun = (
  schedule: Micro.MicroSchedule,
  maxAttempt: number = 7
): Array => {
  let attempt = 1
  let elapsed = 0
  const out: Array = []
  let duration = schedule(attempt, elapsed)
  while (Option.isSome(duration) && attempt <= maxAttempt) {
    const value = duration.value
    attempt++
    elapsed += value
    out.push(value)
    duration = schedule(attempt, elapsed)
  }
  return out
}

const policy = Micro.scheduleIntersect(
  Micro.scheduleExponential(10),
  Micro.scheduleSpaced(300)
)

console.log(dryRun(policy))
```

--------------------------------

### Effect.map data-first variant without pipe

Source: https://effect.website/docs/code-style/dual

Shows the 'data-first' usage of Effect.map, where the 'Effect' is explicitly provided as the first argument. This form is convenient for single operations.

```typescript
const mappedEffect = Effect.map(effect, func)
```

--------------------------------

### Simple Custom Message for Scalar Schema (Effect)

Source: https://effect.website/docs/schema/error-messages

Shows a basic example of adding a custom error message to a scalar schema, specifically `Schema.String`, using the `annotations` method. The custom message is defined within the `message` property of the annotation object. The example demonstrates catching the error and logging its message.

```typescript
import { Schema } from "effect"

const MyString = Schema.String.annotations({
  message: () => "my custom message"
})

const decode = Schema.decodeUnknownSync(MyString)

try {
  decode(null)
} catch (e: any) {
  console.log(e.message) // "my custom message"
}
```

--------------------------------

### Use Effect.js Ref as a Service

Source: https://effect.website/docs/state-management/ref

This example demonstrates how to use Effect.js Ref as a service, allowing state to be shared across different parts of a program. It defines a `MyState` tag, creates subprograms that interact with the state via the service, and composes them into a main program. `Effect.provideServiceEffect` is used to provide the effectful Ref implementation.

```typescript
import { Effect, Context, Ref } from "effect"

// Create a Tag for our state
class MyState extends Context.Tag("MyState")<MyState, Ref.Ref<number>>() {}

// Subprogram 1: Increment the state value twice
const subprogram1 = Effect.gen(function* () {
  const state = yield* MyState
  yield* Ref.update(state, (n) => n + 1)
  yield* Ref.update(state, (n) => n + 1)
})

// Subprogram 2: Decrement the state value and then increment it
const subprogram2 = Effect.gen(function* () {
  const state = yield* MyState
  yield* Ref.update(state, (n) => n - 1)
  yield* Ref.update(state, (n) => n + 1)
})

// Subprogram 3: Read and log the current value of the state
const subprogram3 = Effect.gen(function* () {
  const state = yield* MyState
  const value = yield* Ref.get(state)
  console.log(`MyState has a value of ${value}.`)
})

// Compose subprograms 1, 2, and 3 to create the main program
const program = Effect.gen(function* () {
  yield* subprogram1
  yield* subprogram2
  yield* subprogram3
})

// Create a Ref instance with an initial value of 0
const initialState = Ref.make(0)

// Provide the Ref as a service
const runnable = program.pipe(
  Effect.provideServiceEffect(MyState, initialState)
)

// Run the program and observe the output
Effect.runPromise(runnable)
/* 
Output:
MyState has a value of 2.
*/
```

--------------------------------

### Accessing KeyValueStore Service

Source: https://effect.website/docs/platform/key-value-store

Demonstrates how to access the KeyValueStore service within an Effect program. This is the entry point for interacting with any KeyValueStore implementation.

```typescript
import { KeyValueStore } from "@effect/platform"
import { Effect } from "effect"

const program = Effect.gen(function* () {
  const kv = yield* KeyValueStore.KeyValueStore

  // Use `kv` to perform operations on the store
})
```

--------------------------------

### Fork Scoped Fiber with Effect.forkScoped

Source: https://effect.website/docs/concurrency/fibers

This example demonstrates using `Effect.forkScoped` to create a fiber that is tied to a local scope. Fibers forked with `Effect.forkScoped` can outlive their parent fibers and are only terminated when the local scope closes. It requires the 'effect' library.

```typescript
import { Effect, Console, Schedule } from "effect"

// Child fiber that logs a message repeatedly every second
const child = Effect.repeat(
  Console.log("child: still running!"),
  Schedule.fixed("1 second")
)

// ┌─── Effect
// ▼
const parent = Effect.gen(function* () {
  console.log("parent: started!")
  // Child fiber attached to local scope
  yield* Effect.forkScoped(child)
  yield* Effect.sleep("3 seconds")
  console.log("parent: finished!")
})

// Program runs within a local scope
const program = Effect.scoped(
  Effect.gen(function* () {
    console.log("Local scope started!")
    yield* Effect.fork(parent)
    // Scope lasts for 5 seconds
    yield* Effect.sleep("5 seconds")
    console.log("Leaving the local scope!")
  })
)

Effect.runFork(program)
```

--------------------------------

### EffectJS scheduleUnion Example

Source: https://effect.website/docs/micro/new-users

Demonstrates combining two schedules using a union. The resulting schedule recurs as long as either of the input schedules wants to, using the minimum delay between recurrences. The dryRun helper visualizes the combined schedule.

```typescript
import { Micro } from "effect"
import * as Option from "effect/Option"

const dryRun = (
  schedule: Micro.MicroSchedule,
  maxAttempt: number = 7
): Array => {
  let attempt = 1
  let elapsed = 0
  const out: Array = []
  let duration = schedule(attempt, elapsed)
  while (Option.isSome(duration) && attempt <= maxAttempt) {
    const value = duration.value
    attempt++
    elapsed += value
    out.push(value)
    duration = schedule(attempt, elapsed)
  }
  return out
}

const policy = Micro.scheduleUnion(
  Micro.scheduleExponential(10),
  Micro.scheduleSpaced(300)
)

console.log(dryRun(policy))
```

--------------------------------

### Log Error with Effect

Source: https://effect.website/docs/observability/logging

Shows how to log a message at the ERROR level using Effect.logError. This level is for issues that require attention. The example handles a failing task and logs the error.

```typescript
import { Effect, Either } from "effect"

const task = Effect.fail("Oh uh!").pipe(Effect.as(2))

const program = Effect.gen(function*() {
  const failureOrSuccess = yield* Effect.either(task)
  if (Either.isLeft(failureOrSuccess)) {
    yield* Effect.logError(failureOrSuccess.left)
    return 0
  } else {
    return failureOrSuccess.right
  }
})

Effect.runFork(program)
```

--------------------------------

### Default ParseError (Missing Properties)

Source: https://effect.website/docs/schema/error-messages

This example illustrates the default ParseError when required properties are missing from the input data during schema decoding. It details which properties are expected but not found.

```typescript
import { Schema } from "effect"

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

Schema.decodeUnknownSync(Person)({}, { errors: "all" })
/* 
throws:
ParseError: { readonly name: string; readonly age: number }
├─ ["name"]
│  └─ is missing
└─ ["age"]
   └─ is missing
*/
```

--------------------------------

### Retry Failing Effects with Fixed Delay in Effect.js

Source: https://effect.website/docs/micro/new-users

Shows how to use Micro.retry with Micro.scheduleSpaced to automatically retry a failing Effect.js operation after a fixed delay. The example retries an async task until it succeeds.

```typescript
import { Micro } from "effect"

let count = 0

// Simulates an effect with possible failures
const effect = Micro.async((resume) => {
  if (count <= 2) {
    count++
    console.log("failure")
    resume(Micro.fail(new Error()))
  } else {
    console.log("success")
    resume(Micro.succeed("yay!"))
  }
})

// Define a repetition policy using a spaced delay between retries
const policy = Micro.scheduleSpaced(100)

const repeated = Micro.retry(effect, { schedule: policy })

Micro.runPromise(repeated).then(console.log)
/* 
Output:
failure
failure
failure
success
yay!
*/
```

--------------------------------

### Find Next Cron Run Time

Source: https://effect.website/docs/scheduling/cron

Determines the next date and time that satisfies a given cron schedule using the `next` function. It starts searching from a specified date or the current time if no starting date is provided. The function throws an error if it cannot find a matching date within a reasonable number of iterations to prevent infinite loops.

```typescript
import { Cron } from "effect"

// Define a cron expression for 4:00 AM
// on the 8th to the 14th of every month
const cron = Cron.unsafeParse("0 0 4 8-14 * *", "UTC")

// Specify the starting point for the search
const after = new Date("2025-01-08")

// Find the next matching date
const nextDate = Cron.next(cron, after)

console.log(nextDate)
// Output: 2025-01-08T04:00:00.000Z
```

--------------------------------

### Create User Instances with/without Optional Email in TypeScript

Source: https://effect.website/docs/data-types/option

Provides examples of creating instances of the `User` interface, demonstrating how to assign values to the optional `email` property using `Option.some` and `Option.none`.

```typescript
import { Option } from "effect"

interface User {
  readonly id: number
  readonly username: string
  readonly email: Option.Option
}

const withEmail: User = {
  id: 1,
  username: "john_doe",
  email: Option.some("john.doe@example.com")
}

const withoutEmail: User = {
  id: 2,
  username: "jane_doe",
  email: Option.none()
}
```

--------------------------------

### KeyValueStore API

Source: https://effect.website/docs/platform/key-value-store

The KeyValueStore module provides a service for managing key-value pairs. It includes operations for getting, setting, removing, and managing entries, as well as creating schema-validated stores.

```APIDOC
## KeyValueStore API

### Description

The `@effect/platform/KeyValueStore` module provides a robust and effectful interface for managing key-value pairs. It supports asynchronous operations, ensuring data integrity and consistency, and includes built-in implementations for in-memory, file system-based, and schema-validated stores.

### Service

The module exposes a single service, `KeyValueStore`, which acts as the gateway for interacting with the store.

### Accessing the KeyValueStore Service

```md
1 import { KeyValueStore } from "@effect/platform"
2 import { Effect } from "effect"
3 
4 const program = Effect.gen(function* () {
5   const kv = yield* KeyValueStore.KeyValueStore
6 
7   // Use `kv` to perform operations on the store
8 })
```

### Operations

| Operation | Description |
|---|---|
| **get** | Returns the value as `string` of the specified key if it exists. |
| **getUint8Array** | Returns the value as `Uint8Array` of the specified key if it exists. |
| **set** | Sets the value of the specified key. |
| **remove** | Removes the specified key. |
| **clear** | Removes all entries. |
| **size** | Returns the number of entries. |
| **modify** | Updates the value of the specified key if it exists. |
| **modifyUint8Array** | Updates the value of the specified key if it exists. |
| **has** | Check if a key exists. |
| **isEmpty** | Check if the store is empty. |
| **forSchema** | Create a `SchemaStore` for the specified schema. |

### Basic Operations Example

```md
1 import {
2 KeyValueStore,
3 layerMemory
4 } from "@effect/platform/KeyValueStore"
5 import { Effect } from "effect"
6 
7 const program = Effect.gen(function* () {
8   const kv = yield* KeyValueStore
9 
10   // Store is initially empty
11   console.log(yield* kv.size)
12 
13   // Set a key-value pair
14   yield* kv.set("key", "value")
15   console.log(yield* kv.size)
16 
17   // Retrieve the value
18   const value = yield* kv.get("key")
19   console.log(value)
20 
21   // Remove the key
22   yield* kv.remove("key")
23   console.log(yield* kv.size)
24 })
25 
26 // Run the program with an in-memory layer
27 Effect.runPromise(program.pipe(KeyValueStore.layerMemory))
```
```

--------------------------------

### Catch All Errors with Micro.catchAll in Effect.js

Source: https://effect.website/docs/micro/new-users

This example illustrates how to use Micro.catchAll to intercept any error originating from a program and replace it with a successful outcome. It's useful for ensuring a program always completes, even when unexpected errors occur.

```typescript
import { Micro } from "effect"

class HttpError {
  readonly _tag = "HttpError"
}

class ValidationError {
  readonly _tag = "ValidationError"
}

const program = Micro.gen(function* () {
  // Simulate http and validation errors
  if (Math.random() > 0.5) yield* Micro.fail(new HttpError())
  if (Math.random() > 0.5) yield* Micro.fail(new ValidationError())
  return "some result"
})

const recovered = program.pipe(
  Micro.catchAll((error) =>
    Micro.succeed(`Recovering from ${error._tag}`)
  )
)

Micro.runPromiseExit(recovered).then(console.log)
/* 
Example Output:
{
  "_id": "MicroExit",
  "_tag": "Success",
  "value": "Recovering from HttpError"
}
*/
```

--------------------------------

### Access Service in Micro.gen with Effect.js

Source: https://effect.website/docs/micro/effect-users

Shows how to access a service within a `Micro.gen` block by using `Micro.service`. This is the correct way to yield services in `Micro.gen`, as directly yielding the service tag will not work. The example demonstrates providing a `Random` service and then using it within the generated program.

```typescript
import { Micro, Context } from "effect"

class Random extends Context.Tag("MyRandomService")< 
Random, 
{ readonly next: Micro.Micro }
>() {}

const program = Micro.gen(function* () {
  // const random = yield* Random // this doesn't work
  const random = yield* Micro.service(Random)
  const randomNumber = yield* random.next
  console.log(`random number: ${randomNumber}`)
})

const runnable = Micro.provideService(program, Random, {
  next: Micro.sync(() => Math.random())
})

Micro.runPromise(runnable)
/* 
Example Output:
random number: 0.8241872233134417 
*/
```

--------------------------------

### Create Instances of a Schema Class (TypeScript)

Source: https://effect.website/docs/schema/classes

Demonstrates creating instances of the `Person` schema class. It shows instantiation using the `new` keyword with an object literal and using the `make` factory function provided by `Schema.Class`. Both methods ensure the created instances conform to the schema.

```typescript
import { Schema } from "effect"

class Person extends Schema.Class("Person")({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {}

console.log(new Person({ id: 1, name: "John" }))
/* 
Output: 
Person { id: 1, name: 'John' } 
*/

// Using the factory function
console.log(Person.make({ id: 1, name: "John" }))
/* 
Output: 
Person { id: 1, name: 'John' } 
*/

```

--------------------------------

### Run a Failing Program with runMain (Node.js)

Source: https://effect.website/docs/platform/runtime

This example shows how `runMain` handles a failing Effect. By default, it logs the error in a pretty format to the console, indicating the timestamp, error level, and the error message itself.

```typescript
import { NodeRuntime } from "@effect/platform-node"
import { Effect } from "effect"

const failure = Effect.fail("Uh oh!")

NodeRuntime.runMain(failure)
/* 
Output: 
[12:43:07.186] ERROR (#0):
Error: Uh oh!
*/
```

--------------------------------

### Unbounded Concurrency with Effect.all

Source: https://effect.website/docs/concurrency/basic-concurrency

Shows how to run an unlimited number of effects concurrently by setting `concurrency` to 'unbounded' in `Effect.all`. This allows all tasks to start immediately, potentially consuming more resources.

```typescript
import { Effect, Duration } from "effect"

// Helper function to simulate a task with a delay
const makeTask = (n: number, delay: Duration.DurationInput) =>
  Effect.promise(
    () =>
      new Promise((resolve) => {
        console.log(`start task${n}`)
        setTimeout(() => {
          console.log(`task${n} done`)
          resolve()
        }, Duration.toMillis(delay))
      })
  )

const task1 = makeTask(1, "200 millis")
const task2 = makeTask(2, "100 millis")
const task3 = makeTask(3, "210 millis")
const task4 = makeTask(4, "110 millis")
const task5 = makeTask(5, "150 millis")

const unbounded = Effect.all([task1, task2, task3, task4, task5], {
  concurrency: "unbounded"
})

Effect.runPromise(unbounded)
```

--------------------------------

### Integrate Effect DevTools with NodeRuntime in JavaScript

Source: https://effect.website/docs/getting-started/devtools

Example demonstrating how to import and use the DevTools module in an Effect application with NodeRuntime. It shows logging, delaying, and applying spans within an Effect program, then providing the DevTools layer before running the main program.

```javascript
import { DevTools } from "@effect/experimental"
import { NodeRuntime, NodeSocket } from "@effect/platform-node"
import { Effect, Layer } from "effect"

const program = Effect.log("Hello!").pipe(
  Effect.delay(2000),
  Effect.withSpan("Hi", { attributes: { foo: "bar" } }),
  Effect.forever,
)

const DevToolsLive = DevTools.layer()

program.pipe(Effect.provide(DevToolsLive), NodeRuntime.runMain)
```

--------------------------------

### Awaiting Fiber Completion with Exit Status (TypeScript)

Source: https://effect.website/docs/concurrency/fibers

Shows how to use `Fiber.await` to wait for a fiber to finish and get an `Exit` value. The `Exit` type provides detailed information about whether the fiber succeeded, failed, or was interrupted.

```typescript
import { Effect, Fiber } from "effect"

const fib = (n: number): Effect.Effect =>
  n < 2 
    ? Effect.succeed(n)
    : Effect.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)

const fib10Fiber = Effect.fork(fib(10))

const program = Effect.gen(function* () {
  // Retrieve the fiber reference
  const fiber = yield* fib10Fiber
  // Await its completion and get the Exit result
  const exit = yield* Fiber.await(fiber)
  console.log(exit)
})

Effect.runFork(program) 
/* 
Output:
{
  _id: 'Exit',
  _tag: 'Success',
  value: 55
}
*/
```

--------------------------------

### Split String by Delimiter using Schema.split

Source: https://effect.website/docs/schema/transformations

Demonstrates the `Schema.split` function, which splits a string into an array of substrings based on a specified delimiter. Examples show splitting an empty string, a string with only a delimiter, and strings with leading/trailing delimiters.

```typescript
import { Schema } from "effect"

const schema = Schema.split(",")

const decode = Schema.decodeUnknownSync(schema)

console.log(decode("")) // [""].
console.log(decode(",")) // ["", ""].
console.log(decode("a,")) // ["a", ""].
console.log(decode("a,b")) // ["a", "b"]
```

--------------------------------

### Create Configuration for a HashMap

Source: https://effect.website/docs/configuration

Shows how to use the `Config.hashMap` combinator to define a configuration that accepts key-value pairs, typically read from environment variables with a prefix.

```typescript
import { Config, Effect } from "effect"

const program = Effect.gen(function* () {
  const config = yield* Config.hashMap(Config.string(), "MYMAP")
  console.log(config)
})

Effect.runPromise(program)
// Run:
// MYMAP_A=a MYMAP_B=b npx tsx index.ts
// Output:
// { _id: 'HashMap', values: [ [ 'A', 'a' ], [ 'B', 'b' ] ] }
```

--------------------------------

### Buffering Effect Streams for Speed Mismatch Handling

Source: https://effect.website/docs/stream/operations

This example shows how to use `Stream.buffer` in Effect JS to manage speed differences between a producer and consumer. It buffers elements up to a capacity of 4, logs elements before and after buffering, and introduces a 5-second delay between emissions to illustrate the buffering effect.

```typescript
const stream = Stream.range(1, 10).pipe(
  // Log each element before buffering
  Stream.tap((n) => Console.log(`before buffering: ${n}`)),
  // Buffer with a capacity of 4 elements
  Stream.buffer({ capacity: 4 }),
  // Log each element after buffering
  Stream.tap((n) => Console.log(`after buffering: ${n}`)),
  // Add a 5-second delay between each emission
  Stream.schedule(Schedule.spaced("5 seconds"))
);

Effect.runPromise(Stream.runCollect(stream)).then(console.log);
```

--------------------------------

### Disabling Logging with a Layer

Source: https://effect.website/docs/observability/logging

This example shows how to disable logging by providing a layer that sets the minimum log level to `LogLevel.None`. This approach is effective for disabling logging across a larger part of an application or within specific contexts.

```typescript
import { Effect, Logger, LogLevel } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.log("Executing task...")
  yield* Effect.sleep("100 millis")
  console.log("task done")
})

// Create a layer that disables logging
const layer = Logger.minimumLogLevel(LogLevel.None)

// Apply the layer to disable logging
Effect.runFork(program.pipe(Effect.provide(layer)))
```

--------------------------------

### Trim Record Keys During Decoding (Effect Schema)

Source: https://effect.website/docs/schema/basic-usage

Provides an example of how to trim keys while decoding a record by using 'Schema.transform' and a custom 'decode' function that maps keys after trimming.

```typescript
import { Schema, Record, identity } from "effect"

const schema = Schema.transform(
  // Define the input schema with unprocessed keys
  Schema.Record({
    key: Schema.String,
    value: Schema.NumberFromString
  }),
  // Define the output schema with transformed keys
  Schema.Record({
    key: Schema.Trimmed,
    value: Schema.Number
  }),
  {
    strict: true,
    // Trim keys during decoding
    decode: (record) => Record.mapKeys(record, (key) => key.trim()),
    encode: identity
  }
)

console.log(
  Schema.decodeUnknownSync(schema)({" key1 ": "1", key2: "2"})
)
// Output: { key1: 1, key2: 2 }
```

--------------------------------

### Effect Schema: Number Comparison Filters

Source: https://effect.website/docs/schema/filters

Provides examples of number filters for validating if a number is greater than, less than, greater than or equal to, or less than or equal to a specified value.

```typescript
import { Schema } from "effect"

// Specifies a number greater than 5
Schema.Number.pipe(Schema.greaterThan(5))

// Specifies a number greater than or equal to 5
Schema.Number.pipe(Schema.greaterThanOrEqualTo(5))

// Specifies a number less than 5
Schema.Number.pipe(Schema.lessThan(5))

// Specifies a number less than or equal to 5
Schema.Number.pipe(Schema.lessThanOrEqualTo(5))

// Specifies a number between -2 and 2, inclusive
Schema.Number.pipe(Schema.between(-2, 2))
```

--------------------------------

### Pattern Matching on Causes with Cause.match

Source: https://effect.website/docs/data-types/cause

Provides an example of using Cause.match to handle different types of Causes by defining specific callbacks for each potential error scenario, allowing for structured error management.

```typescript
import { Cause } from "effect"

const cause = Cause.parallel(
  Cause.fail(new Error("my fail message")),
  Cause.die("my die message")
)

console.log(
  Cause.match(cause, {
    onEmpty: "(empty)",
    onFail: (error) => `(error: ${error.message})`,
    onDie: (defect) => `(defect: ${defect})`,
    onInterrupt: (fiberId) => `(fiberId: ${fiberId})`,
    onSequential: (left, right) =>
      `(onSequential (left: ${left}) (right: ${right}))`,
    onParallel: (left, right) =>
      `(onParallel (left: ${left}) (right: ${right}))`
  })
)
/* 
Output:
(onParallel (left: (error: my fail message)) (right: (defect: my die message)) 
*/
```

--------------------------------

### Deferred Status Checks

Source: https://effect.website/docs/concurrency/deferred

Explains how to check the status of a Deferred without suspending, using `Deferred.poll` to get its current state or `Deferred.isDone` for a simple boolean check.

```APIDOC
## Deferred Status Checks

### Description

This section covers methods for inspecting the state of a `Deferred` without causing the current fiber to suspend. This is useful for scenarios where you need to check if a `Deferred` has been completed or retrieve its result non-blockingly.

### Methods

- `Deferred.poll(deferred)`: Returns an `Option<Exit>` of the `Deferred`'s result. Returns `None` if the `Deferred` is incomplete, and `Some(exit)` if it is complete.
- `Deferred.isDone(deferred)`: Returns an `Effect<boolean>` that evaluates to `true` if the `Deferred` has been completed, and `false` otherwise.

### Example (Polling and Checking Completion Status)

```typescript
import { Effect, Deferred } from "effect";

const program = Effect.gen(function* () {
  const deferred = yield* Deferred.make<number, string>();

  // Polling the Deferred to check if it's completed
  const done1 = yield* Deferred.poll(deferred);

  // Checking if the Deferred has been completed
  const done2 = yield* Deferred.isDone(deferred);

  console.log([done1, done2]);
});

Effect.runFork(program);
/*
Output:
[
  { _id: 'Option', _tag: 'None' },
  false
]
*/
```
```

--------------------------------

### Sandboxing and Handling Errors with Effect.sandbox

Source: https://effect.website/docs/error-management/sandboxing

This example demonstrates how to use Effect.sandbox to capture different types of errors (Defect, Interrupt, Fail) and handle them using Effect.catchTags. It then uses Effect.unsandbox to restore the original error handling before running the program.

```typescript
import { Effect, Console } from "effect"

// Create an effect that fails
const task = Effect.fail(new Error("Oh uh!")).pipe(
  Effect.as("primary result")
)

// Sandbox the task to capture the full cause of the error
const sandboxed = Effect.sandbox(task)

// Handle different error causes using Effect.catchTags
const program = Effect.catchTags(sandboxed, {
  Die: (cause) =>
    Console.log(`Caught a defect: ${cause.defect}`).pipe(
      Effect.as("fallback result on defect")
    ),
  Interrupt: (cause) =>
    Console.log(`Caught a defect: ${cause.fiberId}`).pipe(
      Effect.as("fallback result on fiber interruption")
    ),
  Fail: (cause) =>
    Console.log(`Caught a defect: ${cause.error}`).pipe(
      Effect.as("fallback result on failure")
    )
})

// Restore the original error handling with unsandbox
const main = Effect.unsandbox(program)

// Run the program and log the final result
Effect.runPromise(main).then(console.log)

```

--------------------------------

### Testing Database Service with Leaked Dependencies in Effect.js

Source: https://effect.website/docs/requirements-management/layers

This snippet illustrates a problematic test setup in Effect.js where the Database service interface directly requires Config and Logger. This forces the test to provide these unnecessary dependencies, complicating isolation.

```typescript
import { Effect, Context } from "effect"
import * as assert from "node:assert"

// Assuming Config, Logger, and Database tags and DatabaseTest instance are declared
class Config extends Context.Tag("Config")() {}
class Logger extends Context.Tag("Logger")() {}
class Database extends Context.Tag("Database")<Database, {
  readonly query: (sql: string) => Effect.Effect
}>() {}
const DatabaseTest = Database.of({
  query: (sql: string) => Effect.succeed([])
})

// A test that uses the Database service
const test = Effect.gen(function* () {
  const database = yield* Database
  const result = yield* database.query("SELECT * FROM users")
  assert.deepStrictEqual(result, [])
})

// Attempt to provide only the Database service without Config and Logger
const incompleteTestSetup = test.pipe(
  Effect.provideService(Database, DatabaseTest)
)
```

--------------------------------

### Create Cron Instance with Specific Constraints

Source: https://effect.website/docs/scheduling/cron

This example demonstrates how to create a Cron instance with specific constraints for seconds, minutes, hours, days, and optionally a time zone. The `make` function requires all fields to be defined, with empty arrays indicating no restrictions for a given field. This allows for precise scheduling, such as triggering at a specific time on a range of days within a month.

```typescript
import { Cron, DateTime } from "effect"

// Build a cron that triggers at 4:00 AM
// on the 8th to the 14th of each month
const cron = Cron.make({
  seconds: [0],
  minutes: [0],
  hours: [4],
  days: [8, 9, 10, 11, 12, 13, 14],
  months: [],
  weekdays: [],
  tz: DateTime.zoneUnsafeMakeNamed("Europe/Rome")
})
```

--------------------------------

### Manual Service Passing Example in TypeScript

Source: https://effect.website/docs/requirements-management/services

Demonstrates the traditional approach of manually passing a service object to a function. This method becomes unmanageable in larger applications due to the need to pass services through multiple layers.

```typescript
const processData = (data: Data, databaseService: DatabaseService) => {
  // Operations using the database service
}
```

--------------------------------

### Tagging Multiple Metrics with Effect.js

Source: https://effect.website/docs/observability/metrics

This example shows how to apply tags to multiple metrics within the same context using `Effect.tagMetrics`. This approach is beneficial for applying common tags, like the application environment, across several metrics simultaneously. The `environment: production` tag is applied to both `counter1` and `counter2`.

```typescript
import { Metric, Effect } from "effect"

// Create two separate counters
const counter1 = Metric.counter("counter1")
const counter2 = Metric.counter("counter2")

// Define a task that simulates some work with a slight delay
const task = Effect.succeed(1).pipe(Effect.delay("100 millis"))

// Apply the environment tag to both counters in the same context
Effect.gen(function* () {
  yield* counter1(task)
  yield* counter2(task)
}).pipe(Effect.tagMetrics("environment", "production"))
```

--------------------------------

### Effect.map dual API signatures

Source: https://effect.website/docs/code-style/dual

Illustrates the two TypeScript overloads for Effect.map, representing the 'data-last' and 'data-first' API variants. These signatures show the positional difference of the 'self' argument.

```typescript
declare const map: {
  // ┌─── data-last
  // ▼ (f: (a: A) => B): (self: Effect) => Effect
  // ┌─── data-first
  // ▼ (self: Effect, f: (a: A) => B): Effect
}
```

--------------------------------

### Joining Path Segments with @effect/platform/Path

Source: https://effect.website/docs/platform/path

Shows an example of using the `join` method from the Path service to combine multiple path segments into a single path string. It utilizes Node.js specific runtime context.

```typescript
import { Path } from "@effect/platform"
import { Effect } from "effect"
import { NodeContext, NodeRuntime } from "@effect/platform-node"

const program = Effect.gen(function* () {
  const path = yield* Path.Path

  const mypath = path.join("tmp", "file.txt")
  console.log(mypath)
})

NodeRuntime.runMain(program.pipe(Effect.provide(NodeContext.layer)))
// Output: "tmp/file.txt"
```

--------------------------------

### Decoding with decodeUnknown

Source: https://effect.website/docs/schema/getting-started

Decodes a value and returns an `Effect`. This is suitable for schemas involving asynchronous transformations. The `Effect` can be run synchronously or asynchronously to get the result or handle errors.

```APIDOC
## POST /decodeUnknown

### Description
Decodes a value using a schema and returns an `Effect`. This function is specifically designed for schemas that include asynchronous operations or transformations. The resulting `Effect` encapsulates the decoding process, allowing for integrated error handling and asynchronous execution.

### Method
POST

### Endpoint
`/decodeUnknown`

### Parameters
#### Request Body
- **schema** (Schema) - Required - The schema to use for decoding, potentially including async transformations.
- **unknownValue** (unknown) - Required - The value to decode.

### Request Example
```json
{
  "schema": "Schema.transformOrFail(Schema.Number, Schema.Struct({\"id\": Schema.Number, \"name\": Schema.String, \"age\": Schema.Number}), {\n  decode: (id) => Effect.succeed({ id, name: \"name\", age: 18 }).pipe(Effect.delay(\"10 millis\"))\n})",
  "unknownValue": 1
}
```

### Response
#### Success Response (200)
- **effectResult** (object) - The result of running the `Effect`, containing the decoded value.

#### Response Example
```json
{
  "effectResult": {
    "id": 1,
    "name": "name",
    "age": 18
  }
}
```

#### Error Response (400)
- **error** (object) - Contains details about the error during effect execution or decoding.
  - **message** (string) - Description of the error.

#### Error Response Example
```json
{
  "error": {
    "message": "An error occurred during asynchronous decoding."
  }
}
```
```

--------------------------------

### Define Service with Synchronous Constructor (Effect.js)

Source: https://effect.website/docs/requirements-management/layers

Shows how to define a service using a synchronous constructor with `Effect.Service`. This is useful for services that can be instantiated immediately without asynchronous operations.

```typescript
import { Effect, Random } from "effect"

class Sync extends Effect.Service()("Sync", {
  sync: () => ({
    next: Random.nextInt
  })
}) {}

// Accessing the Service
const program = Effect.gen(function* () {
  const sync = yield* Sync
  const n = yield* sync.next
  console.log(`The number is ${n}`)
})

Effect.runPromise(program.pipe(Effect.provide(Sync.Default)))
// Example Output: The number is 3858843290019673
```

--------------------------------

### Create Effect Schema Class Instance with Validation

Source: https://effect.website/docs/schema/classes

Demonstrates creating an instance of a Person class defined with Effect Schema. The example shows how validation fails if the 'name' property is an empty string, as it requires a NonEmptyString. The expected output is a ParseError.

```typescript
import { Schema } from "effect"

class Person extends Schema.Class("Person")({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {}

// Attempt to create an instance with an invalid `name`
new Person({ id: 1, name: "" })
/* 
throws:
ParseError: Person (Constructor) 
└─ ["name"]
└─ NonEmptyString
└─ Predicate refinement failure
└─ Expected NonEmptyString, actual ""
*/
```

--------------------------------

### UTC Constructors

Source: https://effect.website/docs/data-types/datetime

Demonstrates how to create UTC DateTimes from various inputs like JavaScript Date objects, partial date parts, and strings.

```APIDOC
## UTC Constructors

### Description

Creates a UTC `DateTime` from various inputs. The input is interpreted as a local time and then converted to UTC by subtracting the timezone offset. If the input is invalid, an `IllegalArgumentException` is thrown.

### Method

`DateTime.make(input)`

### Parameters

#### Request Body

- **input** (Date | { year: number, month?: number, date?: number, hours?: number, minutes?: number, seconds?: number, milliseconds?: number } | string) - Required - The input value to create a DateTime from.

### Request Example

```javascript
import { DateTime } from "effect"

// From a JavaScript Date
const maybeUtc1 = DateTime.make(new Date("2025-01-01 04:00:00"))
console.log(maybeUtc1)
/*
Output:
{
  _id: 'Option',
  _tag: 'Some',
  value: '2025-01-01T03:00:00.000Z'
}
*/

// From partial date parts
const maybeUtc2 = DateTime.make({ year: 2025 })
console.log(maybeUtc2)
/*
Output:
{
  _id: 'Option',
  _tag: 'Some',
  value: '2025-01-01T00:00:00.000Z'
}
*/

// From a string
const maybeUtc3 = DateTime.make("2025-01-01")
console.log(maybeUtc3)
/*
Output:
{
  _id: 'Option',
  _tag: 'Some',
  value: '2025-01-01T00:00:00.000Z'
}
*/
```

### Response

#### Success Response (200)

- **_id** (string) - The type of the Option, either 'Some' or 'None'.
- **_tag** (string) - Indicates if the value is 'Some' or 'None'.
- **value** (string) - The UTC DateTime string in ISO 8601 format if successful.

#### Response Example

```json
{
  "_id": "Option",
  "_tag": "Some",
  "value": "2025-01-01T03:00:00.000Z"
}
```
```

--------------------------------

### Index Stream Elements with zipWithIndex

Source: https://effect.website/docs/stream/operations

The `Stream.zipWithIndex` operator attaches an index to each element of a stream. It pairs each element with its sequential position, starting from 0. This operator is helpful for maintaining order and referencing elements by their position.

```typescript
import { Stream, Effect } from "effect"

const stream = Stream.zipWithIndex(
  Stream.make("Mary", "James", "Robert", "Patricia")
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/* 
Output:
{
  _id: 'Chunk',
  values: [
    [ 'Mary', 0 ],
    [ 'James', 1 ],
    [ 'Robert', 2 ],
    [ 'Patricia', 3 ]
  ]
}
*/
```

--------------------------------

### Reverse Order Comparison with Effect-TS Order

Source: https://effect.website/docs/behaviour/order

Shows how to invert the sorting direction of an existing `Order` using `Order.reverse`. This example creates a descending order from a default ascending `Order.number`.

```typescript
import { Order } from "effect"

const ascendingOrder = Order.number

const descendingOrder = Order.reverse(ascendingOrder)

console.log(ascendingOrder(1, 3)) 
// Output: -1 (1 < 3 in ascending order)
console.log(descendingOrder(1, 3))
// Output: 1 (1 > 3 in descending order)
```

--------------------------------

### Effect.map data-last variant with pipe

Source: https://effect.website/docs/code-style/dual

Demonstrates the 'data-last' usage of Effect.map, where the 'Effect' argument is implicitly passed via the 'pipe' function. This style is ideal for chaining multiple transformations.

```typescript
const mappedEffect = pipe(
  effect,
  Effect.map(func)
)
```

```typescript
pipe(
  effect,
  Effect.map(func1),
  Effect.map(func2),
  ...)
```

--------------------------------

### Effect Schema: Accessing Base Schema with 'from'

Source: https://effect.website/docs/schema/filters

This example shows how to access the original schema before a filter was applied using the 'from' property. This is useful when you need to refer to the unfiltered schema for further operations.

```typescript
import { Schema } from "effect"

const LongString = Schema.String.pipe(
  Schema.filter((s) => s.length >= 10)
)

// Access the base schema, which is the string schema
// before the filter was applied
const From = LongString.from
```

--------------------------------

### Sequencing Schedule Combinator Example - Effect.js

Source: https://effect.website/docs/scheduling/schedule-combinators

Shows the 'Sequencing' schedule combinator. This combinator chains two schedules together. The first schedule runs to completion, and only then does the second schedule begin its execution.

```typescript
import { Array, Chunk, Duration, Effect, Schedule } from "effect"

// Assuming the log helper function is defined as above

const firstSchedule = Schedule.recurs(3).pipe(
  Schedule.addDelay(() => "100ms")
);

const secondSchedule = Schedule.spaced("50ms").pipe(
  Schedule.addDelay(() => "20ms")
);

const sequencedSchedule = Schedule.andThen(firstSchedule, secondSchedule);

console.log("--- Sequencing Schedule ---");
log(sequencedSchedule);

```

--------------------------------

### Create Fresh Layer Instance with Layer.fresh (Effect-TS)

Source: https://effect.website/docs/requirements-management/layer-memoization

Demonstrates how to create a fresh, non-shared instance of a layer using `Layer.fresh`. This is useful when you don't want to share a module across different parts of your application. The example shows how `ALive` is initialized twice when provided locally to `BLive` and `CLive` respectively.

```typescript
import { Effect, Context, Layer } from "effect"

class A extends Context.Tag("A")() {}

class B extends Context.Tag("B")() {}

class C extends Context.Tag("C")() {}

const ALive = Layer.effect(
  A,
  Effect.succeed({ a: 5 }).pipe(
    Effect.tap(() => Effect.log("initialized"))
  )
)

const BLive = Layer.effect(
  B,
  Effect.gen(function* () {
    const { a } = yield* A
    return { b: String(a) }
  })
)

const CLive = Layer.effect(
  C,
  Effect.gen(function* () {
    const { a } = yield* A
    return { c: a > 0 }
  })
)

const program = Effect.gen(function* () {
  yield* B
  yield* C
})

const runnable = Effect.provide(
  program,
  Layer.merge(
    Layer.provide(BLive, Layer.fresh(ALive)),
    Layer.provide(CLive, Layer.fresh(ALive))
  )
)

Effect.runPromise(runnable)
```

--------------------------------

### Effect TS: Patching TypeScript for Build-Time Diagnostics

Source: https://effect.website/docs/getting-started/devtools

Shows how to patch the local TypeScript installation to enable Effect diagnostics during the build process. This ensures that type-aware linting catches issues by performing type checking.

```bash
effect-language-service patch
```

--------------------------------

### Add Affixes with Stream.intersperseAffixes

Source: https://effect.website/docs/stream/operations

Stream.intersperseAffixes provides more control by allowing different elements to be added at the start, between elements, and at the end of the stream. This is valuable for creating structured output like arrays or delimited strings with custom formatting.

```typescript
import { Stream, Effect } from "effect"

// Create a stream and add affixes:
// - `[` at the start
// - `|` between elements
// - `]` at the end
const stream = Stream.make(1, 2, 3, 4, 5).pipe(
  Stream.intersperseAffixes({
    start: "[",
    middle: "|",
    end: "]"
  })
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/* 
Output: 
{ 
_id: 'Chunk', 
values: [ 
'[', 1, '|', 2, '|', 
3, '|', 4, '|', 5, 
']' 
] 
} 
*/
```

--------------------------------

### Debounce Stream Values in Effect-TS

Source: https://effect.website/docs/stream/operations

This example shows how to use `Stream.debounce` to only emit values after a certain quiet period. It's useful for preventing excessive processing when data arrives rapidly. It requires the 'effect' library.

```typescript
import { Stream, Effect } from "effect"

// Helper function to log with elapsed time since the last log
let last = Date.now()
const log = (message: string) =>
  Effect.sync(() => {
    const end = Date.now()
    console.log(`${message} after ${end - last}ms`)
    last = end
  })

const stream = Stream.make(1, 2, 3).pipe(
  // Emit the value 4 after 200 ms
  Stream.concat(
    Stream.fromEffect(Effect.sleep("200 millis").pipe(Effect.as(4)))
  ),
  // Continue with more rapid values
  Stream.concat(Stream.make(5, 6)),
  // Emit 7 after 150 ms
  Stream.concat(
    Stream.fromEffect(Effect.sleep("150 millis").pipe(Effect.as(7)))
  ),
  Stream.concat(Stream.make(8)),
  Stream.tap((n) => log(`Received ${n}`)),
  // Only emit values after a pause of at least 100 milliseconds
  Stream.debounce("100 millis"),
  Stream.tap((n) => log(`> Emitted ${n}`))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
```

--------------------------------

### Duration Filters in Effect Schema

Source: https://effect.website/docs/schema/filters

Explains filters for validating Duration values, including comparisons like greater than, less than, and greater than or equal to, with examples using string representations of durations.

```typescript
import { Schema } from "effect"

// Specifies a duration greater than 5 seconds
Schema.Duration.pipe(Schema.greaterThanDuration("5 seconds"))

// Specifies a duration greater than or equal to 5 seconds
Schema.Duration.pipe(Schema.greaterThanOrEqualToDuration("5 seconds"))

// Specifies a duration less than 5 seconds
Schema.Duration.pipe(Schema.lessThanDuration("5 seconds"))
```

--------------------------------

### Using Enqueue and Dequeue Queues Together in Effect-TS

Source: https://effect.website/docs/concurrency/queue

Demonstrates how to combine `Enqueue` and `Dequeue` interfaces for a queue within Effect-TS. This example shows a program that adds values to a queue using an `Enqueue` interface and retrieves them using a `Dequeue` interface, illustrating the flexibility of Effect-TS Queues.

```typescript
import { Effect, Queue } from "effect"

const send = (offerOnlyQueue: Queue.Enqueue, value: number) => {
  return Queue.offer(offerOnlyQueue, value)
}

const receive = (takeOnlyQueue: Queue.Dequeue) => {
  return Queue.take(takeOnlyQueue)
}

const program = Effect.gen(function* () {
  const queue = yield* Queue.unbounded()

  // Add values to the queue
  yield* send(queue, 1)
  yield* send(queue, 2)

  // Retrieve values from the queue
  console.log(yield* receive(queue))
  console.log(yield* receive(queue))
})

Effect.runFork(program)
/* 
Output:
1
2
*/
```

--------------------------------

### Scoped Annotations with Effect.annotateLogsScoped

Source: https://effect.website/docs/observability/logging

This example demonstrates how to use `Effect.annotateLogsScoped` to apply annotations to log messages within a specific scope. Annotations are only applied to logs generated within the scope defined by `Effect.annotateLogsScoped` and are not present in logs outside this scope.

```typescript
import { Effect } from "effect"

const program = Effect.gen(function* () {
  yield* Effect.log("no annotations") // No annotations
  yield* Effect.annotateLogsScoped({ key: "value" }) // Scoped annotation
  yield* Effect.log("message1") // Annotation applied
  yield* Effect.log("message2") // Annotation applied
}).pipe(
  Effect.scoped,
  // Outside scope, no annotations
  Effect.andThen(Effect.log("no annotations again"))
)

Effect.runFork(program)
```

--------------------------------

### Repeat Action Multiple Times with Effect.repeatN

Source: https://effect.website/docs/scheduling/repetition

Demonstrates using Effect.repeatN to execute an effect a specified number of times in addition to its initial run. It imports Effect and Console from 'effect'. The example repeats a logging action twice.

```typescript
import { Effect, Console } from "effect"

const action = Console.log("success")

// Repeat the action 2 additional times after the first execution
const program = Effect.repeatN(action, 2)

Effect.runPromise(program)
```

--------------------------------

### Partition Stream with Effectful Predicate using Stream.partitionEither

Source: https://effect.website/docs/stream/operations

This example demonstrates how to use Stream.partitionEither to split a stream into two substreams based on an effectful predicate. It separates elements into those producing Either.left and Either.right values. The input is a stream of integers, and the output is two streams, one for odd numbers and one for even numbers.

```typescript
import { Stream, Effect, Either } from "effect"

// ┌─── Effect<[Stream, Stream], never, Scope>
// ▼
const program = Stream.range(1, 9).pipe(
  Stream.partitionEither(
    // Simulate an effectful computation
    (n) => Effect.succeed(n % 2 === 0 ? Either.right(n) : Either.left(n)),
    { bufferSize: 5 }
  )
)

Effect.runPromise(
  Effect.scoped(
    Effect.gen(function*() {
      const [odds, evens] = yield* program
      console.log(yield* Stream.runCollect(odds))
      console.log(yield* Stream.runCollect(evens))
    })
  )
)

/* 
Output:
{
  _id: 'Chunk', values: [ 1, 3, 5, 7, 9 ]
}
{
  _id: 'Chunk', values: [ 2, 4, 6, 8 ]
}
*/
```

--------------------------------

### Mocking Configuration Provider for Tests (Effect-TS)

Source: https://effect.website/docs/configuration

Demonstrates mocking a configuration provider using ConfigProvider.fromMap for testing. Allows running Effect programs with predefined configuration values instead of environment variables.

```typescript
import { Config, ConfigProvider, Effect } from "effect"

class HostPort {
  constructor(readonly host: string, readonly port: number) {}
  get url() {
    return `${this.host}:${this.port}`
  }
}

const config = Config.map(
  Config.all([Config.string("HOST"), Config.number("PORT")]),
  ([host, port]) => new HostPort(host, port)
)

const program = Effect.gen(function* () {
  const hostPort = yield* config
  console.log(`Application started: ${hostPort.url}`)
})

// Create a mock config provider using a map with test data
const mockConfigProvider = ConfigProvider.fromMap(
  new Map([
    ["HOST", "localhost"],
    ["PORT", "8080"]
  ])
)

// Run the program using the mock config provider
Effect.runPromise(Effect.withConfigProvider(program, mockConfigProvider))
```

--------------------------------

### Create Configuration for a HashSet

Source: https://effect.website/docs/configuration

Demonstrates using the `Config.hashSet` combinator to create a configuration that expects a set of unique values. Duplicate inputs are handled appropriately.

```typescript
import { Config, Effect } from "effect"

const program = Effect.gen(function* () {
  const config = yield* Config.hashSet(Config.string(), "MYSET")
  console.log(config)
})

Effect.runPromise(program)
// Run:
// MYSET=a,"b c",d,a npx tsx index.ts
// Output:
// { _id: 'HashSet', values: [ 'd', 'a', 'b c' ] }
```

--------------------------------

### Define and Compare Recursive Case Classes with Data.case

Source: https://effect.website/docs/data-types/data

Illustrates the creation of a recursive data structure, a binary tree, using Data.case. This example shows how to define a type that can contain itself and how to compare instances for equality.

```typescript
import { Data, Equal } from "effect"

interface BinaryTree<T> {
  readonly value: T
  readonly left: BinaryTree<T> | null
  readonly right: BinaryTree<T> | null
}

const BinaryTree = Data.case<BinaryTree<number>>()

const tree1 = BinaryTree({
  value: 0,
  left: BinaryTree({ value: 1, left: null, right: null }),
  right: null
})

const tree2 = BinaryTree({
  value: 0,
  left: BinaryTree({ value: 1, left: null, right: null }),
  right: null
})

console.log(Equal.equals(tree1, tree2)) // Output: true
```

--------------------------------

### Running an Effect (Sync)

Source: https://context7_llms

Shows how to synchronously run an Effect and handle its outcome. This is useful for simple computations where immediate results are desired.

```typescript
import * as Effect from "@effect/io/Effect"

const computation = Effect.sync(() => 10 + 5)

const result = Effect.runSync(computation)

console.log(result) // 15
```

--------------------------------

### Recurs Schedule: Execute a Task a Fixed Number of Times

Source: https://effect.website/docs/scheduling/built-in-schedules

Illustrates the `Schedule.recurs` schedule, which repeats a task a specified number of times. The example logs the delays for each of the 5 recurrences.

```typescript
import { Array, Chunk, Duration, Effect, Schedule } from "effect"

const log = (
  schedule: Schedule.Schedule,
  delay: Duration.DurationInput = 0
): void => {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () => delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) => {
    console.log(
      i === maxRecurs
        ? "..."
        : i === delays.length - 1
        ? "(end)"
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.recurs(5)

log(schedule)
```

--------------------------------

### Fork Fiber into Specific Scope with Effect.forkIn

Source: https://effect.website/docs/concurrency/fibers

This example illustrates using `Effect.forkIn` to fork a fiber into a specific scope. This allows for more fine-grained control over the fiber's lifecycle, enabling it to outlive inner scopes but still be terminated when the target outer scope is closed. It requires the 'effect' library.

```typescript
import { Console, Effect, Schedule } from "effect"

// Child fiber that logs a message repeatedly every second
const child = Effect.repeat(
  Console.log("child: still running!"),
  Schedule.fixed("1 second")
)

const program = Effect.scoped(
  Effect.gen(function* () {
    yield* Effect.addFinalizer(() =>
      Console.log("The outer scope is about to be closed!")
    )

    // Capture the outer scope
    const outerScope = yield* Effect.scope

    // Create an inner scope
    yield* Effect.scoped(
      Effect.gen(function* () {
        yield* Effect.addFinalizer(() =>
          Console.log("The inner scope is ab
```

--------------------------------

### Provide Random Service Implementation - Effect.js

Source: https://effect.website/docs/requirements-management/services

Demonstrates providing a custom implementation for the `Random` service to a program. The `Random` service is defined with a `next` operation that generates a random number. This example shows how to use `Effect.provideService` to inject this custom service implementation.

```typescript
import * as Effect from "effect/Effect";
import * as Random from "effect/Random";

const program = Effect.gen(function* (_) {
  const random = yield* Random.Random;
  return yield* random.next;
});

Effect.runPromise(Effect.provideService(program, Random, {
  next: Effect.sync(() => Math.random())
})).then(console.log);
// Example Output: 0.9957979486841035
```

--------------------------------

### Importing the Micro Module in Effect.js

Source: https://effect.website/docs/micro/effect-users

Demonstrates how to import the 'Micro' module from the 'effect' library using both default and namespace imports. It also touches upon tree shaking considerations with bundlers.

```typescript
import { Micro } from "effect"

// Or using a namespace import:
import * as Micro from "effect/Micro"
```

--------------------------------

### Defining Tuples with Optional Elements in Effect Schema

Source: https://effect.website/docs/schema/basic-usage

Explains how to define a tuple that includes optional elements using Schema.optionalElement. The example shows a tuple with a required string and an optional number.

```typescript
import { Schema } from "effect"

// Define a tuple with a required string and an optional number
const schema = Schema.Tuple(
  Schema.String, // required element
  Schema.optionalElement(Schema.Number) // optional element
)

// ┌─── readonly [string, number?]
// ▼
type Type = typeof schema.Type
```

--------------------------------

### Defining a Cache Service with Effect.Service and Dependencies

Source: https://effect.website/docs/requirements-management/layers

Shows how to define a Cache service using Effect.Service, specifying its effectful creation logic and its dependency on the FileSystem service. This simplifies service definition by combining tag, layer, and dependencies.

```typescript
import { FileSystem } from "@effect/platform"
import { NodeFileSystem } from "@effect/platform-node"
import { Effect } from "effect"

// Define a Cache service
class Cache extends Effect.Service()("app/Cache", {
  // Define how to create the service
  effect: Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem
    const lookup = (key: string) => fs.readFileString(`cache/${key}`)
    return { lookup } as const
  }),
  // Specify dependencies
  dependencies: [NodeFileSystem.layer]
}) {}
```

--------------------------------

### Reading from Standard Input with Effect

Source: https://effect.website/docs/platform/terminal

Illustrates how to read a line of input from the user via standard input using the `readLine` method of the `Terminal` service. The example logs the received input to the console and is configured to run in a Node.js environment.

```typescript
import { Terminal } from "@effect/platform"
import { NodeRuntime, NodeTerminal } from "@effect/platform-node"
import { Effect } from "effect"

const program = Effect.gen(function* () {
  const terminal = yield* Terminal.Terminal
  const input = yield* terminal.readLine
  console.log(`input: ${input}`)
})

NodeRuntime.runMain(program.pipe(Effect.provide(NodeTerminal.layer)))
// Input: "hello"
// Output: "input: hello"
```

--------------------------------

### Parse Environment Variables to Constant Case with Effect.js

Source: https://effect.website/docs/configuration

This snippet shows how to load configuration from environment variables and convert their keys to constant case using Effect.js's ConfigProvider. It requires setting environment variables like HOST and PORT. The output demonstrates the application starting with the provided host and port.

```typescript
import { ConfigProvider } from "effect/ConfigProvider"

const program = ConfigProvider.fromEnv().pipe(ConfigProvider.constantCase)

// Example environment variables setup:
// HOST=localhost PORT=8080 npx tsx your-script.ts

// Example output:
// Application started: localhost:8080
```

--------------------------------

### Managing a Scope with Finalizers

Source: https://effect.website/docs/resource-management/scope

This example demonstrates how to create a new scope, add multiple finalizers to it, and then close the scope. The finalizers are executed in the reverse order of their addition when the scope is closed, ensuring proper resource cleanup.

```typescript
import { Scope, Effect, Console, Exit } from "effect"

const program = 
  // create a new scope 
  Scope.make().pipe(
    // add finalizer 1
    Effect.tap((scope) => 
      Scope.addFinalizer(scope, Console.log("finalizer 1")) 
    ),
    // add finalizer 2
    Effect.tap((scope) => 
      Scope.addFinalizer(scope, Console.log("finalizer 2")) 
    ),
    // close the scope 
    Effect.andThen((scope) => 
      Scope.close(scope, Exit.succeed("scope closed successfully")) 
    )
  )

Effect.runPromise(program)
/* 
Output:
finalizer 2 <-- finalizers are closed in reverse order
finalizer 1 
*/
```

--------------------------------

### Server and Client Interaction with SubscriptionRef in Effect.js

Source: https://effect.website/docs/state-management/subscriptionref

This snippet defines the core components for a real-time update system. The `server` function continuously increments a shared `Ref`, while the `client` function processes chunks of these updates from a `Stream`. The `program` orchestrates the setup by creating a `SubscriptionRef`, forking the server, launching multiple clients concurrently, and then collecting and displaying their results.

```typescript
import { Ref, Effect, Stream, Random, SubscriptionRef, Fiber } from "effect"

// Server function that increments a shared value forever
const server = (ref: Ref.Ref) =>
  Ref.update(ref, (n) => n + 1).pipe(Effect.forever)

// Client function that observes the stream of changes
const client = (changes: Stream.Stream) =>
  Effect.gen(function* () {
    const n = yield* Random.nextIntBetween(1, 10)
    const chunk = yield* Stream.runCollect(Stream.take(changes, n))
    return chunk
  })

const program = Effect.gen(function* () {
  // Create a SubscriptionRef with an initial value of 0
  const ref = yield* SubscriptionRef.make(0)

  // Fork the server to run concurrently
  const serverFiber = yield* Effect.fork(server(ref))

  // Create 5 clients that subscribe to the changes stream
  const clients = new Array(5).fill(null).map(() => client(ref.changes))

  // Run all clients in concurrently and collect their results
  const chunks = yield* Effect.all(clients, { concurrency: "unbounded" })

  // Interrupt the server when clients are done
  yield* Fiber.interrupt(serverFiber)

  // Output the results collected by each client
  for (const chunk of chunks) {
    console.log(chunk)
  }
})

Effect.runPromise(program)
```

--------------------------------

### Async/Await Comparison with Effect.gen (TypeScript)

Source: https://effect.website/docs/getting-started/using-generators

Provides a direct comparison to the Effect.gen example using standard async/await syntax in TypeScript. Both snippets perform the same logical operations (fetching data, applying discount, adding service charge) to highlight the syntactical similarities in program flow.

```typescript
const addServiceCharge = (amount: number) => amount + 1

const applyDiscount = (
  total: number,
  discountRate: number
): Promise =>
  discountRate === 0
    ? Promise.reject(new Error("Discount rate cannot be zero"))
    : Promise.resolve(total - (total * discountRate) / 100)

const fetchTransactionAmount = Promise.resolve(100)

const fetchDiscountRate = Promise.resolve(5)

export const program = async function () {
  const transactionAmount = await fetchTransactionAmount
  const discountRate = await fetchDiscountRate
  const discountedAmount = await applyDiscount(
    transactionAmount,
    discountRate
  )
  const finalAmount = addServiceCharge(discountedAmount)
  return `Final amount to charge: ${finalAmount}`
}
```

--------------------------------

### Default ParseError (Type Mismatch)

Source: https://effect.website/docs/schema/error-messages

This example shows the default ParseError when a data type mismatch occurs during schema decoding. It highlights the expected structure versus the actual received input.

```typescript
import { Schema } from "effect"

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

Schema.decodeUnknownSync(Person)(null)
// Output: ParseError: Expected { readonly name: string; readonly age: number }, actual null
```

--------------------------------

### Mock File System with Custom Behavior using Effect Platform

Source: https://effect.website/docs/platform/file-system

Illustrates how to mock the FileSystem service in testing environments using FileSystem.layerNoop. This allows for simulating file system interactions without actual disk I/O. Custom return values for methods like readFileString and exists can be provided to the layerNoop function.

```typescript
import { FileSystem } from "@effect/platform"
import { Effect } from "effect"

const program = Effect.gen(function* () {
  const fs = yield* FileSystem.FileSystem

  const exists = yield* fs.exists("/some/path")
  console.log(exists)

  const content = yield* fs.readFileString("/some/path")
  console.log(content)
})

const customMock = FileSystem.layerNoop({
  readFileString: () => Effect.succeed("mocked content"),
  exists: (path) => Effect.succeed(path === "/some/path")
})

Effect.runPromise(program.pipe(Effect.provide(customMock)))
```

--------------------------------

### Using Exactness with Optional Field

Source: https://effect.website/docs/schema/advanced-usage

This example shows how to use `exact: true` with Schema.optionalWith to enforce strict typing for an optional field. Decoding `undefined` will result in a `ParseError`.

```typescript
import { Schema } from "effect"

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    exact: true
  })
})

// Decoding examples
console.log(Schema.decodeUnknownSync(Product)({ quantity: "1" }))
// Output: { quantity: 1 }
console.log(Schema.decodeUnknownSync(Product)({}))
// Output: {}
console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
/* 
throws:
ParseError: { readonly quantity?: NumberFromString } 
└─ ["quantity"]
└─ NumberFromString
└─ Encoded side transformation failure
└─ Expected string, actual undefined 
*/

// Encoding examples
console.log(Schema.encodeSync(Product)({ quantity: 1 }))
// Output: { quantity: "1" }
console.log(Schema.encodeSync(Product)({}))
// Output: {}
```

--------------------------------

### Custom Timeout Error with Effect.timeoutFail

Source: https://effect.website/docs/error-management/timing-out

The Effect.timeoutFail function allows you to produce a specific error when a timeout occurs. This example demonstrates defining a custom error class MyTimeoutError and using it with timeoutFail.

```typescript
import { Effect, Data } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

class MyTimeoutError extends Data.TaggedError("MyTimeoutError")<{}> {}

const program = task.pipe(
  Effect.timeoutFail({
    duration: "1 second",
    onTimeout: () => new MyTimeoutError() // Custom timeout error
  })
)

Effect.runPromiseExit(program).then(console.log)
```

--------------------------------

### Define Config Service Layer (Effect.js)

Source: https://effect.website/docs/requirements-management/layers

Defines a Layer for the Config service using Layer.succeed. This layer provides the 'getConfig' effect, which returns application configuration including logLevel and connection string. It's a basic setup for configuration management.

```typescript
import { Effect, Context, Layer } from "effect"

class Config extends Context.Tag("Config")<Config, {
  readonly getConfig: Effect.Effect<{
    readonly logLevel: string
    readonly connection: string
  }>
}>() {}

const ConfigLive = Layer.succeed(Config, {
  getConfig: Effect.succeed({
    logLevel: "INFO",
    connection: "mysql://username:password@hostname:port/database_name"
  })
})
```

--------------------------------

### Running an Effect Application with Graceful Teardown (Node.js)

Source: https://effect.website/docs/code-style/guidelines

Demonstrates how to use `NodeRuntime.runMain` to execute an Effect application on Node.js, ensuring graceful teardown upon interruption (e.g., CTRL+C). It includes adding a finalizer to log an exit message and repeating a process until interrupted.

```typescript
import { Effect, Console, Schedule, pipe } from "effect"
import { NodeRuntime } from "@effect/platform-node"

const program = pipe(
  Effect.addFinalizer(() => Console.log("Application is about to exit!")),
  Effect.andThen(Console.log("Application started!")),
  Effect.andThen(
    Effect.repeat(Console.log("still alive..."), {
      schedule: Schedule.spaced("1 second")
    })
  ),
  Effect.scoped
)

// Use NodeRuntime.runMain for graceful teardown on CTRL+C
NodeRuntime.runMain(program)
/* 
Output:
Application started!
still alive...
still alive...
still alive...
still alive...
^C <-- CTRL+C
Application is about to exit!
*/
```

--------------------------------

### Add Custom Method to Effect Schema Class

Source: https://effect.website/docs/schema/classes

Illustrates adding a custom method to an Effect Schema class. The example defines a 'greet' method within the Person class that returns a greeting string incorporating the person's name.

```typescript
import { Schema } from "effect"

class Person extends Schema.Class("Person")({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {
  // Custom method to return a greeting
  greet() {
    return `Hello, my name is ${this.name}`
  }
}

const john = new Person({ id: 1, name: "John" })

// Use the custom method
console.log(john.greet())
// Output: "Hello, my name is John"
```

--------------------------------

### Combine Schedules with Sequencing (Effect)

Source: https://effect.website/docs/scheduling/schedule-combinators

Demonstrates using Schedule.andThen to combine two schedules sequentially. The first schedule runs fully before the second one takes over. This example switches from fixed retries to periodic execution.

```typescript
import { Array, Chunk, Duration, Effect, Schedule } from "effect"

const log = (
  schedule: Schedule.Schedule,
  delay: Duration.DurationInput = 0
): void => {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () => delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) => {
    console.log(
      i === maxRecurs
        ? "..."
        : i === delays.length - 1
        ? "(end)"
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.andThen(
  Schedule.recurs(5),
  Schedule.spaced("1 second")
)

log(schedule)
```

--------------------------------

### Deriving Custom Object Equivalence with mapInput

Source: https://effect.website/docs/behaviour/equivalence

Shows how to create a custom equivalence for objects by using `Equivalence.mapInput`. This example derives an equivalence for `User` objects that compares them based solely on their `id` property.

```typescript
import { Equivalence } from "effect"

interface User {
  readonly id: number
  readonly name: string
}

// Create an equivalence that compares User objects based only on the id
const equivalence = Equivalence.mapInput(
  Equivalence.number, // Base equivalence
  (user: User) => user.id // Function to extract the value to compare
)
```

--------------------------------

### Provide and Use Custom Service in Effect-TS

Source: https://effect.website/docs/micro/new-users

Demonstrates how to provide an implementation for a custom service and use it within an Effect-TS program. The `Micro.provideService` function is used to associate a concrete implementation (e.g., an object with a `next` method returning `Math.random()`) with the `Random` service tag. The program can then be executed.

```typescript
import { Micro, Context } from "effect"

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag("MyRandomService")< 
Random,
 {
  readonly next: Micro.Micro
 }
>() {}

// Using the service
const program = Micro.gen(function* () {
  // Access the Random service
  const random = yield* Micro.service(Random)

  // Retrieve a random number from the service
  const randomNumber = yield* random.next

  console.log(`random number: ${randomNumber}`)
})

// Providing the implementation
// 
// // 
// // ┌─── Micro
// // ▼
const runnable = Micro.provideService(program, Random, {
  next: Micro.sync(() => Math.random())
})

Micro.runPromise(runnable)
/* 
Example Output:
random number: 0.8241872233134417 
*/
```

--------------------------------

### Define Discriminated Union in TypeScript

Source: https://effect.website/docs/schema/basic-usage

This example shows the basic TypeScript syntax for defining a discriminated union with a common discriminant property ('kind') for different shape types (Circle, Square).

```typescript
type Circle = {
  readonly kind: "circle"
  readonly radius: number
}

type Square = {
  readonly kind: "square"
  readonly sideLength: number
}

type Shape = Circle | Square
```

--------------------------------

### Run Program with In-Memory KeyValueStore

Source: https://effect.website/docs/platform/key-value-store

Demonstrates executing an Effect program that utilizes the in-memory KeyValueStore implementation. This is useful for testing or lightweight applications.

```typescript
import { Effect, layerMemory } from "@effect/platform/KeyValueStore"

const program = Effect.gen(function* () {
  const kv = yield* KeyValueStore
  yield* kv.set("key", "value")
  console.log(yield* kv.size)
  console.log(yield* kv.get("key"))
})

Effect.runPromise(program.pipe(Effect.provide(layerMemory)))
```

--------------------------------

### Combine Schedules with Union (Effect)

Source: https://effect.website/docs/scheduling/schedule-combinators

Demonstrates using Schedule.union to combine two schedules. The union operator selects the shortest delay at each step. This example combines an exponential backoff with a spaced interval.

```typescript
import { Array, Chunk, Duration, Effect, Schedule } from "effect"

const log = (
  schedule: Schedule.Schedule,
  delay: Duration.DurationInput = 0
): void => {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () => delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) => {
    console.log(
      i === maxRecurs
        ? "..."
        : i === delays.length - 1
        ? "(end)"
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.union(
  Schedule.exponential("100 millis"),
  Schedule.spaced("1 second")
)

log(schedule)
```

--------------------------------

### Define TaggedStruct with Multiple Tags

Source: https://effect.website/docs/schema/basic-usage

Illustrates how to define a schema using Schema.TaggedStruct that includes multiple tags. This example adds a 'category' tag alongside the primary '_tag' for more specific data structuring.

```typescript
import { Schema } from "effect"

const Product = Schema.TaggedStruct("Product", {
  category: Schema.tag("Electronics"),
  name: Schema.String,
  price: Schema.Number
})

// `_tag` and `category` are optional when creating an instance
console.log(Product.make({ name: "Smartphone", price: 999 }))
/* 
Output: 
{
  _tag: 'Product',
  category: 'Electronics',
  name: 'Smartphone',
  price: 999
}
*/
```

--------------------------------

### Combining Nullability and Exactness with Optional Field

Source: https://effect.website/docs/schema/advanced-usage

This example combines `exact: true` and `nullable: true` in Schema.optionalWith. It enforces strict typing while treating `null` as a missing value during decoding.

```typescript
import { Schema } from "effect"

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    exact: true,
    nullable: true
  })
})

// Decoding examples
console.log(Schema.decodeUnknownSync(Product)({ quantity: "1" }))
// Output: { quantity: 1 }
console.log(Schema.decodeUnknownSync(Product)({}))
// Output: {}
console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
/* 
throws:
ParseError: (Struct (Encoded side) <-> Struct (Type side))
└─ Encod
```

--------------------------------

### Custom Constructor: Promise vs. Effect

Source: https://effect.website/docs/additional-resources/effect-vs-promise

Shows how to create asynchronous operations with custom logic using the Promise constructor and Effect.gen. Both allow for deferred execution and conditional resolution or rejection.

```javascript
const task = new Promise((resolve, reject) => {
  setTimeout(() => {
    Math.random() > 0.5 ? resolve(2) : reject("Uh oh!")
  }, 300)
})
```

```typescript
import { Effect } from "effect"

const task = Effect.gen(function* () {
  yield* Effect.sleep("300 millis")
  return Math.random() > 0.5 ? 2 : yield* Effect.fail("Uh oh!")
})
```

--------------------------------

### Combine Option and Effect - Example

Source: https://effect.website/docs/data-types/option

Demonstrates how `Option` values can be seamlessly integrated with `Effect` computations. `Option` variants (`None`, `Some`) map directly to `Effect` representations of absence or presence of a value. This allows for safe composition of potentially failing or optional asynchronous operations.

```typescript
import { Effect, Option } from "effect"

// Function to get the head of an array, returning Option
const head = (array: ReadonlyArray): Option.Option =>
  array.length > 0 ? Option.some(array[0]) : Option.none()

// Simulated fetch function that returns Effect
const fetchData = (): Effect.Effect => {
  const success = Math.random() > 0.5
  return success
    ? Effect.succeed("some data")
    : Effect.fail("Failed to fetch data")
}

// Mixing Either and Effect
const program = Effect.all([head([1, 2, 3]), fetchData()])

Effect.runPromise(program).then(console.log)
/*
Example Output:
[
  1,
  'some data'
]
*/
```

--------------------------------

### Asynchronous Schema Validation Example

Source: https://effect.website/docs/schema/standard-schema

Demonstrates asynchronous validation of a schema. It shows how to validate an object against a standard schema and the expected output when validation fails due to an empty string for the 'name' field. This function relies on the 'effect' library.

```typescript
import { Effect, Schema } from "effect"

// Assuming asyncStandardSchema is defined elsewhere and contains a "~standard" property for validation.
// Example structure for asyncStandardSchema["~standard"]: Schema.Schema<any, any>

// Validate asynchronously
console.log(asyncStandardSchema["~standard"].validate({ name: "" }))
/* 
Output:
Promise { 
"issues": [
  {
    "path": [
      "name"
    ],
    "message": "Expected a non empty string, actual \"\""
  }
]
}
*/
```

--------------------------------

### Running an Effect (Async)

Source: https://context7_llms

Demonstrates how to asynchronously run an Effect, typically involving promises or other asynchronous operations. It handles potential errors and successes.

```typescript
import * as Effect from "@effect/io/Effect"

const asyncComputation = Effect.promise(() => Promise.resolve(20))

Effect.runPromise(asyncComputation)
  .then(result => console.log(result))
  .catch(error => console.error("An error occurred:", error)) // Outputs: 20
```

--------------------------------

### Simplify Resource Management with acquireUseRelease

Source: https://effect.website/docs/micro/new-users

The `acquireUseRelease` function simplifies resource management by automating the scope and release of resources. It takes `acquire`, `use`, and `release` functions as arguments, eliminating the need for manual scope management.

```typescript
import { Micro } from "effect"

// Define the interface for the resource
interface MyResource {
  readonly contents: string
  readonly close: () => Promise
}

// Simulate getting the resource
const getMyResource = (): Promise =>
  Promise.resolve({
    contents: "lorem ipsum",
    close: () =>
      new Promise((resolve) => {
        console.log("Resource released")
        resolve()
      })
  })

// Define the acquisition of the resource with error handling
const acquire = Micro.tryPromise({
  try: () =>
    getMyResource().then((res) => {
      console.log("Resource acquired")
      return res
    }),
  catch: () => new Error("getMyResourceError")
})

// Define the release of the resource
const release = (res: MyResource) => Micro.promise(() => res.close())

const use = (res: MyResource) =>
  Micro.sync(() => console.log(`content is ${res.contents}`)) 

// ┌─── Micro 
// ▼ 
const program = Micro.acquireUseRelease(acquire, use, release)

Micro.runPromise(program)
/* 
Resource acquired
content is lorem ipsum
Resource released 
*/
```

--------------------------------

### Recovering from All Errors with Effect.catchAllCause

Source: https://effect.website/docs/error-management/expected-errors

This example demonstrates how to recover from any type of error in an Effect program using `Effect.catchAllCause`. It checks the cause of the error and returns a success value, allowing for graceful handling of both regular failures and defects.

```typescript
import * as Effect from "effect/Effect"
import * as Cause from "effect/Cause"

const program = Effect.fail("Something went wrong!")

// Recover from all errors by examining the cause
const recovered = program.pipe(
  Effect.catchAllCause((cause) =>
    Cause.isFailType(cause)
      ? Effect.succeed("Recovered from a regular error")
      : Effect.succeed("Recovered from a defect")
  )
)

Effect.runPromise(recovered).then(console.log)
// Output: "Recovered from a regular error"
```

--------------------------------

### EffectJS: Indefinitely Recurring Schedule (forever)

Source: https://effect.website/docs/scheduling/built-in-schedules

Demonstrates the `Schedule.forever` schedule, which repeats indefinitely. The example uses the `log` helper function to show the execution delays, which will continue without end.

```typescript
import { Array, Chunk, Duration, Effect, Schedule } from "effect"

const log = (
  schedule: Schedule.Schedule,
  delay: Duration.DurationInput = 0
): void => {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () => delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) => {
    console.log(
      i === maxRecurs
        ? "..."
        : i === delays.length - 1
        ? "(end)"
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.forever

log(schedule)
/* 
Output:
#1: 0ms < forever 
#2: 0ms 
#3: 0ms 
#4: 0ms 
#5: 0ms 
#6: 0ms 
*/
```

--------------------------------

### Using a Sink to Collect Stream Elements

Source: https://effect.website/docs/sink/introduction

This example demonstrates how to use a Sink to consume elements from a Stream. It creates a stream of numbers and a Sink that takes the first two elements. The Stream.run function is then used to process the stream with the sink, and the result is logged to the console. This showcases a basic application of Sinks for data collection.

```typescript
import { Stream, Sink, Effect } from "effect"

// ┌─── Stream
// ▼
const stream = Stream.make(1, 2, 3)

// Create a sink to take the first 2 elements of the stream
//
// ┌─── Sink, number, number, never, never>
// ▼
const sink = Sink.take(2)

// Run the stream through the sink to collect the elements
//
// ┌─── Effect
// ▼
const sum = Stream.run(stream, sink)

Effect.runPromise(sum).then(console.log)
/*
Output:
{
  _id: 'Chunk',
  values: [ 1, 2 ]
}
*/
```

--------------------------------

### Executing Database Queries with Effect and Layers (TypeScript)

Source: https://effect.website/docs/requirements-management/layers

This snippet shows how to define a query function using Effect.gen, which logs the SQL query and retrieves connection details from configuration. It then defines live implementations for configuration and logging, and a main live layer that provides these services. Finally, it constructs and runs a program that queries the database.

```typescript
const query = (sql: string) =>
  Effect.gen(function* () {
    yield* logger.log(`Executing query: ${sql}`)
    const { connection } = yield* config.getConfig
    return { result: `Results from ${connection}` }
  })

const AppConfigLive = Layer.merge(ConfigLive, LoggerLive)

const MainLive = DatabaseLive.pipe(
  Layer.provide(AppConfigLive),
  Layer.provide(ConfigLive)
)

const program = Effect.gen(function* () {
  const database = yield* Database
  const result = yield* database.query("SELECT * FROM users")
  return result
})

const runnable = Effect.provide(program, MainLive)

Effect.runPromise(runnable).then(console.log)
```

--------------------------------

### Simulate Paginated API Fetch with Effect

Source: https://effect.website/docs/stream/creating

Demonstrates fetching data from a simulated paginated API using Effect. Defines a type for paginated results and a function to fetch pages. Useful for understanding pagination patterns. Requires 'effect' library.

```typescript
import { Chunk, Effect } from "effect"

type RawData = string 

class PageResult {
  constructor(
    readonly results: Chunk.Chunk,
    readonly isLast: boolean
  ) {}
}

const pageSize = 2

const listPaginated = (
  pageNumber: number 
): Effect.Effect => {
  return Effect.succeed(
    new PageResult(
      Chunk.map(
        Chunk.range(1, pageSize),
        (index) => `Result ${pageNumber}-`
        }
      ]
    }
  ]
}
```
```

--------------------------------

### Get Duration Value in Milliseconds (TypeScript)

Source: https://effect.website/docs/data-types/duration

Retrieves the value of a duration in milliseconds using `Duration.toMillis`. This function is useful for obtaining a numerical representation of time for calculations or logging.

```typescript
import { Duration } from "effect"

console.log(Duration.toMillis(Duration.seconds(30)))
// Output: 30000
```

--------------------------------

### Create Stream with Stream.iterate

Source: https://effect.website/docs/stream/creating

Generates a stream by iteratively applying a function to an initial value. The stream starts with the initial value, followed by subsequent values produced by repeatedly applying the function.

```typescript
import { Stream, Effect } from "effect"

// Creating a stream of incrementing numbers
const stream = Stream.iterate(1, (n) => n + 1) // Produces 1, 2, 3, ...

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(
  console.log
)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }
```

--------------------------------

### Create and Use a Counter with Effect.js Ref

Source: https://effect.website/docs/state-management/ref

This snippet shows how to create a simple Counter class using Effect.js Ref. It demonstrates initializing a Ref, defining methods to increment, decrement, and get the counter's value, and running a program that manipulates the counter. The `Ref.make` and `Ref.update` operations are effectful.

```typescript
import { Effect, Ref } from "effect"

class Counter {
  readonly inc: Effect.Effect<void, never, never>
  readonly dec: Effect.Effect<void, never, never>
  readonly get: Effect.Effect<number, never, never>

  constructor(private value: Ref.Ref<number>) {
    this.inc = Ref.update(this.value, (n) => n + 1)
    this.dec = Ref.update(this.value, (n) => n - 1)
    this.get = Ref.get(this.value)
  }
}

const make = Effect.andThen(Ref.make(0), (value) => new Counter(value))

const program = Effect.gen(function* () {
  const counter = yield* make
  yield* counter.inc
  yield* counter.inc
  yield* counter.dec
  yield* counter.inc
  const value = yield* counter.get
  console.log(`This counter has a value of ${value}.`)
})

Effect.runPromise(program)
/* 
Output:
This counter has a value of 2.
*/
```

--------------------------------

### Track Error Occurrences with Frequency (TypeScript)

Source: https://effect.website/docs/observability/metrics

This TypeScript example shows how to create and use a Frequency metric to count the occurrences of different error codes. It defines a frequency metric, simulates random errors using an effect, and repeats this process to populate the frequency count. Finally, it retrieves and logs the state of the frequency metric.

```typescript
import { Metric, Random, Effect } from "effect"

// Define a frequency metric to track errors
const errorFrequency = Metric.frequency("error_frequency", {
  // Optional
  description: "Counts the occurrences of errors."
})

const task = Effect.gen(function* () {
  const n = yield* Random.nextIntBetween(1, 10)
  return `Error-${n}`
})

// Program that simulates random errors and tracks their occurrences
const program = Effect.gen(function* () {
  yield* errorFrequency(task).pipe(Effect.repeatN(99))

  // Retrieve and log the current state of the summary
  const state = yield* Metric.value(errorFrequency)
  console.log("%o", state)
})

Effect.runPromise(program)
```

--------------------------------

### Simplifying Error Handling with Generators and safeTry

Source: https://effect.website/docs/additional-resources/effect-vs-neverthrow

This example shows how generators can simplify complex error handling chains by abstracting away repetitive error checking. It uses the `safeTry` function from neverthrow.

```typescript
import { Result, ok, safeTry } from "neverthrow"

declare function mayFail1(): Result<any, any>
declare function mayFail2(): Result<any, any>

function myFunc(): Result {
  return safeTry(function* () {
    return ok(
      (yield* mayFail1().mapErr(

```

--------------------------------

### Define Request Resolvers for Batching (TypeScript)

Source: https://effect.website/docs/batching

Illustrates how to define `RequestResolver` instances for handling specific Effect-TS requests. This snippet shows the setup for `getUserById` and `getTodos` resolvers, which are fundamental for batching operations by processing multiple requests efficiently.

```typescript
import { Effect, Request, RequestResolver, Data } from "effect"

// ------------------------------
// Model
// ------------------------------

interface User {
  readonly _tag: "User"
  readonly id: number
  readonly name: string
  readonly email: string
}

class GetUserError extends Data.TaggedError("GetUserError")<{}> {}

interface Todo {
  readonly _tag: "Todo"
  readonly id: number
  readonly message: string
  readonly ownerId: number
}

// Placeholder for GetTodosError and SendEmailError, assumed to be defined elsewhere
class GetTodosError extends Data.TaggedError("GetTodosError")<{}> {}
class SendEmailError extends Data.TaggedError("SendEmailError")<{}> {}

// Mock data for demonstration
const mockUsers: Map<number, User> = new Map([
  [1, { _tag: "User", id: 1, name: "Alice", email: "alice@example.com" }]
]);

const mockTodos: Map<number, Array<Todo>> = new Map([
  [1, [
    { _tag: "Todo", id: 1, message: "Buy groceries", ownerId: 1 },
    { _tag: "Todo", id: 2, message: "Walk the dog", ownerId: 1 }
  ]]
]);

// ------------------------------
// Resolvers
// ------------------------------

// Resolver for fetching a single User by ID
const userResolver: RequestResolver.RequestResolver<User | GetUserError, { id: number }>
  = RequestResolver.makeBatched((requests: Array<{ id: number }>) =>
      Effect.succeed([
        ...requests.map(req => {
          const user = mockUsers.get(req.id);
          return user ? Effect.succeed(user) : Effect.fail(new GetUserError());
        })
      ])
    );

// Resolver for fetching multiple Todo items
const todosResolver: RequestResolver.RequestResolver<Array<Todo> | GetTodosError, { _tag: "GetTodos" }>
  = RequestResolver.makeBatched((requests: Array<{ _tag: "GetTodos" }>)=> 
      Effect.succeed([
        ...requests.map(() => {
          // In a real scenario, this would fetch todos based on some criteria
          // For simplicity, returning a fixed list
          const todos = Array.from(mockTodos.values()).flat();
          return Effect.succeed(todos);
        })
      ])
    );

// Placeholder for SendEmail resolver, assuming it's defined elsewhere
// const sendEmailResolver: RequestResolver.RequestResolver<void | SendEmailError, SendEmailRequestType> = ...

// Example of combining resolvers
const combinedResolver = RequestResolver.batch(userResolver, todosResolver);

```

--------------------------------

### Handle Failures During Repeats with Effect.repeatOrElse

Source: https://effect.website/docs/scheduling/repetition

Illustrates how to use Effect.repeatOrElse to repeat an effect based on a schedule and handle failures by executing a fallback handler. It imports Effect and Schedule from 'effect'. The example simulates an action that fails after a few successful attempts.

```typescript
import { Effect, Schedule } from "effect"

let count = 0

// Define an async effect that simulates an action with possible failures
const action = Effect.async((resume) => {
  if (count > 1) {
    console.log("failure")
    resume(Effect.fail("Uh oh!"))
  } else {
    count++
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

// Define a schedule that repeats up to 2 times
// with a 100ms delay between attempts
const policy = Schedule.addDelay(Schedule.recurs(2), () => "100 millis")

// Provide a handler to run when failure occurs after the retries
const program = Effect.repeatOrElse(action, policy, () =>
  Effect.sync(() => {
    console.log("orElse")
    return count - 1
  })
)

Effect.runPromise(program).then((n) => console.log(`repetitions: ${n}`))
```

--------------------------------

### Run Bun Program

Source: https://effect.website/docs/platform/introduction

Executes a JavaScript or TypeScript file directly using the Bun runtime. Bun is known for its speed and built-in tooling.

```bash
bun index.ts
```

--------------------------------

### Simulating User Retrieval with Effect.succeed and Effect.fail

Source: https://effect.website/docs/getting-started/creating-effects

Provides an example of modeling a user retrieval operation using Effect.succeed and Effect.fail. This function simulates fetching user data from a mocked database, returning either a User object on success or an Error if the user is not found.

```typescript
import { Effect } from "effect"

// Define a User type
interface User {
  readonly id: number
  readonly name: string
}

// A mocked function to simulate fetching a user from a database
const getUser = (userId: number): Effect.Effect => {
  // Normally, you would access a database or API here, but we'll mock it
  const userDatabase: Record<number, User> = {
    1: { id: 1, name: "John Doe" },
    2: { id: 2, name: "Jane Smith" }
  }

  // Check if the user exists in our "database" and return appropriately
  const user = userDatabase[userId]
  if (user) {
    return Effect.succeed(user)
  } else {
    return Effect.fail(new Error("User not found"))
  }
}

// When executed, this will successfully return the user with id 1
const exampleUserEffect = getUser(1)
```

--------------------------------

### Accessing File System Operations with Effect

Source: https://effect.website/docs/platform/file-system

Demonstrates how to access the FileSystem service within an Effect program. This pattern is used to obtain an instance of the FileSystem interface to perform subsequent file operations. It requires the 'effect' and '@effect/platform' libraries.

```typescript
import { FileSystem } from "@effect/platform"
import { Effect } from "effect"

const program = Effect.gen(function* () {
  const fs = yield* FileSystem.FileSystem

  // Use `fs` to perform file system operations
})
```

--------------------------------

### Handling Success and Timeout with Effect.timeoutTo (Either)

Source: https://effect.website/docs/error-management/timing-out

Effect.timeoutTo provides flexibility to define different outcomes for successful and timed-out operations. This example uses Either to return the result on success or an error message on timeout.

```typescript
import { Effect, Either } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const program = task.pipe(
  Effect.timeoutTo({
    duration: "1 second",
    onSuccess: (result): Either.Either => 
      Either.right(result),
    onTimeout: (): Either.Either => 
      Either.left("Timed out!")
  })
)

Effect.runPromise(program).then(console.log)
```

--------------------------------

### Concurrent Updates to a Shared Counter with Effect.js Ref

Source: https://effect.website/docs/state-management/ref

This example demonstrates how to manage concurrent updates to a shared counter using Effect.js. It utilizes `Effect.zip` with the `concurrent: true` option to run multiple operations on the counter simultaneously, showcasing how Ref handles state in concurrent scenarios. The output shows the interleaved execution and the final state of the counter.

```typescript
import { Effect, Ref } from "effect"

class Counter {
  readonly inc: Effect.Effect<void, never, never>
  readonly dec: Effect.Effect<void, never, never>
  readonly get: Effect.Effect<number, never, never>

  constructor(private value: Ref.Ref<number>) {
    this.inc = Ref.update(this.value, (n) => n + 1)
    this.dec = Ref.update(this.value, (n) => n - 1)
    this.get = Ref.get(this.value)
  }
}

const make = Effect.andThen(Ref.make(0), (value) => new Counter(value))

const program = Effect.gen(function* () {
  const counter = yield* make

  // Helper to log the counter's value before running an effect
  const logCounter = (
    label: string,
    effect: Effect.Effect<any, any, any>
  ) =>
    Effect.gen(function* () {
      const value = yield* counter.get
      yield* Effect.log(`${label} get: ${value}`)
      return yield* effect
    })

  yield* logCounter("task 1", counter.inc).pipe(
    Effect.zip(logCounter("task 2", counter.inc), { concurrent: true }),
    Effect.zip(logCounter("task 3", counter.dec), { concurrent: true }),
    Effect.zip(logCounter("task 4", counter.inc), { concurrent: true })
  )
  const value = yield* counter.get
  yield* Effect.log(`This counter has a value of ${value}.`)
})

Effect.runPromise(program)
/* 
Output:
timestamp=... fiber=#3 message="task 4 get: 0"
timestamp=... fiber=#6 message="task 3 get: 1"
timestamp=... fiber=#8 message="task 1 get: 0"
timestamp=... fiber=#9 message="task 2 get: 1"
timestamp=... fiber=#0 message="This counter has a value of 2."
*/
```

--------------------------------

### Forking Effects

Source: https://effect.website/docs/micro/new-users

Demonstrates how to create a new fiber by forking an existing effect using `Micro.fork`.

```APIDOC
## Forking Effects

### Description
One of the fundamental ways to create a fiber is by forking an existing effect. When you fork an effect, it starts executing the effect on a new fiber, giving you a reference to this newly-created fiber.

### Method
`Micro.fork(effect)`

### Parameters
#### Path Parameters
None

#### Query Parameters
None

#### Request Body
None

### Request Example
```typescript
import { Micro } from "effect"

const fib = (n: number): Micro.Micro<number, never, never> =>
  n < 2
    ? Micro.succeed(n)
    : Micro.zipWith(fib(n - 1), fib(n - 2), (a, b) => a + b)

// ┌─── Micro, never, never>
// ▼
const fib10Fiber = Micro.fork(fib(10))
```

### Response
#### Success Response (200)
- **Fiber<any, any>** - A reference to the newly created fiber.

#### Response Example
(No specific JSON response for this operation as it returns a Fiber object)
```

--------------------------------

### Get Current UTC Time with Effect Clock

Source: https://effect.website/docs/data-types/datetime

Retrieves the current UTC time as an Effect using the Clock service. This ensures consistent time across the application, especially useful for testing. Requires 'effect' library.

```typescript
import { DateTime, Effect } from "effect"

const program = Effect.gen(function* () {
  const currentTime = yield* DateTime.now
})
```

--------------------------------

### Configure Anthropic Client with NodeHttpClient (TypeScript)

Source: https://effect.website/docs/ai/planning-llm-interactions

Configures the Anthropic client by providing an API key from a redacted environment variable and specifying the Node.js HTTP client (Undici). This setup is essential for making requests to the Anthropic API.

```typescript
const Anthropic = AnthropicClient.layerConfig({
  apiKey: Config.redacted("ANTHROPIC_API_KEY")
}).pipe(Layer.provide(NodeHttpClient.layerUndici))
```

--------------------------------

### Create SubscriptionRef - Effect

Source: https://effect.website/docs/state-management/subscriptionref

Demonstrates how to create a new SubscriptionRef with an initial value using the SubscriptionRef.make constructor. This is the fundamental step to begin observing state changes.

```typescript
import { SubscriptionRef } from "effect"

const ref = SubscriptionRef.make(0)
```

--------------------------------

### Inspect Micro Effect Exit Status with Micro.runPromiseExit

Source: https://effect.website/docs/micro/new-users

This example demonstrates how to use Micro.runPromiseExit to execute a Micro effect and retrieve its detailed exit status. Unlike Micro.runPromise, this function returns a Promise that resolves with a structured exit object, which can be a 'Success' containing the value or a 'Fail' containing the error. This provides more granular control over error inspection.

```typescript
import { Micro } from "effect"

// Simulate fetching weather data
function fetchWeather(city: string): Promise {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (city === "London") {
        resolve("Sunny")
      } else {
        reject(new Error("Weather data not found for this location"))
      }
    }, 1_000)
  })
}

function getWeather(city: string) {
  return Micro.promise(() => fetchWeather(city))
}

const weatherEffect = getWeather("London")

Micro.runPromiseExit(weatherEffect).then(
  (exit) => console.log(exit)
)
```

--------------------------------

### Supervise and Track Fibers with Supervisor

Source: https://effect.website/docs/observability/supervisor

This example demonstrates how to use `Supervisor.track` to create a supervisor that tracks child fibers. The `Effect.supervised` function then applies this supervisor to an effect, ensuring that all fibers forked within it are managed by the supervisor. This allows for monitoring of fiber status and count.

```typescript
import { Effect, Supervisor, Schedule, Fiber, FiberStatus } from "effect"

// Main program that monitors fibers while calculating a Fibonacci number
const program = Effect.gen(function* () {
  // Create a supervisor to track child fibers
  const supervisor = yield* Supervisor.track

  // Start a Fibonacci calculation, supervised by the supervisor
  const fibFiber = yield* fib(20).pipe(
    Effect.supervised(supervisor),
    // Fork the Fibonacci effect into a fiber
    Effect.fork
  )

  // Define a schedule to periodically monitor the fiber count every 500ms
  const policy = Schedule.spaced("500 millis").pipe(
    Schedule.whileInputEffect((_) =>
      Fiber.status(fibFiber).pipe(
        // Continue while the Fibonacci fiber is not done
        Effect.andThen((status) => status !== FiberStatus.done)
      )
    )
  )

  // Start monitoring the fibers, using the supervisor to track the count
  const monitorFiber = yield* monitorFibers(supervisor).pipe(
    // Repeat the monitoring according to the schedule
    Effect.repeat(policy)
    // Fork the monitoring effect into a fiber
    // Effect.fork
  )
})

// Placeholder for fib function (implementation not provided in the original text)
const fib = (n: number): Effect<number, never, never> => {
  return Effect.succeed(0);
}

// Placeholder for monitorFibers function (implementation not provided in the original text)
const monitorFibers = (supervisor: Supervisor<unknown>): Effect<void, never, never> => {
  return Effect.gen(function* () {
    const fiberCount = yield* supervisor.count
    console.log(`Current fiber count: ${fiberCount}`)
  })
}
```

--------------------------------

### Use a Counter Metric in Effect-TS

Source: https://effect.website/docs/observability/metrics

Shows how to apply a counter metric to an Effect. The counter can be incremented or decremented by providing a numerical value. The current state of the counter can be retrieved using `Metric.value`. This example demonstrates incrementing by 1, 2, and decrementing by 4.

```typescript
import { Metric, Effect } from "effect"

const requestCount = Metric.counter("request_count")

const program = Effect.gen(function* () {
  // Increment the counter by 1
  const a = yield* requestCount(Effect.succeed(1))
  // Increment the counter by 2
  const b = yield* requestCount(Effect.succeed(2))
  // Decrement the counter by 4
  const c = yield* requestCount(Effect.succeed(-4))

  // Get the current state of the counter
  const state = yield* Metric.value(requestCount)
  console.log(state)

  return a * b * c
})

Effect.runPromise(program).then(console.log)
/*
Output:
CounterState {
  count: -1,
  ...
}
-8
*/
```

--------------------------------

### Run Effect-TS RaceAll with Either Error Handling

Source: https://effect.website/docs/additional-resources/effect-vs-promise

Demonstrates how to use `Effect.raceAll` to run multiple effects concurrently and handle their outcomes using `Effect.either`. This is useful for scenarios where you want to get the result of the first effect to complete, while also capturing any errors from other effects.

```typescript
import { Effect } from "effect"

const task1 = Effect.gen(function* () {
  console.log("Executing task1...")
  yield* Effect.sleep("100 millis")
  console.log("task1 done")
  return yield* Effect.fail("Something went wrong!")
})

const task2 = Effect.gen(function* () {
  console.log("Executing task2...")
  yield* Effect.sleep("200 millis")
  console.log("task2 done")
  return yield* Effect.fail("Uh oh!")
})

const task3 = Effect.gen(function* () {
  console.log("Executing task3...")
  yield* Effect.sleep("300 millis")
  console.log("task3 done")
  return 3
})

const program = Effect.raceAll([task1, task2, task3].map(Effect.either)) // or Effect.exit

Effect.runPromise(program).then(console.log, console.error)
```

--------------------------------

### Direct Method Access with Effect.Service

Source: https://effect.website/docs/requirements-management/layers

Demonstrates how to define a service using Effect.Service and access its methods directly without explicit service extraction. This method simplifies code by enabling direct calls like `Sync.next`. It requires a default implementation provided via `Effect.provide`.

```typescript
import { Effect, Random } from "effect"

class Sync extends Effect.Service("Sync", {
  sync: () => ({
    next: Random.nextInt
  }),
  accessors: true // Enables direct method access via the tag
}) {}

const program = Effect.gen(function* () {
  // const sync = yield* Sync
  // const n = yield* sync.next
  const n = yield* Sync.next // No need to extract the service first
  console.log(`The number is ${n}`)
})

Effect.runPromise(program.pipe(Effect.provide(Sync.Default)))
// Example Output: The number is 3858843290019673
```

--------------------------------

### Handling Successful Exit with Effect-TS

Source: https://effect.website/docs/data-types/exit

Demonstrates how to run an Effect that succeeds and process its Exit value. It uses `Effect.runSyncExit` to get an Exit object and `Exit.match` to handle the success case, extracting the successful value.

```typescript
import * as Effect from "@effect/io/Effect";
import * as Exit from "@effect/io/Exit";
import * as Cause from "@effect/io/Cause";

const simulatedSuccess = Effect.runSyncExit(Effect.succeed(1));

console.log(
  Exit.match(simulatedSuccess, {
    onFailure: (cause) => `Exited with failure state: ${Cause.pretty(cause)}`,
    onSuccess: (value) => `Exited with success value: ${value}`
  })
);
```

--------------------------------

### Get PubSub Capacity and Size

Source: https://effect.website/docs/concurrency/pubsub

Retrieves the fixed capacity of a PubSub using PubSub.capacity and its current dynamic size using PubSub.size. PubSub.capacity returns a number, while PubSub.size returns an Effect, reflecting that the size can change over time.

```typescript
import { Effect, PubSub } from "effect"

const program = Effect.gen(function* () {
  const pubsub = yield* PubSub.bounded(2)
  console.log(`capacity: ${PubSub.capacity(pubsub)}`)
  console.log(`size: ${yield* PubSub.size(pubsub)}`)
})

Effect.runFork(program)
/* 
Output:
capacity: 2
size: 0
*/
```

--------------------------------

### Using a Service within an Effect with EffectJS

Source: https://effect.website/docs/requirements-management/services

Demonstrates how to use a previously declared service (Random Number Generator) within an EffectJS program. This example utilizes Effect.gen and pipe for composing effects and accessing service methods.

```typescript
import { Effect, Context } from "effect"

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag("MyRandomService")< 
Random, 
{
  readonly next: Effect.Effect<number>
}
>() {}

// Example of using the Random service
const randomNumberEffect = Effect.gen(function* (_) {
  const random = yield* Random
  const number = yield* random.next
  return number
})

// Alternatively using pipe
const randomNumberEffectWithPipe = pipe(
  Random,
  Context.flatMap(random => random.next)
)
```

--------------------------------

### Create and Apply Custom Cache Globally

Source: https://effect.website/docs/batching

This snippet demonstrates how to create a custom request cache with a specified capacity and time-to-live, and then apply it globally to a program using `Effect.provide` and `Layer.setRequestCache`. The program fetches todos and processes them, repeating every 10 seconds.

```typescript
const program = Effect.gen(function* () {
  const todos = yield* getTodos;
  yield* Effect.forEach(todos, (todo) => notifyOwner(todo), {
    concurrency: "unbounded"
  });
}).pipe(
  Effect.repeat(Schedule.fixed("10 seconds")),
  Effect.provide(
    Layer.setRequestCache(
      Request.makeCache({
        capacity: 256,
        timeToLive: "60 minutes"
      })
    )
  )
);
```

--------------------------------

### Wrap Promise with Micro Effect

Source: https://effect.website/docs/micro/new-users

Shows how to wrap a Promise-based function (`fetchWeather`) using the Micro library from Effect. This converts the Promise into a Micro effect, enabling structured handling of success and failure.

```typescript
import { Micro } from "effect"

// Simulate fetching weather data
function fetchWeather(city: string): Promise<string> {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      // ... (rest of the function implementation)
    }, 1000)
  })
}

// Wrap the Promise with Micro
const getWeatherEffect = Micro.fromPromise(fetchWeather("London"))

```

--------------------------------

### Manage Scope and Add Finalizers in Effect-TS

Source: https://effect.website/docs/micro/new-users

Explains and demonstrates the use of `MicroScope` in Effect-TS for resource management. `MicroScope` allows you to add finalizers, which are cleanup functions guaranteed to execute when the scope is closed. This example shows how to create a scope, add two finalizers that log messages, and then close the scope.

```typescript
import { Micro } from "effect"

// Helper function to log a message
const log = (message: string) => Micro.sync(() => console.log(message))

const program = 
  // create a new scope
  Micro.scopeMake.pipe(
    // add finalizer
    Micro.tap((scope) => scope.addFinalizer(() => log("finalizer 1"))),
    // add finalizer
    Micro.tap((scope) => scope.addFinalizer(() => log("finalizer 2"))),
    // close the scope
    Micro.andThen((scope) => 
      // You can perform operations within the scope here if needed
      // For this example, we just close it implicitly by ending the pipeline
      scope
    )
  )

// To actually run and see the finalizers execute, you would typically 
// integrate this into a larger Effect program or use Micro.runPromise.
// For demonstration purposes, let's simulate closing:
// Micro.runPromise(program.pipe(Micro.provideService(Micro.rootScope, ???)))
// However, the core concept is adding finalizers to the scope.

/* 
Example Output when scope is closed:
finalizer 1
finalizer 2
*/
```

--------------------------------

### Get Command Exit Code with Effect Platform

Source: https://effect.website/docs/platform/command

Demonstrates how to execute a command and retrieve only its exit code using `Command.exitCode`. This is useful when you only need to know if a command succeeded or failed without processing its output.

```typescript
import { Command } from "@effect/platform"
import { NodeContext, NodeRuntime } from "@effect/platform-node"
import { Effect } from "effect"

const command = Command.make("ls", "-al")

const program = Effect.gen(function* () {
  const exitCode = yield* Command.exitCode(command)
  console.log(exitCode)
})

NodeRuntime.runMain(program.pipe(Effect.provide(NodeContext.layer)))
```

--------------------------------

### Providing a Mock Service Implementation with Effect.Service

Source: https://effect.website/docs/requirements-management/layers

Illustrates how to provide a custom mock implementation for a service defined with Effect.Service. This is useful for testing or scenarios where a default implementation is not suitable. The mock object must conform to the service's interface.

```typescript
const mock = new MyService({
  /* mocked methods */
})
program.pipe(Effect.provideService(MyService, mock))
```

--------------------------------

### Register Cleanup Action on Fiber Interruption

Source: https://effect.website/docs/concurrency/basic-concurrency

Demonstrates the use of `Effect.onInterrupt` to register a cleanup effect that runs when a fiber is interrupted. This example shows how a cleanup action is executed for an interrupted effect, but not for successful or failing effects.

```typescript
import { Console, Effect } from "effect"

// This handler is executed when the fiber is interrupted
const handler = Effect.onInterrupt((\_fibers) =>
 Console.log("Cleanup completed")
)

const success = Console.log("Task completed").pipe(
 Effect.as("some result"),
 handler
)

Effect.runFork(success)
/* 
Output:
Task completed
*/

const failure = Console.log("Task failed").pipe(
 Effect.andThen(Effect.fail("some error")),
 handler
)

Effect.runFork(failure)
/* 
Output:
Task failed
*/

const interruption = Console.log("Task interrupted").pipe(
 Effect.andThen(Effect.interrupt),
 handler
)

Effect.runFork(interruption)
/* 
Output:
Task interrupted
Cleanup completed
*/
```

--------------------------------

### Promise.any() vs. Effect.raceAll()

Source: https://effect.website/docs/additional-resources/effect-vs-promise

This snippet demonstrates how to handle an array of asynchronous tasks and return the result of the first one that fulfills. It compares the native Promise.any with the Effect library's Effect.raceAll, which achieves a similar outcome by returning the result of the first task to succeed.

```javascript
const task1 = new Promise((resolve, reject) => {
  console.log("Executing task1...")
  setTimeout(() => {
    console.log("task1 done")
    reject("Something went wrong!")
  }, 100)
})

const task2 = new Promise((resolve, reject) => {
  console.log("Executing task2...")
  setTimeout(() => {
    console.log("task2 done")
    resolve(2)
  }, 200)
})

const task3 = new Promise((resolve, reject) => {
  console.log("Executing task3...")
  setTimeout(() => {
    console.log("task3 done")
    reject("Uh oh!")
  }, 300)
})

const program = Promise.any([task1, task2, task3])

program.then(console.log, console.error)
/* 
Output:
Executing task1...
Executing task2...
Executing task3...
task1 done
task2 done
2
task3 done
*/
```

```typescript
import { Effect } from "effect"

const task1 = Effect.gen(function* () {
  console.log("Executing task1...")
  yield* Effect.sleep("100 millis")
  console.log("task1 done")
  return yield* Effect.fail("Something went wrong!")
})

const task2 = Effect.gen(function* () {
  console.log("Executing task2...")
  yield* Effect.sleep("200 millis")
  console.log("task2 done")
  return 2
})

const task3 = Effect.gen(function* () {
  console.log("Executing task3...")
  yield* Effect.sleep("300 millis")
  console.log("task3 done")
  return yield* Effect.fail("Uh oh!")
})

const program = Effect.raceAll([task1, task2, task3])

Effect.runPromise(program).then(console.log, console.error)
/* 
Output:
Executing task1...
Executing task2...
Executing task3...
task1 done
task2 done
2
*/
```

--------------------------------

### No Memoization with Local Layer Provision (Effect-TS)

Source: https://effect.website/docs/requirements-management/layer-memoization

Illustrates that when layers are provided locally using `Effect.provide`, they do not support memoization by default. The example shows `ALive` being initialized twice because it's provided locally twice within the same program scope. This results in the log message appearing two times.

```typescript
import { Effect, Context, Layer } from "effect"

class A extends Context.Tag("A")() {}

const Alive = Layer.effect(
  A,
  Effect.succeed({ a: 5 }).pipe(
    Effect.tap(() => Effect.log("initialized"))
  )
)

const program = Effect.gen(function* () {
  yield* Effect.provide(A, Alive)
  yield* Effect.provide(A, Alive)
})

Effect.runPromise(program)
```

--------------------------------

### Custom Defect on Timeout with Effect.timeoutFailCause

Source: https://effect.website/docs/error-management/timing-out

Effect.timeoutFailCause lets you define a specific defect to throw when a timeout occurs. This is useful for treating timeouts as exceptional cases. The example shows throwing a custom string defect.

```typescript
import { Effect, Cause } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

const program = task.pipe(
  Effect.timeoutFailCause({
    duration: "1 second",
    onTimeout: () => Cause.die("Timed out!") // Custom defect for timeout
  })
)

Effect.runPromiseExit(program).then(console.log)
```

--------------------------------

### Run a Failing Program without Pretty Logger (Node.js)

Source: https://effect.website/docs/platform/runtime

This example demonstrates disabling the default pretty logger when running a failing Effect with `runMain`. The error will still be logged, but in a more basic format, useful for environments where detailed formatting is not desired.

```typescript
import { NodeRuntime } from "@effect/platform-node"
import { Effect } from "effect"

const failure = Effect.fail("Uh oh!")

NodeRuntime.runMain(failure, {
  disablePrettyLogger: true
})
```

--------------------------------

### Get Duration Value in Nanoseconds (TypeScript)

Source: https://effect.website/docs/data-types/duration

Retrieves the value of a duration in nanoseconds using `Duration.toNanos`. This function returns an `Option` because durations can be infinite. Use this for high-precision time measurements.

```typescript
import { Duration } from "effect"

console.log(Duration.toNanos(Duration.millis(100)))
/*
Output:
{
  _id: 'Option',
  _tag: 'Some',
  value: 100000000n
}
*/
```

--------------------------------

### Handle Errors by Tag with Effect.catchTag

Source: https://effect.website/docs/error-management/expected-errors

Effect.catchTag provides a way to handle errors based on their `_tag` field. This is useful for discriminated union error types. This example shows how to catch a specific HttpError.

```typescript
import { Effect, Random, Data } from "effect"

class HttpError extends Data.TaggedError("HttpError")<{}>

class ValidationError extends Data.TaggedError("ValidationError")<{}>

const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    return yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    return yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

const recovered = program.pipe(
  // Only handle HttpError errors
  Effect.catchTag("HttpError", (_HttpError) => 
    Effect.succeed("Recovering from HttpError")
  )
)

// const recovered: Effect<string, ValidationError, never>

```

--------------------------------

### Log Schedule Intervals with Effect.js

Source: https://effect.website/docs/scheduling/cron

This example demonstrates how to create a cron-like schedule using Effect.js and log the intervals at which it triggers. It utilizes `Cron.unsafeParse` to define the schedule and `Schedule.cron` to convert it into a usable schedule. The `log` function, which takes an action and a schedule, is used to output the schedule's execution times.

```typescript
const log = <R, E, A, B>(action: Effect<R, E, A>, schedule: Schedule<R, unknown, B>) => Effect.tapError(Effect.zip(action, schedule).pipe(Effect.fork, Effect.tap(() => Effect.sleep(1000))), () => Effect.unit);

// Build a cron that triggers at 4:00 AM
// on the 8th to the 14th of each month
const cron = Cron.unsafeParse("0 0 4 8-14 * *", "UTC")

// Convert the Cron into a Schedule
const schedule = Schedule.cron(cron)

// Define a dummy action to repeat
const action = Effect.void

// Log the schedule intervals
log(action, schedule)
```

--------------------------------

### Collecting All Errors with combineWithAllErrors in neverthrow and Effect

Source: https://effect.website/docs/additional-resources/effect-vs-neverthrow

This example shows how to collect all errors from a list of asynchronous operations, instead of failing on the first error. It uses `ResultAsync.combineWithAllErrors` in neverthrow and `Effect.validateAll` with `Effect.either` in Effect.

```typescript
import { ResultAsync, okAsync, errAsync } from "neverthrow"

const resultList: ResultAsync<number, string>[] = [
  okAsync(123),
  errAsync("boooom!"),
  okAsync(456),
  errAsync("ahhhhh!")
]

const result = await ResultAsync.combineWithAllErrors(resultList)
// result is Err(['boooom!', 'ahhhhh!'])
```

```typescript
import { Effect, identity } from "effect"

const resultList: Effect.Effect<number, string>[] = [
  Effect.succeed(123),
  Effect.fail("boooom!"),
  Effect.succeed(456),
  Effect.fail("ahhhhh!")
]

const result = await Effect.runPromise(
  Effect.either(Effect.validateAll(resultList, identity))
)
// result is left(['boooom!', 'ahhhhh!'])
```

--------------------------------

### Combine Multiple Orders for Complex Sorting in Effect-TS

Source: https://effect.website/docs/behaviour/order

Demonstrates how to sort an array of `Person` objects by multiple criteria using `Order.combine`. This example sorts first by `name` and then by `age` for individuals with the same name.

```typescript
import { Order, Array } from "effect"

// Define the Person interface
interface Person {
  readonly name: string
  readonly age: number
}

// Create an Order to sort people by their names in ascending order
const byName = Order.mapInput(
  Order.string,
  (person: Person) => person.name
)

// Create an Order to sort people by their ages in ascending order
const byAge = Order.mapInput(Order.number, (person: Person) => person.age)

// Combine orders to sort by name, then by age
const byNameAge = Order.combine(byName, byAge)

const result = Array.sort(
  [
    { name: "Bob", age: 20 },
    { name: "Alice", age: 18 },
    { name: "Bob", age: 18 }
  ],
  byNameAge
)

console.log(result)
/* 
Output:
[
  { name: 'Alice', age: 18 }, // Sorted by name
  { name: 'Bob', age: 18 }, // Sorted by age within the same name
  { name: 'Bob', age: 20 }
]
*/
```

--------------------------------

### Create an Empty Chunk using Chunk.empty

Source: https://effect.website/docs/data-types/chunk

Demonstrates how to create an empty Chunk using the `Chunk.empty` static method. This is useful for initializing a Chunk when no elements are present initially.

```typescript
import { Chunk } from "effect"

// ┌─── Chunk
// ▼
const chunk = Chunk.empty()
```

--------------------------------

### Derive Custom Order for Objects with Effect-TS

Source: https://effect.website/docs/behaviour/order

Shows how to create a custom sorting order for an array of objects using `Order.mapInput`. This example defines an order to sort `Person` objects by their `name` property.

```typescript
import { Order } from "effect"

// Define the Person interface
interface Person {
  readonly name: string
  readonly age: number
}

// Create a custom order to sort Person objects by name in ascending order
const byName = Order.mapInput(
  Order.string,
  (person: Person) => person.name
)
```

--------------------------------

### Union Schedule Combinator Example - Effect.js

Source: https://effect.website/docs/scheduling/schedule-combinators

Demonstrates the 'Union' schedule combinator, which combines two schedules. The resulting schedule recurs if either of the combined schedules wants to continue, and it uses the shorter delay between the two.

```typescript
import { Array, Chunk, Duration, Effect, Schedule } from "effect"

// Assuming the log helper function is defined as above

const exponential = Schedule.exponential("100ms").pipe(
  Schedule.addDelay(() => "50ms") // Adds a base delay
);

const spaced = Schedule.spaced("200ms").pipe(
  Schedule.addDelay(() => "20ms") // Adds a base delay
);

const unionSchedule = Schedule.union(exponential, spaced);

console.log("--- Union Schedule ---");
log(unionSchedule);

```

--------------------------------

### Define Service with Static Implementation (Effect.js)

Source: https://effect.website/docs/requirements-management/layers

Illustrates defining a service using a static implementation with `Effect.Service`. This method is suitable for providing a constant value as a service.

```typescript
import { Effect } from "effect"

class MagicNumber extends Effect.Service()("MagicNumber", {
  succeed: { value: 42 }
}) {}

// Accessing the Service
const program = Effect.gen(function* () {
  const magicNumber = yield* MagicNumber
  console.log(`The magic number is ${magicNumber.value}`)
})

Effect.runPromise(program.pipe(Effect.provide(MagicNumber.Default)))
// The magic number is 42
```

--------------------------------

### Group Stream Elements by Key using Stream.groupByKey

Source: https://effect.website/docs/stream/operations

This example illustrates how to group elements of a stream by a key derived from each element using Stream.groupByKey. The function is non-effectful and uses a provided key function. The result is a GroupBy data type that can be evaluated. The input is a stream of Exam objects, and the output groups them by the tens place of their scores and counts the number of exams in each group.

```typescript
import { Stream, GroupBy, Effect, Chunk } from "effect"

class Exam {
  constructor(
    readonly person: string,
    readonly score: number
  ) {}
}

// Define a list of exam results
const examResults = [
  new Exam("Alex", 64),
  new Exam("Michael", 97),
  new Exam("Bill", 77),
  new Exam("John", 78),
  new Exam("Bobby", 71)
]

// Group exam results by the tens place in the score
const groupByKeyResult = Stream.fromIterable(examResults).pipe(
  Stream.groupByKey((exam) => Math.floor(exam.score / 10) * 10)
)

// Count the number of exam results in each group
const stream = GroupBy.evaluate(groupByKeyResult, (key, stream) =>
  Stream.fromEffect(
    Stream.runCollect(stream).pipe(
      Effect.andThen((chunk) => [key, Chunk.size(chunk)] as const)
    )
  )
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)

/* 
Output:
{
  _id: 'Chunk', values: [ [ 60, 1 ], [ 90, 1 ], [ 70, 3 ] ]
}
*/
```

--------------------------------

### Promise.race() vs. Effect.race()

Source: https://effect.website/docs/additional-resources/effect-vs-promise

This snippet demonstrates the behavior of Promise.race and its Effect library equivalent, Effect.race. Both methods return the result of the first promise/effect to settle, whether it fulfills or rejects. This is useful for scenarios where you want to get a result as quickly as possible and don't need to wait for all operations.

```javascript
const task1 = new Promise((resolve, reject) => {
  console.log("Executing task1...")
  setTimeout(() => {
    console.log("task1 done")
    reject("Something went wrong!")
  }, 100)
})

const task2 = new Promise((resolve, reject) => {
  console.log("Executing task2...")
  setTimeout(() => {
    console.log("task2 done")
    reject("Uh oh!")
  }, 200)
})

const task3 = new Promise((resolve, reject) => {
  console.log("Executing task3...")
  setTimeout(() => {
    console.log("task3 done")
    resolve(3)
  }, 300)
})

const program = Promise.race([task1, task2, task3])

program.then(console.log, console.error)
/* 
Output:
Executing task1...
Executing task2...
Executing task3...
task1 done
Something went wrong!
*/
```

```typescript
import { Effect } from "effect"

const task1 = Effect.gen(function* () {
  console.log("Executing task1...")
  yield* Effect.sleep("100 millis")
  console.log("task1 done")
  return yield* Effect.fail("Something went wrong!")
})

const task2 = Effect.gen(function* () {
  console.log("Executing task2...")
  yield* Effect.sleep("200 millis")
  console.log("task2 done")
  return yield* Effect.fail("Uh oh!")
})

const task3 = Effect.gen(function* () {
  console.log("Executing task3...")
  yield* Effect.sleep("300 millis")
  console.log("task3 done")
  return 3
})

const program = Effect.race([task1, task2, task3])

Effect.runPromise(program).then(console.log, console.error)
/* 
Output:
Executing task1...
Executing task2...
Executing task3...
task1 done
Something went wrong!
*/
```

--------------------------------

### Memoization When Providing Globally - Effect

Source: https://effect.website/docs/requirements-management/layer-memoization

Demonstrates how Effect layers are shared by default when provided globally. The example shows that even if a layer (ALive) is depended upon by multiple other layers (BLive, CLive), it is only initialized once, as evidenced by the single 'initialized' log message.

```typescript
import { Effect, Context, Layer } from "effect"

class A extends Context.Tag("A")() {}

class B extends Context.Tag("B")() {}

class C extends Context.Tag("C")() {}

const ALive = Layer.effect(
  A,
  Effect.succeed({ a: 5 }).pipe(
    Effect.tap(() => Effect.log("initialized"))
  )
)

const BLive = Layer.effect(
  B,
  Effect.gen(function* () {
    const { a } = yield* A
    return { b: String(a) }
  })
)

const CLive = Layer.effect(
  C,
  Effect.gen(function* () {
    const { a } = yield* A
    return { c: a > 0 }
  })
)

const program = Effect.gen(function* () {
  yield* B
  yield* C
})

const runnable = Effect.provide(
  program,
  Layer.merge(Layer.provide(BLive, ALive), Layer.provide(CLive, ALive))
)

Effect.runPromise(runnable)
/* 
Output:
timestamp=... level=INFO fiber=#2 message=initialized
*/
```

--------------------------------

### Platform: File System Operations

Source: https://context7_llms

Explore Effect's FileSystem module for performing various file operations such as reading, writing, and managing files and directories in a type-safe manner.

```typescript
import * as FileSystem from "@effect/platform/FileSystem"
import * as Effect from "@effect/io/Effect"

const readFileEffect = FileSystem.readFile("./myfile.txt")

Effect.runSync(readFileEffect)
// Reads the content of './myfile.txt'.
```

--------------------------------

### Fiber Interruption with Micro.interrupt (TypeScript)

Source: https://effect.website/docs/micro/new-users

This example illustrates interrupting a fiber using `Micro.interrupt` within the fiber's own execution context. The `Micro.interrupt` effect causes the fiber to terminate with an interruption cause, preventing subsequent operations within that fiber from executing.

```typescript
import { Micro } from "effect"

const program = Micro.gen(function* () {
  console.log("start")
  yield* Micro.sleep(2000)
  yield* Micro.interrupt
  console.log("done")
})

Micro.runPromiseExit(program).then(console.log)
/*
Output:
start
{
  "_id": "MicroExit",
  "_tag": "Failure",
  "cause": {
    "_tag": "Interrupt",
    "traces": [],
    "name": "MicroCause.Interrupt"
  }
}
*/
```

--------------------------------

### Effect Schema: Pick Properties from Union

Source: https://effect.website/docs/schema/basic-usage

This example shows how to apply the `pick` function more broadly to a union of schemas in Effect. It creates a new schema by selecting specific properties ('a' and 'b') that are common across the schemas within the union.

```typescript
import { Schema } from "effect"

const MyUnion = Schema.Union(
  Schema.Struct({
    a: Schema.String,
    b: Schema.String,
    c: Schema.String
  }),
  Schema.Struct({
    a: Schema.Number,
    b: Schema.Number,
    d: Schema.Number
  })
)

const PickedSchema = MyUnion.pipe(Schema.pick("a", "b"))
```

--------------------------------

### Handling Operation Exceeding Timeout Duration (TypeScript)

Source: https://effect.website/docs/error-management/timing-out

This example shows what happens when an Effect operation exceeds the specified timeout duration. A TimeoutException is raised, indicating that the operation did not complete within the allocated time.

```typescript
import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

// Output will show a TimeoutException as the task takes longer
// than the specified timeout duration
const timedEffect = task.pipe(Effect.timeout("1 second"))

Effect.runPromiseExit(timedEffect).then(console.log)
/*
Output:
Start processing...
{ _id: 'Exit', _tag: 'Failure', cause: { _id: 'Cause', _tag: 'Fail', error: { _id: 'TaggedError', _tag: 'TimeoutException' } } }
*/
```

--------------------------------

### Custom Logger with Effect.js

Source: https://effect.website/docs/runtime

Demonstrates replacing the default logger with a custom implementation using Logger.replace and applying it temporarily using Effect.provide. This allows for specific logging configurations within certain parts of an Effect program.

```typescript
import { Effect, Logger } from "effect"

// Custom logger implementation
const addSimpleLogger = Logger.make(({ message }) => console.log(message))

const removeDefaultLogger = Logger.remove(Logger.defaultLogger)

const program = Effect.gen(function* () {
  // Logs with default logger
  yield* Effect.log("Application started!")

  yield* Effect.gen(function* () {
    // This log is suppressed
    yield* Effect.log("I'm not going to be logged!")

    // Custom logger applied here
    yield* Effect.log("I will be logged by the simple logger.").pipe(
      Effect.provide(addSimpleLogger)
    )

    // This log is suppressed
    yield* Effect.log("Reset back to the previous configuration, so I won't be logged.")
  }).pipe(
    // Remove the default logger temporarily
    Effect.provide(removeDefaultLogger)
  )

  // Logs with default logger again
  yield* Effect.log("Application is about to exit!")
})

Effect.runSync(program)
```

--------------------------------

### Handling Null as Missing Value with Optional Field

Source: https://effect.website/docs/schema/advanced-usage

This example demonstrates how Schema.optionalWith treats null as a missing value during decoding and encoding. It uses Schema.NumberFromString for the field's type.

```typescript
import { Schema } from "effect"

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    nullable: true
  })
})

// Decoding examples
console.log(Schema.decodeUnknownSync(Product)({ quantity: "1" }))
// Output: { quantity: 1 }
console.log(Schema.decodeUnknownSync(Product)({}))
// Output: {}
console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
// Output: { quantity: undefined }
console.log(Schema.decodeUnknownSync(Product)({ quantity: null }))
// Output: {}

// Encoding examples
console.log(Schema.encodeSync(Product)({ quantity: 1 }))
// Output: { quantity: "1" }
console.log(Schema.encodeSync(Product)({}))
// Output: {}
console.log(Schema.encodeSync(Product)({ quantity: undefined }))
// Output: { quantity: undefined }
```

--------------------------------

### Effect Tracing in Distributed Systems

Source: https://context7_llms

Introduction to tracing in Effect for distributed systems. It uses spans and traces to track request lifecycles across multiple services for debugging and performance analysis.

```markdown
Effect's tracing capabilities help visualize the flow of requests through complex distributed architectures, identifying bottlenecks and errors.
```

--------------------------------

### Define and Use Cache Service with NodeFileSystem

Source: https://effect.website/docs/requirements-management/layers

Defines a Cache service that uses `NodeFileSystem` for reading files. It then shows how to access this service within a program to look up data and provides a mock file system for testing.

```typescript
import { FileSystem } from "@effect/platform"
import { NodeFileSystem } from "@effect/platform-node"
import { Effect, Console } from "effect"

// Define a Cache service
class Cache extends Effect.Service()("app/Cache", {
  effect: Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem
    const lookup = (key: string) => fs.readFileString(`cache/${key}`)
    return { lookup } as const
  }),
  dependencies: [NodeFileSystem.layer]
}) {}

// Accessing the Cache Service
const program = Effect.gen(function* () {
  const cache = yield* Cache
  const data = yield* cache.lookup("my-key")
  console.log(data)
}).pipe(Effect.catchAllCause((cause) => Console.log(cause)))

// Create a test file system that always returns a fixed value
const FileSystemTest = FileSystem.layerNoop({
  readFileString: () => Effect.succeed("File Content...")
})

const runnable = program.pipe(
  Effect.provide(Cache.DefaultWithoutDependencies),
  // Provide the mock file system
  Effect.provide(FileSystemTest)
)

Effect.runFork(runnable)
// Output: File Content...
```

--------------------------------

### Handle Multiple Resume Calls with Effect.async in JavaScript

Source: https://effect.website/docs/getting-started/creating-effects

Demonstrates the behavior of Effect.async when the 'resume' function is called multiple times. Only the first call to 'resume' will take effect; subsequent calls are ignored. This example shows a successful result followed by an ignored second attempt.

```javascript
import { Effect } from "effect"

const program = Effect.async((resume) => {
  resume(Effect.succeed(1))
  resume(Effect.succeed(2)) // This line will be ignored
})

// Run the program
Effect.runPromise(program).then(console.log) // Output: 1
```

--------------------------------

### Sequential Errors with Effect.ensuring

Source: https://effect.website/docs/error-management/parallel-and-sequential-errors

This example illustrates handling multiple sequential errors that arise from resource-safety operators like Effect.ensuring. It shows that both the original effect's failure and the finalizer's defect are captured.

```typescript
import { Effect } from "effect"

// Simulate an effect that fails
const fail = Effect.fail("Oh uh!")

// Simulate a finalizer that causes a defect
const die = Effect.dieMessage("Boom!")

// The finalizer 'die' will always run, even if 'fail' fails
const program = fail.pipe(
  Effect.ensuring(die)
)

Effect.runPromiseExit(program).then(console.log)

/*
Output:
{
  _id: 'Exit',
  _tag: 'Failure',
  cause: {
    _id: 'Cause',
    _tag: 'Sequential',
    left: {
      _id: 'Cause',
      _tag: 'Fail',
      failure: 'Oh uh!'
    },
    right: {
      _id: 'Cause',
      _tag: 'Die',
      defect: [Object]
    }
  }
}
*/
```

--------------------------------

### Deferred Common Use Cases

Source: https://effect.website/docs/concurrency/deferred

Illustrates practical applications of the Deferred primitive, such as coordinating concurrent fibers, achieving synchronization, handing over work between fibers, and suspending execution.

```APIDOC
## Common Use Cases

### Description

The `Deferred` primitive is particularly useful for managing asynchronous operations and coordinating the execution of concurrent fibers. It acts as a synchronization point, allowing one fiber to signal completion or the availability of a result to other fibers.

### Use Cases

- **Coordinating Fibers**: Facilitates communication and synchronization between multiple concurrent tasks, enabling one fiber to signal another when a specific operation is complete.
- **Synchronization**: Ensures that a piece of code does not proceed until another piece of code has finished its work, providing necessary synchronization.
- **Handing Over Work**: Allows one fiber to prepare data or perform an initial task, and then hand over the continuation of the work to another fiber.
- **Suspending Execution**: Enables a fiber to pause its execution until a certain condition is met or a specific event occurs, signaled via a `Deferred`.

### Example (Using Deferred to Coordinate Two Fibers)

This example demonstrates how to use a `Deferred` to pass a value between two concurrently running fibers, ensuring that `fiberB` waits for `fiberA` to complete its task.

```typescript
import { Effect, Deferred, Fiber } from "effect";

const program = Effect.gen(function* () {
  const deferred = yield* Deferred.make<string>();

  // Completes the Deferred with a value after a delay
  const taskA = Effect.gen(function* () {
    console.log("Starting task to complete the Deferred");
    yield* Effect.sleep("1 second");
    console.log("Completing the Deferred");
    return yield* Deferred.succeed(deferred, "hello world");
  });

  // Waits for the Deferred and prints the value
  const taskB = Effect.gen(function* () {
    console.log("Waiting for the Deferred to be completed...");
    const value = yield* Deferred.await(deferred);
    console.log("Deferred completed with value:", value);
    return value;
  });

  // Run both tasks concurrently
  const fiberA = yield* Fiber.fork(taskA);
  const fiberB = yield* Fiber.fork(taskB);

  // Optionally, await both fibers to ensure they complete
  yield* Fiber.join(fiberA);
  yield* Fiber.join(fiberB);
});

Effect.runFork(program);
```
```

--------------------------------

### Compose Workspace Transactional Effect (Effect)

Source: https://effect.website/docs/resource-management/scope

Composes the `createBucket`, `createIndex`, and `createEntry` effects into a single scoped effect named `make`. This `make` effect ensures that resources are acquired and released in a transactional manner, suitable for workspace setup.

```typescript
import { Effect, Context, Exit, Data } from "effect"

// Assume S3, ElasticSearch, and Database services and their create operations are defined as above.

const make = Effect.scoped(
  Effect.gen(function* () {
    const bucket = yield* createBucket
    const index = yield* createIndex
    return yield* createEntry(bucket, index)
  })
)
```

--------------------------------

### Test Effect with ElasticSearch Failure

Source: https://effect.website/docs/resource-management/scope

This example illustrates testing an effect with a simulated 'ElasticSearch' failure during index creation. The FailureCase service is set to 'ElasticSearch'. The output shows S3 bucket creation, followed by an ElasticSearch index creation failure and subsequent rollback of the S3 bucket.

```typescript
const runnable = make.pipe(
  Effect.provide(layer),
  Effect.provideService(FailureCase, "ElasticSearch")
)
```

--------------------------------

### Decode Hex Encoded String to UTF-8 using Effect Schema

Source: https://effect.website/docs/schema/transformations

Decodes a hex encoded string into a UTF-8 string using `Schema.StringFromHex`. The example demonstrates converting hex pairs to their corresponding byte values using `TextEncoder`.

```typescript
import { Schema } from "effect"

const decode = Schema.decodeUnknownSync(Schema.StringFromHex)

console.log(new TextEncoder().encode(decode("0001020304050607")))
/*
Output:
Uint8Array(8) [
  0,
  1,
  2,
  3,
  4,
  5,
  6,
  7
]
*/
```

--------------------------------

### Provide Random Service Implementation

Source: https://effect.website/docs/requirements-management/services

Demonstrates how to provide an actual implementation for a declared service (Random) using Effect.provideService. This allows the effect to be run successfully, as the required service is now available.

```typescript
import { Effect, Context } from "effect"

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag("MyRandomService")<Random, {
  readonly next: Effect.Effect
}>() {}

// Using the service
const program = Effect.gen(function* () {
  const random = yield* Random
  const randomNumber = yield* random.next
  console.log(`random number: ${randomNumber}`)
})

// Providing the implementation
const runnable = Effect.provideService(program, Random, {
  next: Effect.sync(() => Math.random())
})

// Run successfully
Effect.runPromise(runnable)
```

--------------------------------

### BigDecimal Creation

Source: https://effect.website/docs/data-types/bigdecimal

Demonstrates various methods for creating BigDecimal instances, including from BigInt, strings, and numbers.

```APIDOC
## BigDecimal Creation

### fromBigInt

The `fromBigInt` function creates a `BigDecimal` from a `bigint`. The `scale` defaults to `0`, meaning the number has no fractional part.

**Example** (Creating a BigDecimal from a BigInt)
```
1 import { BigDecimal } from "effect"
2 
3 const decimal = BigDecimal.fromBigInt(10n)
4 
5 console.log(decimal)
6 // Output: { _id: 'BigDecimal', value: '10', scale: 0 }
```

### fromString

Parses a numerical string into a `BigDecimal`. Returns an `Option`:
* `Some(BigDecimal)` if the string is valid.
* `None` if the string is invalid.

**Example** (Parsing a String into a BigDecimal)
```
1 import { BigDecimal } from "effect"
2 
3 const decimal = BigDecimal.fromString("0.02")
4 
5 console.log(decimal)
6 /*
7 Output:
8 {
9  _id: 'Option',
10  _tag: 'Some',
11  value: { _id: 'BigDecimal', value: '2', scale: 2 }
12 }
13 */
```

### unsafeFromString

The `unsafeFromString` function is a variant of `fromString` that throws an error if the input string is invalid. Use this only when you are confident that the input will always be valid.

**Example** (Unsafe Parsing of a String)
```
1 import { BigDecimal } from "effect"
2 
3 const decimal = BigDecimal.unsafeFromString("0.02")
4 
5 console.log(decimal)
6 // Output: { _id: 'BigDecimal', value: '2', scale: 2 }
```

### unsafeFromNumber

Creates a `BigDecimal` from a JavaScript `number`. Throws a `RangeError` for non-finite numbers (`NaN`, `+Infinity`, or `-Infinity`).

**Example** (Unsafe Parsing of a Number)
```
1 import { BigDecimal } from "effect"
2 
3 console.log(BigDecimal.unsafeFromNumber(123.456))
4 // Output: { _id: 'BigDecimal', value: '123456', scale: 3 }
```

**Avoid Direct Conversion**
Avoid converting floating-point numbers directly to `BigDecimal`, as their representation may already introduce precision issues.
```

--------------------------------

### Wrap Callback API with Effect.async in JavaScript

Source: https://effect.website/docs/getting-started/creating-effects

Illustrates how to convert a Node.js fs module callback-based function (like readFile) into an Effect-compatible asynchronous operation using Effect.async. The 'resume' function is used to signal success with data or failure with an error. Ensure '@types/node' is installed for TypeScript.

```javascript
import { Effect } from "effect"
import * as NodeFS from "node:fs"

const readFile = (filename) =>
  Effect.async((resume) => {
    NodeFS.readFile(filename, (error, data) => {
      if (error) {
        // Resume with a failed Effect if an error occurs
        resume(Effect.fail(error))
      } else {
        // Resume with a succeeded Effect if successful
        resume(Effect.succeed(data))
      }
    })
  })

// ┌─── Effect
// ▼
const program = readFile("example.txt")
```

--------------------------------

### Executing Effects and Obtaining a MicroFiber with Micro.runFork

Source: https://effect.website/docs/micro/effect-users

Explains the usage of `Micro.runFork` to execute a 'Micro' effect and obtain a `MicroFiber`. This fiber can be managed (awaited, joined, aborted), and results can be observed using `addObserver`.

```typescript
import { Micro } from "effect"

// Example usage:
// const fiber = Micro.runFork(myMicroEffect)
// fiber.addObserver(result => {
//   console.log("Effect finished:", result)
// })

```

--------------------------------

### Add Randomness to Delays with Jitter (Effect)

Source: https://effect.website/docs/scheduling/schedule-combinators

Demonstrates using Schedule.jittered to add randomness to retry delays. This helps avoid synchronized retries causing further overload. The example shows jittered exponential backoff.

```typescript
import { Array, Chunk, Duration, Effect, Schedule } from "effect"

const log = (
  schedule: Schedule.Schedule,
  delay: Duration.DurationInput = 0
): void => {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () => delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) => {
    console.log(
      i === maxRecurs
        ? "..."
        : i === delays.length - 1
        ? "(end)"
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.jittered(Schedule.exponential("10 millis"))

log(schedule)
```

--------------------------------

### Creating Effects with Different Causes (TypeScript)

Source: https://effect.website/docs/data-types/cause

This snippet demonstrates how to define effects that fail with specific causes using `Effect.failCause`. It shows examples of creating an effect that 'dies' with an unexpected error (`Cause.die`) and an effect that 'fails' with an expected error (`Cause.fail`).

```typescript
import { Effect, Cause } from "effect"

// Define an effect that dies with an unexpected error
//
// ┌─── Effect
// ▼
const die = Effect.failCause(Cause.die("Boom!"))

// Define an effect that fails with an expected error
//
// ┌─── Effect
// ▼
const fail = Effect.failCause(Cause.fail("Oh no!"))
```

--------------------------------

### Log a Simple Message with Effect.js

Source: https://effect.website/docs/observability/logging

Demonstrates how to log a single message at the default INFO level using `Effect.log`. The output includes timestamp, log level, fiber ID, and the message content.

```typescript
import { Effect } from "effect"

const program = Effect.log("Application started")

Effect.runFork(program)
/* 
Output:
timestamp=... level=INFO fiber=#0 message="Application started"
*/
```

--------------------------------

### Perform Basic Arithmetic with BigDecimal in TypeScript

Source: https://effect.website/docs/data-types/bigdecimal

Provides examples of performing common arithmetic operations (addition, multiplication, subtraction, division, negation, modulus) using the BigDecimal module. These operations ensure precision and avoid floating-point errors. Requires the 'effect' package.

```typescript
import { BigDecimal } from "effect"

const dec1 = BigDecimal.unsafeFromString("1.05")
const dec2 = BigDecimal.unsafeFromString("2.10")

// Addition
console.log(String(BigDecimal.sum(dec1, dec2)))
// Output: BigDecimal(3.15)

// Multiplication
console.log(String(BigDecimal.multiply(dec1, dec2)))
// Output: BigDecimal(2.205)

// Subtraction
console.log(String(BigDecimal.subtract(dec2, dec1)))
// Output: BigDecimal(1.05)

// Division (safe, returns Option)
console.log(BigDecimal.divide(dec2, dec1))
/* 
Output: 
{
  _id: 'Option',
  _tag: 'Some',
  value: { _id: 'BigDecimal', value: '2', scale: 0 }
}
*/

// Division (unsafe, throws if divisor is zero)
console.log(String(BigDecimal.unsafeDivide(dec2, dec1)))
// Output: BigDecimal(2)

// Negation
console.log(String(BigDecimal.negate(dec1)))
// Output: BigDecimal(-1.05)

// Modulus (unsafe, throws if divisor is zero)
console.log(
  String(
    BigDecimal.unsafeRemainder(dec2, BigDecimal.unsafeFromString("0.6") )
  )
)
// Output: BigDecimal(0.3)
```

--------------------------------

### Handling Shallow Defaults in Nested Structs (Effect Schema)

Source: https://effect.website/docs/schema/default-constructors

Shows an example where default values in nested structs do not automatically apply to the top-level constructor. This leads to a type error if the nested property is missing.

```typescript
import { Schema } from "effect"

const Config = Schema.Struct({
  // Define a nested struct with a default value
  web: Schema.Struct({
    application_url: Schema.String.pipe(
      Schema.propertySignature,
      Schema.withConstructorDefault(() => "http://localhost")
    ),
    application_port: Schema.Number
  })
})

// This will cause a type error because 'application_url'
// is missing in the nested struct
// Config.make({ web: { application_port: 3000 } })
```

--------------------------------

### Control Flow: `while` Loop

Source: https://context7_llms

Demonstrates how to implement a `while` loop using Effect's control flow operators. This allows for iterative execution of Effects based on a condition.

```typescript
import * as Effect from "@effect/io/Effect"

let counter = 0
const loop = Effect.whileLoop(
  () => counter < 5,
  () => Effect.sync(() => {
    counter++
    console.log(`Iteration: ${counter}`)
  })
)

Effect.runSync(loop)
```

--------------------------------

### Timeout Stream and Fail with Message

Source: https://effect.website/docs/stream/error-handling

This example uses `Stream.timeoutFail` to terminate a stream after a set duration and fail with a custom error message. The stream `Effect.never` will time out, resulting in a failure with the provided message.

```typescript
import { Stream, Effect } from "effect"

const stream = Stream.fromEffect(Effect.never).pipe(
  Stream.timeoutFail(() => "timeout", "2 seconds")
)

Effect.runPromiseExit(Stream.runCollect(stream)).then(console.log)
```

--------------------------------

### Conflicting Index Signature Example (Effect Schema)

Source: https://effect.website/docs/schema/basic-usage

Demonstrates a conflicting index signature scenario where a fixed property 'a' has a different type (string) than the values allowed by the index signature (number). This leads to incorrect TypeScript typing.

```typescript
import { Schema } from "effect"

// Attempting to define a struct with a conflicting index signature
// - The fixed property "a" is a string
// - The index signature requires all values to be numbers
const schema = Schema.Struct(
  {
    a: Schema.String
  },
  {
    key: Schema.String,
    value: Schema.Number
  }
)

// ❌ Incorrect TypeScript type:
// type Type = typeof schema.Type
```

--------------------------------

### Create a Cache with Options

Source: https://effect.website/docs/caching/cache

Demonstrates the creation of a cache using the `make` function. This function requires options specifying the cache's `capacity` (maximum number of entries) and `timeToLive` (duration for entries to remain valid). It also takes the `lookup` function, which defines how to compute values for given keys.

```typescript
declare const make: <Key, Value, Requirements, Error>(
  options: {
    readonly capacity: number
    readonly timeToLive: Duration.DurationInput
    readonly lookup: Lookup<Key, Value, Requirements, Error>
  }
) => Effect<Cache<Key, Value, Requirements, Error>, never, Requirements | Scope>
```

--------------------------------

### Handle Multiple Error Types with Effect.catchTag

Source: https://effect.website/docs/error-management/expected-errors

This example demonstrates how to chain multiple Effect.catchTag calls to handle different error types. By catching both HttpError and ValidationError, the resulting effect's error channel is narrowed.

```typescript
import { Effect, Random, Data } from "effect"

class HttpError extends Data.TaggedError("HttpError")<{}>

class ValidationError extends Data.TaggedError("ValidationError")<{}>

const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    return yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    return yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

const recovered = program.pipe(
  Effect.catchTag("HttpError", (_HttpError) => 
    Effect.succeed("Recovering from HttpError")
  ),
  Effect.catchTag("ValidationError", (_ValidationError) => 
    Effect.succeed("Recovering from ValidationError")
  )
)

// const recovered: Effect<string, never, never>

```

--------------------------------

### Effect Schema: Omit Properties from Union

Source: https://effect.website/docs/schema/basic-usage

This example demonstrates applying the `omit` function to a union of schemas in Effect. It creates a new schema by excluding a specific property ('b') that exists in the schemas within the union.

```typescript
import { Schema } from "effect"

const MyUnion = Schema.Union(
  Schema.Struct({
    a: Schema.String,
    b: Schema.String,
    c: Schema.String
  }),
  Schema.Struct({
    a: Schema.Number,
    b: Schema.Number,
    d: Schema.Number
  })
)

const PickedSchema = MyUnion.pipe(Schema.omit("b"))
```

--------------------------------

### Effect.js: Forking and Waiting on a Latch

Source: https://effect.website/docs/concurrency/latch

This snippet demonstrates forking an Effect into a new fiber, yielding to allow it to run, and then waiting for a latch to open before proceeding. It also shows how to wait for the forked fiber to complete.

```javascript
import * as Effect from "@effect/core/io/Effect"
import * as Fiber from "@effect/core/io/Fiber"
import * as Ref from "@effect/core/io/Ref"
import * as Layer from "@effect/core/io/Layer"
import { pipe } from "@effect/data/Function"
import * as Synchronized from "@effect/core/io/Cause/errors"
import { Clock } from "@effect/core/io/Clock"

// Assume latch and fiber are defined elsewhere, e.g.:
// const latch = await Effect.runPromise(Synchronized.newLatch(0))
// const fiber = await Effect.runPromise(Effect.fork(someEffect))

const program = Effect.gen(function* (_) {
  const latch = yield* _(Synchronized.newLatch(0))
  const fiber = yield* _(Effect.fork(Effect.delay(1000)(Effect.succeed("open sesame"))))

  // Wait for the latch to open
  yield* _(latch.await)

  // Wait for the forked fiber to finish
  const result = yield* _(fiber.await)
  console.log(result)
})

// To run this example, you would need to implement the latch and fiber creation
// For demonstration purposes, let's simulate the latch opening after a delay

const runExample = Effect.gen(function* (_)
{
  const latch = yield* _(Synchronized.newLatch(0))
  const fiber = yield* _(Effect.fork(Effect.delay(1000)(Effect.succeed("open sesame"))))

  // Simulate opening the latch after a delay
  yield* _(Effect.delay(500)(latch.open))

  yield* _(fiber.await)
})

// Effect.runFork(runExample)

```

--------------------------------

### Run Effect Without Interruption

Source: https://effect.website/docs/concurrency/basic-concurrency

Demonstrates a basic Effect execution that runs to completion without any interruption. It logs the start and end of a sleep operation, returning a success value. This serves as a baseline for understanding interruption.

```typescript
import { Effect } from "effect"

const program = Effect.gen(function* () {
 console.log("start")
 yield* Effect.sleep("2 seconds")
 console.log("done")
 return "some result"
})

Effect.runPromiseExit(program).then(console.log)
/* 
Output:
start
done
{ 
_id: 'Exit', 
_tag: 'Success', 
value: 'some result' 
}
*/
```

--------------------------------

### Collecting Leftovers with Sink.collectLeftover

Source: https://effect.website/docs/sink/leftovers

This example demonstrates how to use `Sink.collectLeftover` to capture elements that remain unconsumed after a sink operation. It returns a tuple containing the sink's result and the leftover elements. This is useful when you need to process or inspect all elements from a stream, even if the sink only acts on a subset.

```typescript
import { Stream, Sink, Effect } from "effect"

const stream = Stream.make(1, 2, 3, 4, 5)

// Take the first 3 elements and collect any leftovers
const sink1 = Sink.take(3).pipe(Sink.collectLeftover)

Effect.runPromise(Stream.run(stream, sink1)).then(console.log)
/*
Output:
[
  { _id: 'Chunk', values: [ 1, 2, 3 ] },
  { _id: 'Chunk', values: [ 4, 5 ] }
]
*/

// Take only the first element and collect the rest as leftovers
const sink2 = Sink.head().pipe(Sink.collectLeftover)

Effect.runPromise(Stream.run(stream, sink2)).then(console.log)
/*
Output:
[
  { _id: 'Option', _tag: 'Some', value: 1 },
  { _id: 'Chunk', values: [ 2, 3, 4, 5 ] }
]
*/
```

--------------------------------

### Run Node.js Program with Deno

Source: https://effect.website/docs/platform/introduction

Executes a TypeScript file directly using Deno. Deno can run Node.js-compatible code by importing npm packages, requiring specific permission flags for certain operations.

```bash
deno run index.ts
```

```bash
deno run -RE index.ts
```

--------------------------------

### Handling Success and Failure with match in neverthrow and Effect

Source: https://effect.website/docs/additional-resources/effect-vs-neverthrow

This example demonstrates how to handle both successful and failed outcomes at the end of a chain of asynchronous operations. It uses the `match` function in neverthrow and Effect's `match` operator.

```typescript
import { ResultAsync } from "neverthrow"

interface User {
  readonly name: string
}
declare function validateUser(user: User): ResultAsync<User, Error>
declare function insertUser(user: User): ResultAsync<User, Error>

const user: User = { name: "John" }

// Handle both cases at the end of the chain using match
const resultMessage = await validateUser(user)
  .andThen(insertUser)
  .match(
    (user: User) => `User ${user.name} has been successfully created`,
    (error: Error) => `User could not be created because ${error.message}`
  )
```

```typescript
import * as Effect from "effect/Effect"

interface User {
  readonly name: string
}
declare function validateUser(user: User): Effect.Effect<User, Error>
declare function insertUser(user: User): Effect.Effect<User, Error>

const user: User = { name: "John" }

// Handle both cases at the end of the chain using match
const resultMessage = await Effect.runPromise(
  validateUser(user).pipe(
    Effect.andThen(insertUser),
    Effect.match({
      onSuccess: (user) =>
        `User ${user.name} has been successfully created`,
      onFailure: (error) =>
        `User could not be created because ${error.message}`
    })
  )
)
```

--------------------------------

### Setting a Timeout for an Effect Operation (TypeScript)

Source: https://effect.website/docs/error-management/timing-out

This example demonstrates how to use `Effect.timeout` to set a time limit for an Effect operation. If the operation completes within the specified duration, its result is successfully returned. Otherwise, a TimeoutException is thrown.

```typescript
import { Effect } from "effect"

const task = Effect.gen(function* () {
  console.log("Start processing...")
  yield* Effect.sleep("2 seconds") // Simulates a delay in processing
  console.log("Processing complete.")
  return "Result"
})

// Sets a 3-second timeout for the task
const timedEffect = task.pipe(Effect.timeout("3 seconds"))

// Output will show that the task completes successfully
// as it falls within the timeout duration
Effect.runPromiseExit(timedEffect).then(console.log)
/*
Output:
Start processing...
Processing complete.
{ _id: 'Exit', _tag: 'Success', value: 'Result' }
*/
```

--------------------------------

### Combine Fibers with Fiber.zip in Effect.js

Source: https://effect.website/docs/concurrency/fibers

Demonstrates how to fork two fibers concurrently and combine their results into a tuple using Fiber.zip. This is useful when you need to run multiple independent effects in parallel and await all their results.

```typescript
import { Effect, Fiber } from "effect"

const program = Effect.gen(function* () {
  // Fork two fibers that each produce a string
  const fiber1 = yield* Effect.fork(Effect.succeed("Hi!"))
  const fiber2 = yield* Effect.fork(Effect.succeed("Bye!"))

  // Combine the two fibers using Fiber.zip
  const fiber = Fiber.zip(fiber1, fiber2)

  // Join the combined fiber and get the result as a tuple
  const tuple = yield* Fiber.join(fiber)
  console.log(tuple)
})

Effect.runFork(program)
/* 
Output: 
[ 'Hi!', 'Bye!' ] 
*/
```

--------------------------------

### Combining and Providing Multiple Services with Effect-TS

Source: https://effect.website/docs/requirements-management/services

Illustrates how to combine multiple service implementations into a single Context object using Context.empty and Context.add, and then provide this combined context to an effect using Effect.provide.

```typescript
import { Effect, Context } from "effect"

class Random extends Context.Tag("MyRandomService")<Random, {
  readonly next: Effect.Effect
}>() {}

class Logger extends Context.Tag("MyLoggerService")<Logger, {
  readonly log: (message: string) => Effect.Effect
}>() {}

const program = Effect.gen(function* () {
  const random = yield* Random
  const logger = yield* Logger
  const randomNumber = yield* random.next
  return yield* logger.log(String(randomNumber))
})

// Combine service implementations into a single 'Context'
const context = Context.empty().pipe(
  Context.add(Random, { next: Effect.sync(() => Math.random()) }),
  Context.add(Logger, {
    log: (message) => Effect.sync(() => console.log(message))
  })
)

// Provide the entire context
const runnable = Effect.provide(program, context)
```

--------------------------------

### Default ParseError (Incorrect Property Type)

Source: https://effect.website/docs/schema/error-messages

This example demonstrates the default ParseError when a property has an incorrect data type compared to what the schema expects. It specifies the expected type and the actual received type for each erroneous property.

```typescript
import { Schema } from "effect"

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

Schema.decodeUnknownSync(Person)(
  { name: null, age: "age" },
  { errors: "all" }
)
/* 
throws:
ParseError: { readonly name: string; readonly age: number }
├─ ["name"]
│  └─ Expected string, actual null
└─ ["age"]
   └─ Expected number, actual "age"
*/
```

--------------------------------

### Parse and Validate JSON Structure using Effect Schema

Source: https://effect.website/docs/schema/transformations

Parses a JSON string and validates its structure against a provided schema using `Schema.parseJson` with a nested schema. This example uses a `Schema.Struct` to ensure the parsed JSON is an object with a numeric property `a`.

```typescript
import { Schema } from "effect"

// ┌─── SchemaClass<{ readonly a: number; }, string, never>
// ▼ 
const schema = Schema.parseJson(Schema.Struct({ a: Schema.Number }))
```

--------------------------------

### Invalid Struct with Duplicate String Index Signatures (Effect Schema)

Source: https://effect.website/docs/schema/basic-usage

Shows an example of an invalid struct definition where multiple string index signatures are attempted. This will result in a TypeScript error indicating a duplicate index signature.

```typescript
import { Schema } from "effect"

Schema.Struct(
  {
    a: Schema.Number
  },
  // Attempting to define multiple string index signatures
  {
    key: Schema.String,
    value: Schema.Number
  },
  {
    key: Schema.String,
    value: Schema.Boolean
  }
)
/*
throws:
Error: Duplicate index signature 
details: string index signature
*/
```

--------------------------------

### Create and Use a Bounded Queue in Effect.js

Source: https://effect.website/docs/concurrency/queue

Demonstrates how to create a bounded queue with a specific capacity and perform basic operations like offering and taking elements. This showcases the back-pressure mechanism where offers suspend if the queue is full.

```typescript
import { Effect, Queue } from "effect"

const program = Effect.gen(function* () {
  // Creates a bounded queue with capacity 100
  const queue = yield* Queue.bounded(100)
  // Adds 1 to the queue
  yield* Queue.offer(queue, 1)
  // Retrieves and removes the oldest value
  const value = yield* Queue.take(queue)
  return value
})

Effect.runPromise(program).then(console.log)
// Output: 1
```

--------------------------------

### Refinement Default Constructor Example - Effect Schema

Source: https://effect.website/docs/schema/default-constructors

Demonstrates using a default constructor with a Schema.NumberFromString refined by Schema.between. The constructor accepts numbers within the valid range (1-10) and throws an error for out-of-range numbers.

```typescript
import { Schema } from "effect"

const schema = Schema.NumberFromString.pipe(
  Schema.between(1, 10)
)

// The constructor only accepts numbers
console.log(schema.make(5)) // Output: 5

// This will throw an error because the number is outside the valid range
console.log(schema.make(20))
/*
throws:
ParseError: between(1, 10)
└─ Predicate refinement failure
└─ Expected a number between 1 and 10, actual 20
*/
```

--------------------------------

### Asynchronous API Data Validation with Effect-TS Schema

Source: https://effect.website/docs/schema/transformations

Shows how to perform asynchronous transformations and validations using `Schema.transformOrFail` by returning an `Effect`. This example validates a person's ID by making an API call. Failures in the API call are caught and converted into `ParseResult.Type` errors.

```typescript
import { Effect, Schema, ParseResult } from "effect"

// Define a function to make API requests
const get = (url: string): Effect.Effect =>
  Effect.tryPromise({
    try: () =>
      fetch(url).then((res) => {
        if (res.ok) {
          return res.json() as Promise
        }
        throw new Error(String(res.status))
      }),
    catch: (e) => new Error(String(e))
  })

// Create a branded schema for a person's ID
const PeopleId = Schema.String.pipe(Schema.brand("PeopleId"))

// Define a schema with async transformation
const PeopleIdFromString = Schema.transformOrFail(
  Schema.String,
  PeopleId,
  {
    strict: true,
    decode: (s, _, ast) =>
      // Make an API call to validate the ID
      Effect.mapBoth(get(`https://swapi.dev/api/people/${s}`), {
        // Error handling for failed API call
        onFailure: (e) => new ParseResult.Type(ast, s, e.message),
        // Return the ID if the API call succeeds
        onSuccess: () => s
      }),
    encode: ParseResult.succeed
  }
)

// ┌─── string 
// ▼ 
type Encoded = typeof PeopleIdFromString.Encoded

// ┌─── string & Brand<"PeopleId"> 
// ▼ 
type Type = typeof PeopleIdFromString.Type

// ┌─── never 
// ▼ 
type Context = typeof PeopleIdFromString.Context

// Run a successful decode operation
Effect.runPromiseExit(Schema.decodeUnknown(PeopleIdFromString)("1")).then(
  console.log
)
/* 
Output: 
{ _id: 'Exit', _tag: 'Success', value: '1' } 
*/

// Run a decode operation that will fail
Effect.runPromiseExit(
  Schema.decodeUnknown(PeopleIdFromString)("fail")
).then(console.log)
```

--------------------------------

### Bypass Validation in Effect Schema Class Instantiation

Source: https://effect.website/docs/schema/classes

Illustrates how to bypass validation when creating an instance of a Person class using Effect Schema. The example shows two methods: passing 'true' as the second argument to the constructor, or passing an options object with 'disableValidation: true'.

```typescript
import { Schema } from "effect"

class Person extends Schema.Class("Person")({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {}

// Bypass validation during instantiation
const john = new Person({ id: 1, name: "" }, true)

// Or use the `disableValidation` option explicitly
new Person({ id: 1, name: "" }, { disableValidation: true })
```

--------------------------------

### HashSet Basic Creation and Operations

Source: https://effect.website/docs/data-types/hash-set

Illustrates the fundamental operations of Effect's immutable HashSet, including creation, adding elements, and performing set algebra like union, intersection, and difference. It highlights that adding an element to an immutable set returns a new set, leaving the original unchanged.

```typescript
import { HashSet } from "effect"

// Create an initial set with 3 values
const set1 = HashSet.make(1, 2, 3)

// Add a value (returns a new set)
const set2 = HashSet.add(set1, 4)

// The original set is unchanged
console.log(HashSet.toValues(set1))
// Output: [1, 2, 3]

console.log(HashSet.toValues(set2))
// Output: [1, 2, 3, 4]

// Perform set operations with another set
const set3 = HashSet.make(3, 4, 5)

// Combine both sets
const union = HashSet.union(set2, set3)

console.log(HashSet.toValues(union))
// Output: [1, 2, 3, 4, 5]

// Shared values
const intersection = HashSet.intersection(set2, set3)

console.log(HashSet.toValues(intersection))
// Output: [3, 4]

// Values only in set2
const difference = HashSet.difference(set2, set3)

console.log(HashSet.toValues(difference))
// Output: [1, 2]
```

--------------------------------

### Handle Overlapping Schemas in Union

Source: https://effect.website/docs/schema/basic-usage

Provides an example of defining a union schema with potentially overlapping member schemas. It highlights the importance of evaluation order, demonstrating how placing a more specific schema first ensures correct decoding.

```typescript
import { Schema } from "effect"

const Member1 = Schema.Struct({
  a: Schema.String
})

const Member2 = Schema.Struct({
  a: Schema.String,
  b: Schema.Number
})

// ❌ Define a union where Member1 appears first
const Bad = Schema.Union(Member1, Member2)

console.log(Schema.decodeUnknownSync(Bad)({ a: "a", b: 12 }))
// Output: { a: 'a' } (Member1 matched first, so `b` was ignored)

// ✅ Define a union where Member2 appears first
const Good = Schema.Union(Member2, Member1)

console.log(Schema.decodeUnknownSync(Good)({ a: "a", b: 12 }))
// Output: { a: 'a', b: 12 } (Member2 matched first, so `b` was included)
```

--------------------------------

### Literal Schemas in Effect

Source: https://effect.website/docs/schema/basic-usage

Illustrates the creation of literal schemas for exact values of string, number, boolean, null, and bigint. Examples show defining single literals and unions of literals.

```typescript
import { Schema } from "effect"

// Define various literal schemas
Schema.Null // Same as S.Literal(null)
Schema.Literal("a") // string literal
Schema.Literal(1) // number literal
Schema.Literal(true) // boolean literal
Schema.Literal(2n) // BigInt literal
```

```typescript
import { Schema } from "effect"

// ┌─── Literal<["a"]>
// ▼
const schema = Schema.Literal("a")

// ┌─── "a"
// ▼
type Type = typeof schema.Type

console.log(Schema.decodeUnknownSync(schema)("a"))
// Output: "a"

console.log(Schema.decodeUnknownSync(schema)("b"))
/* 
throws:
ParseError: Expected "a", actual "b"
*/
```

```typescript
import { Schema } from "effect"

// ┌─── Literal<["a", "b", "c"]>
// ▼
const schema = Schema.Literal("a", "b", "c")

// ┌─── "a" | "b" | "c"
// ▼
type Type = typeof schema.Type

Schema.decodeUnknownSync(schema)(null)
/* 
throws:
ParseError: "a" | "b" | "c"
├─ Expected "a", actual null
├─ Expected "b", actual null
└─ Expected "c", actual null
*/
```

```typescript
import { Schema } from "effect"

// Schema with individual messages for each literal
const individualMessages = Schema.Literal("a", "b", "c")

console.log(Schema.decodeUnknownSync(individualMessages)(null))
/* 
throws:
ParseError: "a" | "b" | "c"
├─ Expected "a", actual null
├─ Expected "b", actual null
└─ Expected "c", actual null
*/

// Schema with a unified custom message for all literals
const unifiedMessage = Schema.Literal("a", "b", "c").annotations({
  message: () => ({ message: "Not a valid code", override: true })
})

console.log(Schema.decodeUnknownSync(unifiedMessage)(null))
/* 
throws:
ParseError: Not a valid code
*/
```

```typescript
import { Schema } from "effect"

const schema = Schema.Literal("a", "b", "c")

// ┌─── readonly ["a", "b", "c"]
// ▼
const literals = schema.literals
```

--------------------------------

### Create a Gauge Metric in TypeScript

Source: https://effect.website/docs/observability/metrics

Demonstrates how to initialize a Gauge metric using the Metric.gauge constructor. This metric type is suitable for values that can increase or decrease, such as memory usage.

```typescript
import { Metric } from "effect"

const memory = Metric.gauge("memory_usage", {
  // Optional
  description: "A gauge for memory usage"
})
```

--------------------------------

### Set Custom Environment Variables for Commands

Source: https://effect.website/docs/platform/command

Shows how to set custom environment variables for a command using `Command.env`. It also demonstrates using `Command.runInShell(true)` to ensure that shell-specific variable expansions are correctly processed.

```typescript
import { Command } from "@effect/platform"
import { NodeContext, NodeRuntime } from "@effect/platform-node"
import { Effect } from "effect"

const command = Command.make("echo", "-n", "$MY_CUSTOM_VAR").pipe(
  Command.env({
    MY_CUSTOM_VAR: "Hello, this is a custom environment variable!"
  }),
  // Use shell to interpret variables correctly
  // on Windows and Unix-like systems
  Command.runInShell(true)
)

const program = Effect.gen(function* () {
  const output = yield* Command.string(command)
  console.log(output)
})

NodeRuntime.runMain(program.pipe(Effect.provide(NodeContext.layer)))
```

--------------------------------

### Use the `Int` Constructor with Validation (TypeScript)

Source: https://effect.website/docs/code-style/branded-types

This example shows how to use the `Int` constructor created with `Brand.refined`. It demonstrates creating a valid `Int` value and how attempting to create an `Int` with a non-integer value (e.g., a float) will result in a runtime error with a descriptive message.

```typescript
import { Brand } from "effect"

type Int = number & Brand.Brand<"Int">

const Int = Brand.refined<number, "Int">( 
  (n) => Number.isInteger(n),
  (n) => Brand.error(`Expected ${n} to be an integer`)
)

// Create a valid Int value
const x: Int = Int(3)
console.log(x) // Output: 3

// Attempt to create an Int with an invalid value
// const y: Int = Int(3.14)
// throws [ { message: 'Expected 3.14 to be an integer' } ]

```

--------------------------------

### Defining Environment with Union of Services in Effect

Source: https://effect.website/docs/additional-resources/coming-from-zio

This example demonstrates how to define the environment required for an Effect workflow using a union of services in TypeScript. It shows the structure for `IOError`, `HttpError`, `Console`, and `Logger` interfaces, culminating in a `Http` type that is a union of `Console` and `Logger`. This approach differs from ZIO's intersection-based environment representation.

```typescript
import { Effect } from "effect"

interface IOError {
  readonly _tag: "IOError"
}

interface HttpError {
  readonly _tag: "HttpError"
}

interface Console {
  readonly log: (msg: string) => void
}

interface Logger {
  readonly log: (msg: string) => void
}

type Response = Record

// `R` is a union of `Console` and `Logger`
type Http = Effect.Effect<never, IOError | HttpError, Response>
```

--------------------------------

### Export Spans to Console with Effect.fn and OpenTelemetry (Effect.js)

Source: https://effect.website/docs/error-management/expected-errors

Configures Effect.js to export traced spans to the console using OpenTelemetry. This example sets up a NodeSdk with a ConsoleSpanExporter and BatchSpanProcessor, allowing visibility into function execution, metadata, and errors.

```typescript
import { Effect } from "effect"
import { NodeSdk } from "@effect/opentelemetry"
import {
  ConsoleSpanExporter,
  BatchSpanProcessor
} from "@opentelemetry/sdk-trace-base"

const myfunc = Effect.fn("myspan")(function* (n: number) {
  yield* Effect.annotateCurrentSpan("n", n)
  console.log(`got: ${n}`)
  yield* Effect.fail(new Error("Boom!"))
})

const program = myfunc(100)

const NodeSdkLive = NodeSdk.layer(() => ({
  resource: { serviceName: "example" },
  // Export span data to the console
  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())
}))

// Effect.runFork(program.pipe(Effect.provide(NodeSdkLive)))
// Note: The above line is commented out as it's an incomplete snippet for demonstration.
```

--------------------------------

### Handle Invalid Input for String to Boolean Transformation (Effect)

Source: https://effect.website/docs/schema/transformations

This example shows how the `Schema.transform` function handles invalid input when decoding. If the input does not conform to the source schema ('on' or 'off' in this case), the transformation fails before the decode function is even called, providing detailed error messages.

```typescript
import { Schema } from "effect"

// Convert "on"/"off" to boolean and back
const BooleanFromString = Schema.transform(
  Schema.Literal("on", "off"),
  Schema.Boolean,
  {
    strict: true,
    decode: (s) => s === "on",
    encode: (bool) => (bool ? "on" : "off")
  }
)

// Providing input not allowed by the source schema
Schema.decodeUnknownSync(BooleanFromString)("wrong")
/*
throws:
ParseError: ("on" | "off" <-> boolean)
└─ Encoded side transformation failure
└─ "on" | "off"
├─ Expected "on", actual "wrong"
└─ Expected "off", actual "wrong"
*/
```

--------------------------------

### Environment Object for Bundling Services in TypeScript

Source: https://effect.website/docs/requirements-management/services

Illustrates using a context or environment object to group multiple services. This approach simplifies passing services but introduces the complexity of ensuring the environment is correctly initialized with all required services.

```typescript
type Context = {
  databaseService: DatabaseService
  loggingService: LoggingService
}

const processData = (data: Data, context: Context) => {
  // Using multiple services from the context
}
```

--------------------------------

### Generate Natural Numbers with Stream.unfold

Source: https://effect.website/docs/stream/creating

Generates a stream of natural numbers starting from an initial state. Uses a step function that returns Option.some([value, nextState]) to continue or Option.none() to end. Requires 'effect' library. The output is a chunk of numbers.

```typescript
import { Stream, Effect, Option } from "effect"

const stream = Stream.unfold(1, (n) => Option.some([n, n + 1]))

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(
  console.log
)
// { _id: 'Chunk', values: [ 1, 2, 3, 4, 5 ] }
```

--------------------------------

### Group Stream Elements with Effectful Function using Stream.groupBy

Source: https://effect.website/docs/stream/operations

This example shows how to group stream elements using an effectful partitioning function with Stream.groupBy. It returns a GroupBy data type that can be evaluated. The input is a stream of names, and the output groups them by their first letter and counts the names in each group, simulating an effectful operation.

```typescript
import { Stream, GroupBy, Effect, Chunk } from "effect"

// Group names by their first letter
const groupByKeyResult = Stream.fromIterable([
  "Mary",
  "James",
  "Robert",
  "Patricia",
  "John",
  "Jennifer",
  "Rebecca",
  "Peter"
]).pipe(
  // Simulate an effectful groupBy operation
  Stream.groupBy((name) => Effect.succeed([name.substring(0, 1), name]))
)

// Count the number of names in each group and display results
const stream = GroupBy.evaluate(groupByKeyResult, (key, stream) =>
  Stream.fromEffect(
    Stream.runCollect(stream).pipe(
      Effect.andThen((chunk) => [key, Chunk.size(chunk)] as const)
    )
  )
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)

/* 
Output:
{
  _id: 'Chunk',
  values: [ [ 'M', 1 ], [ 'J', 3 ], [ 'R', 2 ], [ 'P', 2 ] ]
}
*/
```

--------------------------------

### Main Effect Execution with Client Provisioning (TypeScript)

Source: https://effect.website/docs/ai/planning-llm-interactions

The main entry point for the application's effects. It pipes a main effect with the provision of both Anthropic and OpenAI clients, then runs the effect to completion using `runPromise`. This ensures the necessary client layers are available.

```typescript
main.pipe(
  Effect.provide([Anthropic, OpenAi]),
  Effect.runPromise
)
```

--------------------------------

### Nesting Spans for Hierarchical Operations with Effect.js and OpenTelemetry

Source: https://effect.website/docs/observability/tracing

This example illustrates how to create nested spans using Effect.js and OpenTelemetry to represent hierarchical operations. It defines a 'child' effect with its own span and a 'parent' effect that includes the 'child' effect and additional delays, showcasing the parent-child relationship in the trace output.

```typescript
import { Effect } from "effect"
import { NodeSdk } from "@effect/opentelemetry"
import {
  ConsoleSpanExporter,
  BatchSpanProcessor
} from "@opentelemetry/sdk-trace-base"

const child = Effect.void.pipe(
  Effect.delay("100 millis"),
  Effect.withSpan("child")
)

const parent = Effect.gen(function* () {
  yield* Effect.sleep("20 millis")
  yield* child
  yield* Effect.sleep("10 millis")
}).pipe(Effect.withSpan("parent"))

// Set up tracing with the OpenTelemetry SDK
const NodeSdkLive = NodeSdk.layer(() => ({
  resource: { serviceName: "example" },
  spanProcessor: new BatchSpanProcessor(new ConsoleSpanExporter())
}))

// Run the effect, providing the tracing layer
Effect.runPromise(parent.pipe(Effect.provide(NodeSdkLive)))
```

--------------------------------

### Observe Asynchronous Effect with Effect.js

Source: https://effect.website/docs/micro/effect-users

Demonstrates how to observe the completion of an asynchronous effect using `Micro.runFork` and attaching an observer. This pattern is useful for handling side effects that occur after an effect has successfully completed. The output shows the logged result of the asynchronous operation.

```typescript
import { Micro } from "effect"

// ┌─── MicroFiber
// ▼
const fiber = Micro.succeed(42).pipe(Micro.delay(1000), Micro.runFork)

// Attach an observer to log the result when the effect completes
fiber.addObserver((result) => {
console.log(result)
})

console.log("observing...")
/* 
Output:
observing...
{
  "_id": "MicroExit",
  "_tag": "Success",
  "value": 42
}
*/
```

--------------------------------

### Unsafely Get Duration Value in Nanoseconds (TypeScript)

Source: https://effect.website/docs/data-types/duration

Retrieves the value of a duration in nanoseconds as a `bigint` using `Duration.unsafeToNanos`. This method throws an error for infinite durations, so use it only when you are certain the duration is finite.

```typescript
import { Duration } from "effect"

console.log(Duration.unsafeToNanos(Duration.millis(100)))
// Output: 100000000n

console.log(Duration.unsafeToNanos(Duration.infinity))
/*
throws:
Error: Cannot convert infinite duration to nanos
...
*/
```

--------------------------------

### Defining a Person Schema with Optional Properties

Source: https://effect.website/docs/schema/introduction

This example demonstrates how to define a schema for a 'Person' object using effect/Schema. It utilizes 'Schema.optionalWith' to specify an optional 'name' property, leveraging the 'exact: true' option for precise handling of optional properties when 'exactOptionalPropertyTypes' is enabled in TypeScript.

```typescript
import { Schema } from "effect"

const Person = Schema.Struct({
  name: Schema.optionalWith(Schema.NonEmptyString, { exact: true 

```

--------------------------------

### Handle Sync and Async Validation with Standard Schema V1

Source: https://effect.website/docs/schema/standard-schema

Illustrates how the `validate` method of a Standard Schema V1 object can return either a direct value (for synchronous validation) or a `Promise` (for asynchronous validation), depending on the underlying Effect Schema. Includes examples for both scenarios.

```typescript
import { Effect, Schema } from "effect"

// Utility function to display sync and async results
const print = (t: T) =>
 t instanceof Promise
 ? t.then((x) => console.log("Promise", JSON.stringify(x, null, 2)))
 : console.log("Value", JSON.stringify(t, null, 2))

// Define a synchronous schema
const sync = Schema.Struct({
 name: Schema.String
})

// Generate a Standard Schema V1 object
const syncStandardSchema = Schema.standardSchemaV1(sync)

// Validate synchronously
print(syncStandardSchema["~standard"].validate({ name: null }))
/*
Output:
{
  "issues": [
    {
      "path": [
        "name"
      ],
      "message": "Expected string, actual null"
    }
  ]
}
*/

// Define an asynchronous schema with a transformation
const async = Schema.transformOrFail(
 sync,
 Schema.Struct({
  name: Schema.NonEmptyString
 }),
 {
  // Simulate an asynchronous validation delay
  decode: (x) => Effect.sleep("100 millis").pipe(Effect.as(x)),
  encode: Effect.succeed
 }
)

// Generate a Standard Schema V1 object
const asyncStandardSchema = Schema.standardSchemaV1(async)
```

--------------------------------

### Map Property Signature from a Different Key in Effect Schema

Source: https://effect.website/docs/schema/advanced-usage

This example shows how to map a property signature from a source field with a different key name to a target field in your internal model. The Schema.fromKey function is used to establish this mapping.

```typescript
import { Schema } from "effect"

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.propertySignature(Schema.NumberFromString).pipe(
    Schema.fromKey("AGE") // Maps from "AGE" to "age"
  )
})

console.log(Schema.decodeUnknownSync(Person)({" name": "name", AGE: "18" }))
// Output: { name: 'name', age: 18 }
```

--------------------------------

### Manage Resource Lifetime with Effect.acquireUseRelease (TypeScript)

Source: https://effect.website/docs/resource-management/introduction

Effect.acquireUseRelease ensures resources are properly acquired, used, and released, even if errors occur. It takes three functions: `acquire` to get the resource, `use` to operate on it, and `release` to clean it up. This pattern is crucial for managing external resources like database connections or file handles.

```typescript
import { Effect, Console } from "effect"

// Define an interface for a resource
interface MyResource {
  readonly contents: string
  readonly close: () => Promise<void>
}

// Simulate resource acquisition
const getMyResource = (): Promise<MyResource> =>
  Promise.resolve({
    contents: "lorem ipsum",
    close: () =>
      new Promise((resolve) => {
        console.log("Resource released")
        resolve()
      })
  })

// Define how the resource is acquired
const acquire = Effect.tryPromise({
  try: () =>
    getMyResource().then((res) => {
      console.log("Resource acquired")
      return res
    }),
  catch: () => new Error("getMyResourceError")
})

// Define how the resource is released
const release = (res: MyResource) => Effect.promise(() => res.close())

const use = (res: MyResource) => Console.log(`content is ${res.contents}`)

// Effect
const program = Effect.acquireUseRelease(acquire, use, release)

Effect.runPromise(program)
/*
Output:
Resource acquired
content is lorem ipsum
Resource released
*/
```

--------------------------------

### MutableHashSet - Concepts and Operations

Source: https://effect.website/docs/data-types/hash-set

Explains the concept of MutableHashSet, highlighting its mutability and contrasting it with HashSet, and lists its available operations.

```APIDOC
## MutableHashSet - Concepts and Operations

A `MutableHashSet` allows for in-place modifications, offering performance benefits for frequent updates.

### Description

A `MutableHashSet` is a **mutable**, **unordered** collection of **unique** values. Unlike `HashSet`, operations like `add`, `remove`, and `clear` modify the original set directly. This mutability is beneficial for scenarios requiring repeated modifications within a contained scope.

### Example (Using `Schema.Data` with `MutableHashSet`)

```typescript
import { Equal, MutableHashSet, Schema } from "effect"

// Define a schema that describes the structure of a Person
const PersonSchema = Schema.Data(
  Schema.Struct({
    id: Schema.Number,
    name: Schema.String,
    age: Schema.Number
  })
)

// Decode values from plain objects
const Person = Schema.decodeSync(PersonSchema)

const person1 = Person({ id: 1, name: "Alice", age: 30 })
const person2 = Person({ id: 1, name: "Alice", age: 30 })

// person1 and person2 are different instances but equal in value
console.log(Equal.equals(person1, person2)) // Output: true

// Add both to a MutableHashSet — only one will be stored
const set = MutableHashSet.empty<typeof person1>().pipe(
  MutableHashSet.add(person1),
  MutableHashSet.add(person2)
)

console.log(MutableHashSet.size(set)) // Output: 1
```

### Operations

| Category      | Operation    | Description                                     | Complexity |
|---------------|--------------|-------------------------------------------------|------------|
| Constructors  | `empty`      | Creates an empty MutableHashSet                 | O(1)       |
| Constructors  | `fromIterable`| Creates a MutableHashSet from an iterable       | O(n)       |
| Constructors  | `make`       | Creates a MutableHashSet from multiple values   | O(n)       |
| Elements      | `has`        | Checks if a value exists in the set             | O(1) avg   |
| Elements      | `some`       | Checks if any element satisfies a predicate     | O(n)       |
| Elements      | `every`      | Checks if all elements satisfy a predicate      | O(n)       |
| Getters       | `values`     | Gets an `Iterator` of all values                | O(1)       |
| Getters       | `toValues`   | Gets an `Array` of all values                   | O(n)       |
| Getters       | `size`       | Gets the number of elements                     | O(1)       |
| Mutations     | `add`        | Adds a value to the set (modifies in-place)     | O(1) avg   |
| Mutations     | `remove`     | Removes a value from the set (modifies in-place)| O(1) avg   |
| Mutations     | `clear`      | Removes all elements from the set               | O(n)       |
| Operations    | `difference` | Computes set difference (A - B) (returns new set)| O(n)       |
| Operations    | `intersection`| Computes set intersection (A ∩ B) (returns new set)| O(n)       |
| Operations    | `union`      | Computes set union (A ∪ B) (returns new set)    | O(n)       |
| Mapping       | `map`        | Transforms each element (returns new set)       | O(n)       |
| Filtering     | `filter`     | Keeps elements that satisfy a predicate (returns new set)| O(n)       |
```

--------------------------------

### Repeat Single Value Stream using Effect TS

Source: https://effect.website/docs/stream/creating

Creates a stream that endlessly repeats a specified value. This is useful for generating streams with a constant value. The example demonstrates taking the first 5 elements of such a stream.

```typescript
import { Stream, Effect } from "effect"

const stream = Stream.repeatValue(0)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(
  console.log
)
// { _id: 'Chunk', values: [ 0, 0, 0, 0, 0 ] }
```

--------------------------------

### Sequential Task Execution with One-Permit Semaphore - Effect.js

Source: https://effect.website/docs/concurrency/semaphore

Demonstrates how to use `withPermits(1)` to force sequential execution of concurrent tasks. The one-permit semaphore ensures that only one task can proceed at a time, even when multiple tasks are started concurrently.

```typescript
import { Effect } from "effect"

const task = Effect.gen(function* () {
  yield* Effect.log("start")
  yield* Effect.sleep("2 seconds")
  yield* Effect.log("end")
})

const program = Effect.gen(function* () {
  const mutex = yield* Effect.makeSemaphore(1)

  // Wrap the task to require one permit, forcing sequential execution
  const semTask = mutex
    .withPermits(1)(task)
    .pipe(Effect.withLogSpan("elapsed"))

  // Run 3 tasks concurrently, but they execute sequentially
  // due to the one-permit semaphore
  yield* Effect.all([semTask, semTask, semTask], {
    concurrency: "unbounded"
  })
})

Effect.runFork(program)
```

--------------------------------

### Create Utc from Various Inputs (Effect-TS)

Source: https://effect.website/docs/data-types/datetime

Shows how to create Utc DateTime instances using `DateTime.unsafeMake` with different input types: a JavaScript Date, partial date parts, and a string.

```typescript
import { DateTime } from "effect"

// From a JavaScript Date
const utc1 = DateTime.unsafeMake(new Date("2025-01-01 04:00:00"))
console.log(utc1)
// Output: DateTime.Utc(2025-01-01T03:00:00.000Z)

// From partial date parts
const utc2 = DateTime.unsafeMake({ year: 2025 })
console.log(utc2)
// Output: DateTime.Utc(2025-01-01T00:00:00.000Z)

// From a string
const utc3 = DateTime.unsafeMake("2025-01-01")
console.log(utc3)
// Output: DateTime.Utc(2025-01-01T00:00:00.000Z)
```

--------------------------------

### Injecting Test Dependencies with Effect.Service

Source: https://effect.website/docs/requirements-management/layers

Illustrates how to use the Cache.DefaultWithoutDependencies layer with a mock FileSystem to test service logic without interacting with the actual file system. This is crucial for unit testing Effect applications.

```typescript
import { FileSystem } from "@effect/platform"
import { NodeFileSystem } from "@effect/platform-node"
import { Effect, Console } from "effect"

// Define a Cache service
class Cache extends Effect.Service()("app/Cache", {
  effect: Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem
    const lookup = (key: string) => fs.readFileString(`cache/${key}`)
    return { lookup } as const
  }),
  dependencies: [NodeFileSystem.layer]
}) {}

// Example of using a test file system (requires a mock implementation of FileSystem)
// const testFileSystemLayer = FileSystem.layer.use(() => ({ ...mockFileSystemImplementation }))
// const runnable = program.pipe(Effect.provide(Cache.DefaultWithoutDependencies, testFileSystemLayer))
```

--------------------------------

### Refine or Die Stream Errors by Type

Source: https://effect.website/docs/stream/error-handling

This example shows how to selectively keep certain errors while terminating the stream with others using `Stream.refineOrDie`. It filters errors, retaining only `SyntaxError` types and discarding all other error types.

```typescript
import { Stream, Option } from "effect"

const stream = Stream.fail(new Error())

const res = Stream.refineOrDie(stream, (error) => {
  if (error instanceof SyntaxError) {
    return Option.some(error)
  }
  return Option.none()
})
```

--------------------------------

### Intersection Schedule Combinator Example - Effect.js

Source: https://effect.website/docs/scheduling/schedule-combinators

Illustrates the 'Intersection' schedule combinator. This combinator merges two schedules, and the resulting schedule recurs only if both input schedules want to continue. It uses the longer delay between the two schedules.

```typescript
import { Array, Chunk, Duration, Effect, Schedule } from "effect"

// Assuming the log helper function is defined as above

const exponential = Schedule.exponential("100ms").pipe(
  Schedule.addDelay(() => "50ms")
);

const spaced = Schedule.spaced("200ms").pipe(
  Schedule.addDelay(() => "20ms")
);

const intersectionSchedule = Schedule.intersect(exponential, spaced);

console.log("--- Intersection Schedule ---");
log(intersectionSchedule);

```

--------------------------------

### Micro module for Effect Users

Source: https://context7_llms

Introduction to the Micro module, a lightweight alternative to Effect designed to reduce bundle size while maintaining compatibility for TypeScript applications.

```markdown
The Micro module offers a more minimal API surface compared to the full Effect library, suitable for scenarios where bundle size is critical.
```

--------------------------------

### Covariant Type Parameter in EffectJS

Source: https://effect.website/docs/additional-resources/coming-from-zio

Demonstrates how EffectJS uses a covariant R type parameter, utilizing unions for composing services. This differs from ZIO's approach and improves type signature clarity. The example shows assigning a union type to a variable.

```typescript
interface A {
  readonly prop: string
}

interface B {
  readonly prop: number
}

// ok
const ab: A | B = {
  prop: ""
}
```

--------------------------------

### Create Successful Operation: Promise vs. Effect

Source: https://effect.website/docs/additional-resources/effect-vs-promise

Demonstrates how to create a successful asynchronous operation using both JavaScript's native Promise and the Effect library. Effect.succeed is used for success cases.

```javascript
const success = Promise.resolve(2)
```

```typescript
import { Effect } from "effect"

const success = Effect.succeed(2)
```

--------------------------------

### Using a Rest Element in Effect Schema Tuples

Source: https://effect.website/docs/schema/basic-usage

Illustrates the use of a rest element in Effect's Schema.Tuple constructor, allowing the tuple to accept any number of additional elements of a specified type. The example defines a tuple with required and optional elements followed by a rest element of booleans.

```typescript
import { Schema } from "effect"

// Define a tuple with required elements and a rest element of type boolean
const schema = Schema.Tuple(
  [Schema.String, Schema.optionalElement(Schema.Number)], // elements
  Schema.Boolean // rest element
)

// ┌─── readonly [string, number?, ...boolean[]]
// ▼
type Type = typeof schema.Type
```

--------------------------------

### Providing Bun Context for Effect Platform

Source: https://effect.website/docs/platform/introduction

Adapts the Effect Platform program to run within a Bun environment by providing the Bun-specific context. This allows the program to leverage Bun APIs.

```typescript
1 import { Path } from "@effect/platform"
2 import { Effect } from "effect"
3 import { BunContext, BunRuntime } from "@effect/platform-bun"
4 
5 const program = Effect.gen(function* () {
6 // Access the Path service
7 const path = yield* Path.Path
8 
9 // Join parts of a path to create a complete file path
10 const mypath = path.join("tmp", "file.txt")
11 
12 console.log(mypath)
13 })
14 
15 BunRuntime.runMain(program.pipe(Effect.provide(BunContext.layer)))

```

--------------------------------

### Implement Dad Joke Tool Handlers - Effect AI

Source: https://effect.website/docs/ai/tool-use

Implements the logic for the 'GetDadJoke' tool within a Toolkit using '.toLayer'. This example demonstrates how to access Effect platform services like HttpClient to make API calls and handle responses, returning the joke string.

```typescript
import { Tool, Toolkit } from "@effect/ai"
import { HttpClient, HttpClientRequest, HttpClientResponse } from "@effect/platform"
import { NodeHttpClient } from "@effect/platform-node"
import { Array, Effect, Schema } from "effect"

class DadJoke extends Schema.Class("DadJoke")({
  id: Schema.String,
  joke: Schema.String
}) {}

class SearchResponse extends Schema.Class("SearchResponse")({
  results: Schema.Array(DadJoke)
}) {}

class ICanHazDadJoke extends Effect.Service()("ICanHazDadJoke", {
  dependencies: [NodeHttpClient.layerUndici],
  effect: Effect.gen(function*() {
    const httpClient = yield* HttpClient.HttpClient
    const httpClientOk = httpClient.pipe(
      HttpClient.filterStatusOk,
      HttpClient.mapRequest(HttpClientRequest.prependUrl("https://icanhazdadjoke.com"))
    )

    const search = Effect.fn("ICanHazDadJoke.search")(
      function*(searchTerm: string) {
        return yield* httpClientOk.get("/search", {
          acceptJson: true,
          urlParams: { searchTerm }
        }).pipe(
          Effect.flatMap(HttpClientResponse.schemaBodyJson(SearchResponse)),
          Effect.flatMap(({ results }) => Array.head(results)),
          Effect.map((joke) => joke.joke),
          Effect.orDie
        )
      }
    )

    return {
      search
    } as const
  })
}) {}

const GetDadJoke = Tool.make("GetDadJoke", {
  description: "Get a hilarious dad joke from the ICanHazDadJoke API",
  success: Schema.String,
  failure: Schema.Never,
  parameters: {
    searchTerm: Schema.String.annotations({
      description: "The search term to use to find dad jokes"
    })
  }
})

const DadJokeTools = Toolkit.make(GetDadJoke)

const DadJokeToolHandlers = DadJokeTools.toLayer(
  Effect.gen(function*() {
    // Access the `ICanHazDadJoke` service
    const icanhazdadjoke = yield* ICanHazDadJoke
    return {
      // Implement the handler for the `GetDadJoke` tool call request
      GetDadJoke: ({ searchTerm }) => icanhazdadjoke.search(searchTerm)
    }
  })
)
```

--------------------------------

### Interrupt Parent Fiber Without Affecting Daemon Fiber

Source: https://effect.website/docs/concurrency/fibers

This example shows how interrupting the parent fiber does not affect the daemon fiber, which continues to run in the background. It uses `Effect.forkDaemon` for the background task and `Effect.onInterrupt` to handle parent fiber interruption. It requires the 'effect' library.

```typescript
import { Effect, Console, Schedule, Fiber } from "effect"

// Daemon fiber that logs a message repeatedly every second
const daemon = Effect.repeat(
  Console.log("daemon: still running!"),
  Schedule.fixed("1 second")
)

const parent = Effect.gen(function* () {
  console.log("parent: started!")
  // Daemon fiber running independently
  yield* Effect.forkDaemon(daemon)
  yield* Effect.sleep("3 seconds")
  console.log("parent: finished!")
}).pipe(Effect.onInterrupt(() => Console.log("parent: interrupted!")))

// Program that interrupts the parent fiber after 2 seconds
const program = Effect.gen(function* () {
  const fiber = yield* Effect.fork(parent)
  yield* Effect.sleep("2 seconds")
  yield* Fiber.interrupt(fiber) // Interrupt the parent fiber
})

Effect.runFork(program)
```

--------------------------------

### Encode/Decode HashSetFromSelf with Effect-TS Schema

Source: https://effect.website/docs/schema/effect-data-types

This snippet illustrates using Schema.HashSetFromSelf for scenarios where HashSets are already in the correct format but inner values need transformation. It demonstrates decoding a HashSet of strings to a HashSet of numbers and encoding vice-versa. The examples show the resulting HashSets after decoding and encoding.

```typescript
import { Schema } from "effect"
import { HashSet } from "effect"

const schema = Schema.HashSetFromSelf(Schema.NumberFromString)

// ┌─── HashSet
// ▼
type Encoded = typeof schema.Encoded

// ┌─── HashSet
// ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(decode(HashSet.fromIterable(["1", "2", "3"])))
// Output: { _id: 'HashSet', values: [ 1, 2, 3 ] }

// Encoding examples

console.log(encode(HashSet.fromIterable([1, 2, 3])))
// Output: { _id: 'HashSet', values: [ '1', '3', '2' ] }
```

--------------------------------

### Using the Brand Interface from the Brand Module in TypeScript

Source: https://effect.website/docs/code-style/branded-types

This example demonstrates the practical application of the `effect/Brand` module by importing and using its `Brand` interface. It simplifies the creation of branded types like `ProductId` and `UserId` by providing a standardized and type-safe way to add unique identifiers.

```typescript
import { Brand } from "effect"

// Define a ProductId type branded with a unique identifier
type ProductId = number & Brand.Brand<{
  readonly ProductId: "ProductId"
}>

// Define a UserId type branded similarly
type UserId = number & Brand.Brand<{
  readonly UserId: "UserId"
}>
```

--------------------------------

### Create and Use Latch - Effect TypeScript

Source: https://effect.website/docs/concurrency/latch

Demonstrates creating a Latch in a closed state using Effect.makeLatch and then opening it to release a waiting fiber. The fiber logs a message only after the latch is opened.

```typescript
import { Console, Effect } from "effect"

// A generator function that demonstrates latch usage
const program = Effect.gen(function* () {
  // Create a latch, starting in the closed state
  const latch = yield* Effect.makeLatch()

  // Fork a fiber that logs "open sesame" only when the latch is open
  const fiber = yield* Console.log("open sesame").pipe(
    latch.await
  )

  // Wait for one second before opening the latch
  yield* Effect.sleep(1000)
  yield* latch.open()

  yield* Console.log("Latch opened!")
})

Effect.runFork(program)
```

--------------------------------

### Load Environment Variable as Array of Strings

Source: https://effect.website/docs/configuration

Illustrates using the `Config.array` combinator to parse an environment variable into an array of strings. The input format is typically comma-separated.

```typescript
import { Config, Effect } from "effect"

const program = Effect.gen(function* () {
  const config = yield* Config.array(Config.string(), "MYARRAY")
  console.log(config)
})

Effect.runPromise(program)
// Run:
// MYARRAY=a,b,c,a npx tsx index.ts
// Output:
// [ 'a', 'b', 'c', 'a' ]
```

--------------------------------

### Define Custom Service Tag with Context.Tag in Effect-TS

Source: https://effect.website/docs/micro/new-users

Illustrates how to declare a service tag using `Context.Tag` in Effect-TS. A service tag defines a unique identifier and the interface for a service. This example defines a `Random` service tag with a `next` method that returns a `Micro` effect.

```typescript
import { Micro, Context } from "effect"

// Declaring a tag for a service that generates random numbers
class Random extends Context.Tag("MyRandomService")<
Random,
{
  readonly next: Micro.Micro
}
>() {}
```

--------------------------------

### TypeScript: Using Built-in Order Comparators

Source: https://effect.website/docs/behaviour/order

Demonstrates how to use the built-in Order comparators for string, number, and bigint types. These functions simplify comparisons without needing to manually implement the logic.

```typescript
import { Order } from "effect"

console.log(Order.string("apple", "banana"))
// Output: -1, as "apple" < "banana"

console.log(Order.number(1, 1))
// Output: 0, as 1 = 1

console.log(Order.bigint(2n, 1n))
// Output: 1, as 2n > 1n
```

--------------------------------

### Fixed Schedule: Recur at Fixed Intervals

Source: https://effect.website/docs/scheduling/built-in-schedules

Shows the `Schedule.fixed` schedule, which ensures recurrences happen at regular intervals, regardless of action execution time. This example logs delays when the action takes 100ms and the schedule is fixed at 200ms.

```typescript
import { Array, Chunk, Duration, Effect, Schedule } from "effect"

const log = (
  schedule: Schedule.Schedule,
  delay: Duration.DurationInput = 0
): void => {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () => delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) => {
    console.log(
      i === maxRecurs
        ? "..."
        : i === delays.length - 1
        ? "(end)"
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.fixed("200 millis")

// ┌─── Simulating an effect that takes
// │ 100 milliseconds to complete
// ▼
log(schedule, "100 millis")
```

--------------------------------

### Conditional Effect Execution with Effect.whenEffect in TypeScript

Source: https://effect.website/docs/getting-started/control-flow

Illustrates executing an effect conditionally based on the result of another effect using `Effect.whenEffect`. In this example, `Random.nextInt` is executed only if `Random.nextBoolean` returns true. Requires 'effect' and 'effect/random' libraries.

```typescript
import { Effect, Random } from "effect"

const randomIntOption = Random.nextInt.pipe(
  Effect.whenEffect(Random.nextBoolean)
)

console.log(Effect.runSync(randomIntOption))
/* 
Example Output:
{
  _id: 'Option',
  _tag: 'Some',
  value: 8609104974198840
}
*/
```

--------------------------------

### Stream Throttling with Burst Capacity (TypeScript)

Source: https://effect.website/docs/stream/operations

Demonstrates how to throttle a stream using 'effect' library, allowing temporary increases in data throughput beyond set rate limits by configuring burst capacity. This is useful for handling uneven data flows.

```typescript
import { Effect, Schedule, Stream, Chunk } from "effect"

// Helper function to log with elapsed time since last log
let last = Date.now()
const log = (message: string) =>
  Effect.sync(() => {
    const end = Date.now()
    console.log(`${message} after ${end - last}ms`)
    last = end
  })

const stream = Stream.fromSchedule(Schedule.spaced("10 millis")).pipe(
  Stream.take(20),
  Stream.tap((n) => log(`Received ${n}`)),
  Stream.throttle({
    cost: Chunk.size,
    duration: "200 millis",
    units: 5,
    strategy: "enforce",
    burst: 2
  }),
  Stream.tap((n) => log(`> Emitted ${n}`))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
```

--------------------------------

### Iterate Over Future Cron Dates

Source: https://effect.website/docs/scheduling/cron

Generates an infinite iterator of future dates that match a cron schedule using the `sequence` function. You can specify a starting date for the iteration. This is useful for generating a series of upcoming event times.

```typescript
import { Cron } from "effect"

// Define a cron expression for 4:00 AM
// on the 8th to the 14th of every month
const cron = Cron.unsafeParse("0 0 4 8-14 * *", "UTC")

// Specify the starting date
const start = new Date("2021-01-08")

// Create an iterator for the schedule
const iterator = Cron.sequence(cron, start)

// Get the first matching date after the start date
console.log(iterator.next().value)
// Output: 2021-01-08T04:00:00.000Z

// Get the second matching date after the start date
console.log(iterator.next().value)
// Output: 2021-01-09T04:00:00.000Z
```

--------------------------------

### Create UTC DateTime from JavaScript Date

Source: https://effect.website/docs/data-types/datetime

Converts a JavaScript Date object to a UTC DateTime object using the 'effect' library. It handles potential `None` results if the input is invalid. The example demonstrates conversion from a specific date and time, showing the resulting UTC value.

```javascript
import { DateTime } from "effect"

// From a JavaScript Date
const maybeUtc1 = DateTime.make(new Date("2025-01-01 04:00:00"))
console.log(maybeUtc1)
/* 
Output:
{ _id: 'Option', _tag: 'Some', value: '2025-01-01T03:00:00.000Z' } 
*/
```

--------------------------------

### Combine Schedules with Intersection (Effect)

Source: https://effect.website/docs/scheduling/schedule-combinators

Demonstrates using Schedule.intersect to combine two schedules. The intersect operator recurs only if both schedules want to continue, using the longer delay. This example limits exponential backoff with a fixed number of retries.

```typescript
import { Array, Chunk, Duration, Effect, Schedule } from "effect"

const log = (
  schedule: Schedule.Schedule,
  delay: Duration.DurationInput = 0
): void => {
  const maxRecurs = 10
  const delays = Chunk.toArray(
    Effect.runSync(
      Schedule.run(
        Schedule.delays(Schedule.addDelay(schedule, () => delay)),
        Date.now(),
        Array.range(0, maxRecurs)
      )
    )
  )
  delays.forEach((duration, i) => {
    console.log(
      i === maxRecurs
        ? "..."
        : i === delays.length - 1
        ? "(end)"
        : `#${i + 1}: ${Duration.toMillis(duration)}ms`
    )
  })
}

const schedule = Schedule.intersect(
  Schedule.exponential("10 millis"),
  Schedule.recurs(5)
)

log(schedule)
```

--------------------------------

### Retry Effect with Fixed Delay Schedule

Source: https://effect.website/docs/error-management/retrying

The `Effect.retry` function retries an effect based on a provided `Schedule` policy. This example demonstrates retrying an effect with a fixed delay between attempts, suitable for handling intermittent failures.

```typescript
import { Effect, Schedule } from "effect"

let count = 0

// Simulates an effect with possible failures
const task = Effect.async((resume) => {
  if (count <= 2) {
    count++
    console.log("failure")
    resume(Effect.fail(new Error()))
  } else {
    console.log("success")
    resume(Effect.succeed("yay!"))
  }
})

// Define a repetition policy using a fixed delay between retries
const policy = Schedule.delay(2000).lastIndexOf(3)

// Retry the task with the defined policy
const retriedTask = Effect.retry(task, policy)

Effect.runPromise(retriedTask).then(console.log).catch(console.error)
```

--------------------------------

### Get and Validate User Guess (TypeScript)

Source: https://effect.website/docs/platform/terminal

An Effect that orchestrates prompting the user for input and validating it using `parseGuess`. If the input is invalid, it displays an error message and recursively calls itself to re-prompt. This ensures the game proceeds only with valid guesses.

```typescript
import { Effect, Option, Random } from "effect"
import { NodeRuntime, NodeTerminal } from "@effect/platform-node"
import { Terminal, PlatformError } from "@effect/platform"

// Get the user's guess, validating it as an integer between 1 and 100
const answer: Effect.Effect<
  number,
  Terminal.QuitException | PlatformError,
  Terminal.Terminal
> = Effect.gen(function* () {
  const input = yield* prompt
  const guess = parseGuess(input)
  if (Option.isNone(guess)) {
    yield* display("You must enter an integer from 1 to 100")
    return yield* answer
  }
  return guess.value
})
```

--------------------------------

### Custom Pretty Printer for Numbers with Annotation (TypeScript)

Source: https://effect.website/docs/schema/pretty

This example shows how to define a custom pretty printer for a schema by using the 'pretty' annotation. The annotation provides a function that takes the value and returns its formatted string representation. This allows for specific formatting logic for different data types within a schema. Dependencies include 'effect'.

```typescript
import { Pretty, Schema } from "effect"

// Define a schema with a custom pretty annotation
const schema = Schema.Number.annotations({
  pretty: (/\*typeParameters*\/) => (value) => `my format: ${value}`
})

// Create the pretty printer
const customPrettyPrinter = Pretty.make(schema)

// Format and print a value
console.log(customPrettyPrinter(1))
// Output: "my format: 1"
```

--------------------------------

### Timeout Stream and Switch to Another

Source: https://effect.website/docs/stream/error-handling

This example demonstrates `Stream.timeoutTo`, where if a stream doesn't produce a value within a specified time, it switches to a different stream. The `Effect.never` stream times out, and execution continues with `Stream.make(1, 2, 3)`.

```typescript
import { Stream, Effect } from "effect"

const stream = Stream.fromEffect(Effect.never).pipe(
  Stream.timeoutTo("2 seconds", Stream.make(1, 2, 3))
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
```

--------------------------------

### Retry API Calls with Timeout in TypeScript

Source: https://effect.website/docs/scheduling/examples

This example demonstrates how to make an API call with a specified number of retries and a timeout duration. The `getJson` function fetches data from a URL, and the `program` function utilizes `Effect.retry` to attempt the call up to two times and `Effect.timeout` to interrupt the operation if it exceeds 4 seconds. `Effect.catchAll` is used to log any errors encountered. Dependencies include the 'effect' library.

```TypeScript
import { Console, Effect } from "effect"

// Function to make the API call
const getJson = (url: string) =>
  Effect.tryPromise(() =>
    fetch(url).then((res) => {
      if (!res.ok) {
        console.log("error")
        throw new Error(res.statusText)
      }
      console.log("ok")
      return res.json() as unknown
    })
  )

// Program that retries the API call twice, times out after 4 seconds,
// and logs errors
const program = (url: string) =>
  getJson(url).pipe(
    Effect.retry({ times: 2 }),
    Effect.timeout("4 seconds"),
    Effect.catchAll(Console.error)
  )

// Test case: successful API response
Effect.runFork(program("https://dummyjson.com/products/1?delay=1000"))
/* 
Output:
ok 
*/

// Test case: API call exceeding timeout limit
Effect.runFork(program("https://dummyjson.com/products/1?delay=5000"))
/* 
Output:
TimeoutException: Operation timed out before the specified duration of '4s' elapsed 
*/

// Test case: API returning an error response
Effect.runFork(program("https://dummyjson.com/auth/products/1?delay=500"))
/* 
Output:
error 
error 
error 
UnknownException: An unknown error occurred 
*/
```

--------------------------------

### Create a Valid Schema Class Instance (TypeScript)

Source: https://effect.website/docs/schema/classes

Shows the creation of a valid `Person` instance using its constructor. The constructor automatically validates that the provided properties (`id` and `name`) adhere to the schema's rules, ensuring `id` is a number and `name` is a non-empty string.

```typescript
import { Schema } from "effect"

class Person extends Schema.Class("Person")({
  id: Schema.Number,
  name: Schema.NonEmptyString
}) {}

// Create an instance with valid properties
const john = new Person({ id: 1, name: "John" })

```

--------------------------------

### Defining Template Literals with Schema.TemplateLiteral - Effect Schema

Source: https://effect.website/docs/schema/basic-usage

Illustrates how to use Schema.TemplateLiteral to create schemas for TypeScript template literal types. Examples include basic string interpolation and unions of literal string endings.

```typescript
import { Schema } from "effect"

// This creates a schema for: `a${string}`
// 
// ┌─── TemplateLiteral<`a${string}`>
// ▼
const schema1 = Schema.TemplateLiteral("a", Schema.String)

// This creates a schema for:
// `https://${string}.com` | `https://${string}.net`
const schema2 = Schema.TemplateLiteral(
  "https://",
  Schema.String,
  ".",
  Schema.Literal("com", "net")
)
```

--------------------------------

### Manage Service Lifecycle with Scoped (Effect.js)

Source: https://effect.website/docs/requirements-management/layers

Demonstrates defining a service with a `scoped` constructor for lifecycle management. It uses `Effect.acquireRelease` to manage resource acquisition and release, and `Effect.addFinalizer` for shutdown tasks.

```typescript
import { Effect, Console } from "effect"

class Scoped extends Effect.Service()("Scoped", {
  scoped: Effect.gen(function* () {
    // Acquire the resource and ensure it is properly released
    const resource = yield* Effect.acquireRelease(
      Console.log("Aquiring...").pipe(Effect.as("foo")),
      () => Console.log("Releasing...")
    )
    // Register a finalizer to run when the effect is completed
    yield* Effect.addFinalizer(() => Console.log("Shutting down"))
    return { resource }
  })
}) {}

// Accessing the Service
const program = Effect.gen(function* () {
  const resource = (yield* Scoped).resource
  console.log(`The resource is ${resource}`)
})

Effect.runPromise(
  program.pipe(
    Effect.provide(
      Scoped.Default
    )
  )
)
/* 
Aquiring...
 The resource is foo 
 Shutting down
 Releasing...
*/
```

--------------------------------

### Zip Streams with Custom Pairing Logic (EffectJS)

Source: https://effect.website/docs/stream/operations

Demonstrates using `Stream.zipWith` to combine elements from two streams by applying a custom function to each pair. This allows for flexible transformations on the zipped elements.

```typescript
import { Stream, Effect } from "effect"

const stream = Stream.zipWith(
  Stream.make(1, 2, 3, 4, 5, 6),
  Stream.make("a", "b", "c"),
  (n, s) => [n + 10, s + "!"]
)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
```

--------------------------------

### Create and Compare Objects with Effect Data

Source: https://effect.website/docs/data-types/hash-set

Demonstrates how to define a data structure using Effect's Schema.Data and compare instances for value equality. It shows that even with different object references, value-equal objects are treated as identical by Effect's Equal.equals and can be stored uniquely in a HashSet.

```typescript
import { Equal, Schema } from "effect"

// Define a schema that describes the structure of a Person
const PersonSchema = Schema.Data(
  Schema.Struct({
    id: Schema.Number,
    name: Schema.String,
    age: Schema.Number
  })
)

// Decode values from plain objects
const Person = Schema.decodeSync(PersonSchema)

const person1 = Person({ id: 1, name: "Alice", age: 30 })
const person2 = Person({ id: 1, name: "Alice", age: 30 })

// person1 and person2 are different instances but equal in value
console.log(Equal.equals(person1, person2))
// Output: true

// Add both to a MutableHashSet — only one will be stored
import { MutableHashSet } from "effect"

const set = MutableHashSet.empty().pipe(
  MutableHashSet.add(person1),
  MutableHashSet.add(person2)
)

console.log(MutableHashSet.size(set))
// Output: 1
```

--------------------------------

### Omitting Empty Strings with `optionalToOptional` in Effect Schema

Source: https://effect.website/docs/schema/advanced-usage

Shows how to use `Schema.optionalToOptional` to transform an optional string field. This example specifically demonstrates how to omit fields containing empty strings from the output during decoding, treating them as absent.

```typescript
import { Option, Schema } from "effect"

const schema = Schema.Struct({
  nonEmpty: Schema.optionalToOptional(Schema.String, Schema.String, {
    // ┌─── Option
    // ▼
    decode: (maybeString) => {
      if (Option.isNone(maybeString)) {
        // If `maybeString` is `None`, the field is absent in the input.
        // Return O
```

--------------------------------

### Handle Failures with matchEffect in Effect.js

Source: https://effect.website/docs/micro/new-users

Demonstrates how to use Micro.matchEffect to handle both successful outcomes and failures in an Effect.js program. It pipes the result through a tap function for logging.

```typescript
import * as Micro from "effect/Cause"

const log = (message: string) => Micro.sync(() => console.log(message))

const program1 = Micro.matchEffect(Micro.succeed(42), {
  onFailure: (error) => Micro.succeed(`failure: ${error.message}`).pipe(Micro.tap(log)),
  onSuccess: (value) => Micro.succeed(`success: ${value}`).pipe(Micro.tap(log))
})

Micro.runSync(program1)
/* 
Output:
success: 42 
*/

const program2 = Micro.matchEffect(Micro.fail(new Error("Uh oh!")), {
  onFailure: (error) => Micro.succeed(`failure: ${error.message}`).pipe(Micro.tap(log)),
  onSuccess: (value) => Micro.succeed(`success: ${value}`).pipe(Micro.tap(log))
})

Micro.runSync(program2)
/* 
Output:
failure: Uh oh! 
*/
```

--------------------------------

### Cleanup Interrupted Effect.async Operations in JavaScript

Source: https://effect.website/docs/getting-started/creating-effects

Shows an advanced usage of Effect.async where the returned Effect handles resource cleanup upon fiber interruption. This example wraps file writing and includes a cleanup effect that deletes the file if the operation is interrupted, ensuring resources are released.

```javascript
import { Effect, Fiber } from "effect"
import * as NodeFS from "node:fs"

// Simulates a long-running operation to write to a file
const writeFileWithCleanup = (filename, data) =>
  Effect.async((resume) => {
    const writeStream = NodeFS.createWriteStream(filename)

    // Start writing data to the file
    writeStream.write(data)

    // When the stream is finished, resume with success
    writeStream.on("finish", () => resume(Effect.void))

    // In case of an error during writing, resume with failure
    writeStream.on("error", (err) => resume(Effect.fail(err)))

    // Handle interruption by returning a cleanup effect
    return Effect.sync(() => {
      console.log(`Cleaning up ${filename}`)
      NodeFS.unlinkSync(filename)
    })
  })

const program = Effect.gen(function* () {
  const fiber = yield* Effect.fork(
    writeFileWithCleanup("example.txt", "Some long data...")
  )
  // Simulate interrupting the fiber after 1 second
  yield* Effect.sleep("1 second")
  yield* Fiber.interrupt(fiber) // This will trigger the cleanup
})

// Run the program
Effect.runPromise(program)
/*
Output:
Cleaning up example.txt
*/
```

--------------------------------

### Run Failing Program with Pretty Logger Disabled (TypeScript)

Source: https://effect.website/docs/platform/runtime

This example demonstrates running a failing Effect.js program with the pretty logger disabled. It uses NodeRuntime to execute an Effect that fails with an error message. The output will include timestamp and level information but with disabled pretty logging.

```typescript
import { NodeRuntime } from "@effect/platform-node"
import { Effect } from "effect"

const failure = Effect.fail("Uh oh!")

NodeRuntime.runMain(failure, { disablePrettyLogger: true }) 
/* 
Output:
timestamp=2025-01-14T11:43:46.276Z level=ERROR fiber=#0 cause="Error: Uh oh!"
*/
```

--------------------------------

### Run Failing Program Without Error Reporting (TypeScript)

Source: https://effect.website/docs/platform/runtime

This example shows how to run a failing Effect.js program while explicitly disabling error reporting. It uses NodeRuntime to execute a failing Effect. When error reporting is disabled, no output related to the error is produced.

```typescript
import { NodeRuntime } from "@effect/platform-node"
import { Effect } from "effect"

const failure = Effect.fail("Uh oh!")

NodeRuntime.runMain(failure, { disableErrorReporting: true })
// No Output
```

--------------------------------

### Effect.gen with Control Flow (TypeScript)

Source: https://effect.website/docs/getting-started/using-generators

Illustrates how to use standard control flow statements like `while` and `if` within an Effect.gen generator function. This example calculates tax for even numbers within a loop until a counter reaches 10, demonstrating complex logic handling.

```typescript
import { Effect, Console } from "effect"

const calculateTax = (
  amount: number,
  taxRate: number
): Effect.Effect =>
  taxRate > 0
    ? Effect.succeed((amount * taxRate) / 100)
    : Effect.fail(new Error("Invalid tax rate"))

const program = Effect.gen(function* () {
  let i = 1

  while (true) {
    if (i === 10) {
      break // Break the loop when counter reaches 10
    } else {
      if (i % 2 === 0) {
        // Calculate tax for even numbers
        console.log(yield* calculateTax(100, i))
      }
      i++
      continue
    }
  }
})

Effect.runPromise(program)
```

--------------------------------

### Adding Metadata with Annotations in Effect Schema

Source: https://effect.website/docs/schema/filters

Example of how to add metadata such as identifiers, JSON schema specifications, and descriptions to a schema using annotations in Effect. This enhances schema understanding and analysis. It uses Schema.filter to apply a length constraint and associates metadata with the schema.

```typescript
import { Schema, JSONSchema } from "effect"

const LongString = Schema.String.pipe(
  Schema.filter(
    (s) =>
      s.length >= 10 ? undefined : "a string at least 10 characters long",
    {
      identifier: "LongString",
      jsonSchema: { minLength: 10 },
      description: "Lorem ipsum dolor sit amet, ..."
    }
  )
)

console.log(Schema.decodeUnknownSync(LongString)("a"))
/*
throws:
ParseError: LongString
└─ Predicate refinement failure
└─ a string at least 10 characters long
*/

console.log(JSON.stringify(JSONSchema.make(LongString), null, 2))
/*
Output:
{
  "$schema": "http://json-schema.org/draft-07/schema#",
  "$defs": {
    "LongString": {
      "type": "string",
      "description": "Lorem ipsum dolor sit amet, ...",
      "minLength": 10
    }
  },
  "$ref": "#/\$defs/LongString"
}
*/
```

--------------------------------

### Effect-TS: Control Stream Termination with 'haltStrategy'

Source: https://effect.website/docs/stream/operations

Illustrates how to control the termination of a merged stream using the `haltStrategy` option in `Stream.merge`. The example specifically uses `haltStrategy: "left"` to terminate the merged stream as soon as the left-hand stream finishes, even if the right-hand stream is still active.

```typescript
import { Stream, Schedule, Effect } from "effect"

const s1 = Stream.range(1, 5).pipe(
  Stream.schedule(Schedule.spaced("100 millis"))
)
const s2 = Stream.repeatValue(0).pipe(
  Stream.schedule(Schedule.spaced("200 millis"))
)

const merged = Stream.merge(s1, s2, { haltStrategy: "left" })

Effect.runPromise(Stream.runCollect(merged)).then(console.log)
```

--------------------------------

### Get First Some Value from Iterable - Option.firstSomeOf

Source: https://effect.website/docs/data-types/option

The `Option.firstSomeOf` function retrieves the first `Some` value from an iterable of `Option` values. If no `Some` value is found, it returns `None`. This is useful for efficiently processing collections where you only need the first valid result.

```typescript
import { Option } from "effect"

const first = Option.firstSomeOf([
  Option.none(),
  Option.some(2),
  Option.none(),
  Option.some(3)
])

console.log(first)
// Output: { _id: 'Option', _tag: 'Some', value: 2 }
```

--------------------------------

### Ignoring Leftovers with Sink.ignoreLeftover

Source: https://effect.website/docs/sink/leftovers

This example shows how to use `Sink.ignoreLeftover` to discard any elements that are not consumed by the sink. This is beneficial when you only care about the result of the sink's intended operation and want to ensure that any remaining elements do not interfere with subsequent processing or cause unexpected behavior. The `Sink.collectLeftover` is still used here to demonstrate that the leftovers are indeed empty.

```typescript
import { Stream, Sink, Effect } from "effect"

const stream = Stream.make(1, 2, 3, 4, 5)

// Take the first 3 elements and ignore any remaining elements
const sink = Sink.take(3).pipe(
  Sink.ignoreLeftover,
  Sink.collectLeftover
)

Effect.runPromise(Stream.run(stream, sink)).then(console.log)
/*
Output:
[
  { _id: 'Chunk', values: [ 1, 2, 3 ] },
  { _id: 'Chunk', values: [] }
]
*/
```

--------------------------------

### Compose Program for Notifying Todo Owners (TypeScript)

Source: https://effect.website/docs/batching

Illustrates a composed Effect program using `Effect.gen` and `Effect.forEach` to fetch all todos and then notify the owner of each todo. This program leverages the previously defined queries and resolvers for efficient batching.

```typescript
const program = Effect.gen(function* () {
  const todos = yield* getTodos
  yield* Effect.forEach(todos, (todo) => notifyOwner(todo), { batching: true })
})
```

--------------------------------

### Run Failing Program with Custom Teardown (TypeScript)

Source: https://effect.website/docs/platform/runtime

This example illustrates running a failing Effect.js program with a custom teardown function. The teardown logic checks the exit status of the program and logs a specific message if the program ended with an error. It then calls the provided `onExit` callback with an appropriate exit code.

```typescript
import { NodeRuntime } from "@effect/platform-node"
import { Effect } from "effect"

const failure = Effect.fail("Uh oh!")

NodeRuntime.runMain(failure, {
  teardown: function customTeardown(exit, onExit) {
    if (exit._tag === "Failure") {
      console.error("Program ended with an error.")
      onExit(1)
    } else {
      console.log("Program finished successfully.")
      onExit(0)
    }
  }
})
/* 
Output:
[12:46:39.871] ERROR (#0):
Error: Uh oh!
Program ended with an error.
*/
```

--------------------------------

### Generate JSON Schema with Standard Annotations (Effect-TS)

Source: https://effect.website/docs/schema/json-schema

This snippet demonstrates how to use standard JSON Schema annotations such as 'description', 'title', 'default', and 'examples' with Effect-TS Schemas. These annotations enrich the schema with metadata for better readability and information. It imports Schema and JSONSchema from 'effect' and generates a JSON schema for a string type.

```typescript
import { JSONSchema, Schema } from "effect"

const schema = Schema.String.annotations({
  description: "my custom description",
  title: "my custom title",
  default: "",
  examples: ["a", "b"]
})

const jsonSchema = JSONSchema.make(schema)

console.log(JSON.stringify(jsonSchema, null, 2))
```

--------------------------------

### Get Redacted Equivalence - Effect.js

Source: https://effect.website/docs/data-types/redacted

The Redacted.getEquivalence function generates an Equivalence for Redacted values using an Equivalence for the underlying values of type A. This allows for comparing Redacted values based on their underlying content. It requires an Equivalence for type A as input.

```typescript
import { Redacted, Equivalence } from "effect"

const stringEquivalence: Equivalence<string> = (x, y) => x === y
const redactedEquivalence = Redacted.getEquivalence(stringEquivalence)

const redacted1 = Redacted.make("sensitive")
const redacted2 = Redacted.make("sensitive")
const redacted3 = Redacted.make("different")

console.log(redactedEquivalence(redacted1, redacted2)) // true
console.log(redactedEquivalence(redacted1, redacted3)) // false
```

--------------------------------

### Define a Simple Custom Logger

Source: https://effect.website/docs/observability/logging

Illustrates how to create a custom logger using Logger.make. This logger formats log messages to include the log level's label and the message itself, then logs them to the console.

```typescript
import { Logger } from "effect"

// Custom logger that outputs log messages to the console
const logger = Logger.make(({ logLevel, message }) => {
  globalThis.console.log(`[${logLevel.label}] ${message}`)
})
```

--------------------------------

### Encode/Decode HashMapFromSelf with Effect-TS Schema

Source: https://effect.website/docs/schema/effect-data-types

This snippet demonstrates Schema.HashMapFromSelf for direct HashMap transformations. It decodes a HashMap of stringified numbers into a HashMap of actual numbers and encodes vice-versa. The examples display the resulting HashMaps after decoding and encoding operations.

```typescript
import { Schema } from "effect"
import { HashMap } from "effect"

const schema = Schema.HashMapFromSelf({
  key: Schema.String,
  value: Schema.NumberFromString
})

// ┌─── HashMap
// ▼
type Encoded = typeof schema.Encoded

// ┌─── HashMap
// ▼
type Type = typeof schema.Type

const decode = Schema.decodeUnknownSync(schema)
const encode = Schema.encodeSync(schema)

// Decoding examples

console.log(
  decode(
    HashMap.fromIterable([
      ["a", "2"],
      ["b", "2"],
      ["c", "3"]
    ])
  )
)
// Output: { _id: 'HashMap', values: [ [ 'a', 2 ], [ 'c', 3 ], [ 'b', 2 ] ] }

// Encoding examples

console.log(
  encode(
    HashMap.fromIterable([
      ["a", 1],
      ["b", 2],
      ["c", 3]
    ])
  )
)
// Output: { _id: 'HashMap', values: [ [ 'a', 1 ], [ 'c', 3 ], [ 'b', 2 ] ] }
```

--------------------------------

### Effect.js: Closing a Scope with Pending Tasks

Source: https://effect.website/docs/resource-management/scope

Demonstrates that closing a scope in Effect.js does not interrupt tasks within that scope that are still pending. The example shows a task with a sleep duration and a finalizer, where the task and its finalizer execute even after the scope has been closed.

```typescript
import { Console, Effect, Exit, Scope } from "effect"

const task = Effect.gen(function* () {
  yield* Effect.sleep("1 second")
  console.log("Executed")
  yield* Effect.addFinalizer(() => Console.log("Task Finalizer"))
})

const program = Effect.gen(function* () {
  const scope = yield* Scope.make()

  // Close the scope immediately
  yield* Scope.close(scope, Exit.void)
  console.log("Scope closed")

  // This task will be executed even if the scope is closed
  yield* task.pipe(Scope.extend(scope))
})

Effect.runPromise(program)
/* 
Output:
Scope closed
Executed <-- after 1 second
Task Finalizer 
*/
```

--------------------------------

### Effect.gen Error Handling with Effect.fail (TypeScript)

Source: https://effect.website/docs/getting-started/using-generators

Shows how to introduce errors into an Effect.gen workflow using `Effect.fail`. This example executes two console logging tasks and then intentionally fails the program with a custom error message, demonstrating immediate error propagation.

```typescript
import { Effect, Console } from "effect"

const task1 = Console.log("task1...")
const task2 = Console.log("task2...")

const program = Effect.gen(function* () {
  // Perform some tasks
  yield* task1
  yield* task2
  // Introduce an error
  yield* Effect.fail("Something went wrong!")
})

Effect.runPromise(program).then(console.log, console.error)
```

--------------------------------

### Log Multiple Messages with Effect.js

Source: https://effect.website/docs/observability/logging

Shows how to log multiple string messages simultaneously using `Effect.log`. All provided messages are appended to the log entry with their respective keys.

```typescript
import { Effect } from "effect"

const program = Effect.log("message1", "message2", "message3")

Effect.runFork(program)
/* 
Output:
timestamp=... level=INFO fiber=#0 message=message1 message=message2 message=message3 
*/
```

--------------------------------

### Effect Caching with Time-to-Live (TTL) in Effect.js

Source: https://effect.website/docs/caching/caching-effects

Explains how to use Effect.cachedWithTTL to cache an effect's result for a specific duration. After the TTL expires, the effect is recomputed on the next evaluation. This example shows caching for 150 milliseconds and recomputation after expiration.

```typescript
import { Effect, Console } from "effect"

let i = 1

// Simulating an expensive task with a delay
const expensiveTask = Effect.promise(() => {
  console.log("expensive task...")
  return new Promise((resolve) => {
    setTimeout(() => {
      resolve(`result ${i++}`)
    }, 100)
  })
})

const program = Effect.gen(function* () {
  // Caches the result for 150 milliseconds
  const cached = yield* Effect.cachedWithTTL(expensiveTask, "150 millis")

  // First evaluation triggers the task
  yield* cached.pipe(Effect.andThen(Console.log))

  // Second evaluation returns the cached result
  yield* cached.pipe(Effect.andThen(Console.log))

  // Wait for 100 milliseconds, ensuring the cache expires
  yield* Effect.sleep("100 millis")

  // Recomputes the task after cache expiration
  yield* cached.pipe(Effect.andThen(Console.log))
})

Effect.runFork(program)
```

--------------------------------

### Effect-TS: Interleaving Streams with 'Stream.merge'

Source: https://effect.website/docs/stream/operations

Shows how to combine elements from two streams into a single stream using `Stream.merge`. This operation interleaves elements as they become available, unlike `Stream.concat` which waits for the first stream to complete. The example demonstrates merging two streams with different emission intervals.

```typescript
import { Schedule, Stream, Effect } from "effect"

// Create two streams with different emission intervals
const s1 = Stream.make(1, 2, 3).pipe(
  Stream.schedule(Schedule.spaced("100 millis"))
)
const s2 = Stream.make(4, 5, 6).pipe(
  Stream.schedule(Schedule.spaced("200 millis"))
)

// Merge s1 and s2 into a single stream that interleaves their values
const merged = Stream.merge(s1, s2)

Effect.runPromise(Stream.runCollect(merged)).then(console.log)
```

--------------------------------

### Configure OpenAI Client with NodeHttpClient (TypeScript)

Source: https://effect.website/docs/ai/planning-llm-interactions

Sets up the OpenAI client, similar to the Anthropic client. It retrieves the API key from a redacted environment variable and configures it to use the Node.js Undici HTTP client for making API calls.

```typescript
const OpenAi = OpenAiClient.layerConfig({
  apiKey: Config.redacted("OPENAI_API_KEY")
}).pipe(Layer.provide(NodeHttpClient.layerUndici))
```

--------------------------------

### Repeat Stream Content using Effect TS

Source: https://effect.website/docs/stream/creating

Constructs a new stream that repeats the content of a given stream according to a specified schedule. This enables the creation of recurring events or values based on a defined pattern. The example uses `Schedule.forever` to repeat indefinitely.

```typescript
import { Stream, Effect, Schedule } from "effect"

// Creating a stream that repeats a value indefinitely
const stream = Stream.repeat(Stream.succeed(1), Schedule.forever)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(
  console.log
)
// { _id: 'Chunk', values: [ 1, 1, 1, 1, 1 ] }
```

--------------------------------

### Temporarily Overriding ConfigProvider Service with Effect.withConfigProviderScoped - Effect.js

Source: https://effect.website/docs/requirements-management/default-services

This example demonstrates temporarily overriding the ConfigProvider service within a scope using `Effect.withConfigProviderScoped`. This ensures that a specific configuration is used only within the designated scope, and the original ConfigProvider is restored upon exiting the scope, preventing unintended side effects.

```typescript
import { Effect, Clock, Console, ConfigProvider } from "effect"

// Assume customConfigProvider is an implementation of the ConfigProvider service
// const customConfigProvider = ConfigProvider.fromMap(new Map([['key', 'value']]));

const program = Effect.gen(function* () {
  const config = yield* ConfigProvider.get("key")
  yield* Console.log(`Configuration value: ${config}`)
})

// Effect.withConfigProviderScoped(customConfigProvider)(program)
```

--------------------------------

### Generate Arbitrary Data from Effect Schema

Source: https://effect.website/docs/schema/arbitrary

This snippet demonstrates how to use `Arbitrary.make` to create an `Arbitrary` instance from an Effect `Schema` and then generate random samples using `fast-check.sample`. It defines a `Person` schema with constraints on `name` and `age` and shows example output.

```typescript
import { Arbitrary, FastCheck, Schema } from "effect"

// Define a Person schema with constraints
const Person = Schema.Struct({
  name: Schema.NonEmptyString,
  age: Schema.Int.pipe(Schema.between(1, 80))
})

// Create an Arbitrary based on the schema
const arb = Arbitrary.make(Person)

// Generate random samples from the Arbitrary
console.log(FastCheck.sample(arb, 2))
/*
Example Output:
[ { name: 'q r', age: 3 }, { name: '&|', age: 6 } ]
*/
```

--------------------------------

### PlatformLogger.toFile

Source: https://effect.website/docs/platform/platformlogger

Creates a new logger from an existing string-based logger, writing its output to the specified file. It supports optional batching with `batchWindow`.

```APIDOC
## PlatformLogger.toFile

### Description
Creates a new logger from an existing string-based logger, writing its output to the specified file. If a `batchWindow` duration is provided, logs are batched before writing, which can reduce overhead. Without `batchWindow`, logs are written as they arrive. This function returns an `Effect` that may fail with a `PlatformError` if the file cannot be opened or written to.

### Method
Pipeable function (part of Effect's pipeable API)

### Endpoint
N/A (This is a library function, not a network endpoint)

### Parameters
#### Path Parameters
N/A

#### Query Parameters
N/A

#### Request Body
N/A

### Request Example
(Example for directing logs to a file)
```javascript
import { PlatformLogger } from "@effect/platform"
import { NodeFileSystem } from "@effect/platform-node"
import { Effect, Layer, Logger } from "effect"

// Create a string-based logger
const myStringLogger = Logger.logfmtLogger

// Apply toFile to write logs to "/tmp/log.txt"
const fileLogger = myStringLogger.pipe(
  PlatformLogger.toFile("/tmp/log.txt")
)

// Replace the default logger, providing NodeFileSystem
const LoggerLive = Logger.replaceScoped(
  Logger.defaultLogger,
  fileLogger
).pipe(Layer.provide(NodeFileSystem.layer))

const program = Effect.log("Hello")

// Run the program, writing logs to /tmp/log.txt
Effect.runFork(program.pipe(Effect.provide(LoggerLive)))
/*
Logs will be written to "/tmp/log.txt" in the logfmt format,
and won't appear on the console.
*/
```

(Example for directing logs to both a file and the console)
```javascript
import { PlatformLogger } from "@effect/platform"
import { NodeFileSystem } from "@effect/platform-node"
import { Effect, Layer, Logger } from "effect"

// Create a string-based logger for the file
const fileLogger = Logger.logfmtLogger.pipe(
  PlatformLogger.toFile("/tmp/app.log")
)

// Create a pretty logger for the console
const consoleLogger = Logger.prettyLogger

// Combine loggers: fileLogger for file output, consoleLogger for console
const combinedLogger = Logger.combine(fileLogger, consoleLogger)

// Provide FileSystem for file operations and replace the default logger
const LoggerLive = Logger.replaceScoped(
  Logger.defaultLogger,
  combinedLogger
).pipe(Layer.provide(NodeFileSystem.layer))

const program = Effect.all([
  Effect.log("This log goes to both file and console."),
  Effect.logError("This error goes to both file and console.")
])

// Run the program
Effect.runFork(program.pipe(Effect.provide(LoggerLive)))
/*
Logs will be written to "/tmp/app.log" in logfmt format
AND displayed on the console using the pretty format.
*/
```

### Response
#### Success Response (200)
N/A (This function returns an Effect that produces a Logger)

#### Response Example
N/A
```

--------------------------------

### Running Effects Synchronously with Micro.runSyncExit

Source: https://effect.website/docs/micro/effect-users

Demonstrates the synchronous execution of a 'Micro' effect using `Micro.runSyncExit`. It shows how the function returns a `MicroExit` object, indicating either success with a value or failure with a `MicroCause`.

```typescript
import { Micro } from "effect"

const result1 = Micro.runSyncExit(Micro.succeed(1))
console.log(result1)
/* 
Output:
{
  "_id": "MicroExit",
  "_tag": "Success",
  "value": 1
}
*/

const result2 = Micro.runSyncExit(Micro.fail("my error"))
console.log(result2)
/* 
Output:
{
  "_id": "MicroExit",
  "_tag": "Failure",
  "cause": {
    "_tag": "Fail",
    "traces": [],
    "name": "MicroCause.Fail",
    "error": "my error"
  }
}
*/
```

--------------------------------

### Reporting Multiple Validation Errors with Effect Schema

Source: https://effect.website/docs/schema/filters

Demonstrates how the Schema.filter API in Effect can report multiple validation issues simultaneously. This is beneficial for form validation where several checks might fail at once. The example defines a form with multiple fields and applies filters.

```typescript
import { Either, Schema, ParseResult } from "effect"

const Password = Schema.Trim.pipe(Schema.minLength(2))
const OptionalString = Schema.optional(Schema.String)

const MyForm = Schema.Struct({
  password: Password,
  confirm_password: Password,
  name: OptionalString,
  surname: OptionalString
}).pipe(
  Schema.filter
)
```

--------------------------------

### Do Simulation: Measure Elapsed Time with Effect.js

Source: https://effect.website/docs/code-style/do

This snippet demonstrates how to measure the elapsed time of an Effect using the Do Simulation pattern. It binds the start and end timestamps and calculates the difference, logging it to the console. It requires the 'effect' library, specifically Effect and Console.

```typescript
import { Effect, Console } from "effect"

// Get the current timestamp
const now = Effect.sync(() => new Date().getTime())

const elapsed = (
  self: Effect.Effect
): Effect.Effect =>
Effect.Do.pipe(
  Effect.bind("startMillis", () => now),
  Effect.bind("result", () => self),
  Effect.bind("endMillis", () => now),
  Effect.let(
    "elapsed",
    // Calculate the elapsed time in milliseconds
    ({ startMillis, endMillis }) => endMillis - startMillis
  ),
  // Log the elapsed time
  Effect.tap(({ elapsed }) => Console.log(`Elapsed: ${elapsed}`)),
  Effect.map(({ result }) => result)
)

// Simulates a successful computation with a delay of 200 milliseconds
const task = Effect.succeed("some task").pipe(Effect.delay("200 millis"))

const program = elapsed(task)

Effect.runPromise(program).then(console.log)
/* 
Output:
Elapsed: 204
some task 
*/
```

--------------------------------

### Generate JSON Schema from Effect Struct

Source: https://effect.website/docs/schema/json-schema

This example demonstrates how to create a JSON Schema from an Effect Schema representing a 'Person' struct. The `JSONSchema.make` function takes the struct schema and generates a corresponding JSON Schema object. The output is then stringified for display.

```typescript
import { JSONSchema, Schema } from "effect"

const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

const jsonSchema = JSONSchema.make(Person)

console.log(JSON.stringify(jsonSchema, null, 2))
```

--------------------------------

### Create a Counter Metric in Effect-TS

Source: https://effect.website/docs/observability/metrics

Demonstrates the creation of a basic counter metric using `Metric.counter`. This metric can track cumulative numerical changes over time. It requires the 'effect' library and accepts a name and an optional description.

```typescript
import { Metric, Effect } from "effect"

const requestCount = Metric.counter("request_count", {
  // Optional
  description: "A counter for tracking requests"
})
```

--------------------------------

### Applying Filters to Schema Constraints for Arbitrary Generation

Source: https://effect.website/docs/schema/arbitrary

This example shows how Effect translates schema constraints, like `Schema.between`, into corresponding `fast-check` primitives. For instance, `Schema.Int.pipe(Schema.between(1, 80))` is mapped to `FastCheck.integer({ min: 1, max: 80 })` during arbitrary generation.

```typescript
import { Schema, FastCheck } from "effect"

// Schema with a numerical constraint
const constrainedInt = Schema.Int.pipe(Schema.between(1, 80))

// When Arbitrary.make is used with this schema, it will utilize:
// FastCheck.integer({ min: 1, max: 80 })

// Example of generating a value using the underlying primitive:
const arbInt = Arbitrary.make(constrainedInt)
console.log(FastCheck.sample(arbInt, 1))
```

--------------------------------

### Effect Schema: Validate Class Instance Fields

Source: https://effect.website/docs/schema/basic-usage

This example shows how to validate the fields of a class instance using Effect's Schema. It combines instance validation with additional checks on the instance's fields using `Schema.filter` and `ParseResult.validateEither` to ensure specific field constraints are met.

```typescript
import { Either, ParseResult, Schema } from "effect"

class MyData {
  constructor(readonly name: string) {}
}

const MyDataFields = Schema.Struct({
  name: Schema.NonEmptyString
})

const MyDataSchema = Schema.instanceOf(MyData).pipe(
  Schema.filter((a, options) => 
    ParseResult.validateEither(MyDataFields)(a, options).pipe(
      Either.flip,
      Either.getOrUndefined
    )
  )
)

// Example: Valid instance
console.log(Schema.validateSync(MyDataSchema)(new MyData("John")))
// Output: MyData { name: 'John' }

// Example: Invalid instance (empty name)
console.log(Schema.validateSync(MyDataSchema)(new MyData("")))
/* 
throws:
ParseError: { MyData | filter }
└─ Predicate refinement failure
└─ { readonly name: NonEmptyString }
└─ ["name"]
└─ NonEmptyString
└─ Predicate refinement failure
└─ Expected a non empty string, actual ""
*/
```

--------------------------------

### Customize Error Handling with parseOptions in Effect Schema

Source: https://effect.website/docs/schema/getting-started

Demonstrates how to use parseOptions within schema annotations to control error reporting. This allows for granular control over whether the first or all errors are reported for a given schema or sub-schema. The example shows a main schema configured for 'all' errors and a nested schema configured for 'first' errors.

```typescript
import { Schema } from "effect"
import { Either } from "effect"

const schema = Schema.Struct({
  a: Schema.Struct({
    b: Schema.String,
    c: Schema.String
  }).annotations({
    title: "first error only",
    // Limit errors to the first in this sub-schema
    parseOptions: { errors: "first" }
  }),
  d: Schema.String
}).annotations({
  title: "all errors",
  // Capture all errors for the main schema
  parseOptions: { errors: "all" }
})

// Decode input with custom error-handling behavior
const result = Schema.decodeUnknownEither(schema)(
  {
    a: {}
  },
  {
    errors: "first"
  }
)

if (Either.isLeft(result)) {
  console.log(result.left.message)
}
/* 
all errors 
├─ ["a"]
│ └─ first error only
│ └─ ["b"]
│ └─ is missing
└─ ["d"]
└─ is missing
*/
```

--------------------------------

### Stream.ensuring for Post-Finalization Actions (TypeScript)

Source: https://effect.website/docs/stream/resourceful-streams

Illustrates the use of Stream.ensuring to execute actions after a stream has been finalized. This operator is useful for performing secondary tasks that should run once the primary stream and its finalizers have completed. The example shows application logic, finalization, and then post-finalization work.

```typescript
import { Stream, Console, Effect } from "effect"

const program = Stream.fromEffect(Console.log("Application Logic.")).pipe(
  Stream.concat(Stream.finalizer(Console.log("Finalizing the stream"))),
  Stream.ensuring(
    Console.log("Doing some other works after stream's finalization")
  )
)

Effect.runPromise(Stream.runCollect(program)).then(console.log)
```

--------------------------------

### Import Micro Module from Effect

Source: https://effect.website/docs/micro/new-users

Demonstrates two ways to import the Micro module from the Effect library: a named import and a namespace import. Both methods provide access to Micro functionalities.

```typescript
import { Micro } from "effect"

```

```typescript
import * as Micro from "effect/Micro"

```

--------------------------------

### TypeScript: Demonstrate Short-Circuiting Behavior in Effect

Source: https://effect.website/docs/error-management/expected-errors

This example illustrates the short-circuiting behavior of Effect.js when errors occur in sequential operations. It defines three tasks, where the second task is designed to fail. The code shows that subsequent tasks are skipped when an error is encountered, and the error is propagated.

```typescript
import { Effect, Console } from "effect"

const task1 = Console.log("Executing task1...")
const task2 = Effect.fail("Something went wrong!")
const task3 = Console.log("Executing task3...")

const program = Effect.gen(function* () {
  yield* task1
  yield* task2
  yield* task3
})

Effect.runPromiseExit(program).then(console.log)
/* 
Output:
Executing task1...
{ 
  _id: 'Exit', 
  _tag: 'Failure', 
  cause: { _id: 'Cause', _tag: 'Fail', failure: 'Something went wrong!' } 
}
*/
```

--------------------------------

### Define Optional Number Field in Effect Schema

Source: https://effect.website/docs/schema/advanced-usage

This code defines a Product schema with an optional 'quantity' field using Schema.optional. It illustrates decoding and encoding examples for cases where the quantity is provided, omitted, or set to undefined.

```typescript
import { Schema } from "effect"

const Product = Schema.Struct({
  quantity: Schema.optional(Schema.NumberFromString)
})

// Decoding examples
console.log(Schema.decodeUnknownSync(Product)({" quantity": "1" }))
// Output: { quantity: 1 }
console.log(Schema.decodeUnknownSync(Product)({}))
// Output: {}
console.log(Schema.decodeUnknownSync(Product)({" quantity": undefined }))
// Output: { quantity: undefined }

// Encoding examples
console.log(Schema.encodeSync(Product)({" quantity": 1 }))
// Output: { quantity: "1" }
console.log(Schema.encodeSync(Product)({}))
// Output: {}
console.log(Schema.encodeSync(Product)({" quantity": undefined }))
// Output: { quantity: undefined }
```

--------------------------------

### Temporarily Overriding Console Service with Effect.withConsoleScoped - Effect.js

Source: https://effect.website/docs/requirements-management/default-services

This example shows how to temporarily override the Console service within a defined scope using `Effect.withConsoleScoped`. This is beneficial for isolating console interactions during tests or specific operational contexts, ensuring the original Console service is reinstated afterward.

```typescript
import { Effect, Clock, Console } from "effect"

// Assume customConsole is an implementation of the Console service
// const customConsole = { log: (message: string) => Effect.unit };

const program = Effect.gen(function* () {
  const now = yield* Clock.currentTimeMillis
  yield* Console.log(`Application started at ${new Date(now)}`)
})

// Effect.withConsoleScoped(customConsole)(program)
```

--------------------------------

### Create Effect Request with Context-Aware Resolver

Source: https://effect.website/docs/batching

Shows how to create an Effect.request that requires the HttpService context, using a resolver that has been explicitly configured to depend on it. The resulting Effect type reflects the dependency on HttpService and the minimal context required by the resolver.

```typescript
const getTodos: Effect.Effect<Array<Todo>, GetTodosError | GetUserError | SendEmailError, HttpService> = Effect.request(GetTodos({}), GetTodosResolver)
```

--------------------------------

### Define and Use PositiveInt Type (TypeScript)

Source: https://effect.website/docs/code-style/branded-types

This snippet defines a custom type `PositiveInt` using `Brand.Brand.FromConstructor`. It illustrates how to create instances of this type with valid positive integers and shows examples that would throw errors for negative or non-integer values.

```typescript
import { Brand } from 'effect/Brand'

type PositiveInt = Brand.Brand<number, 'PositiveInt'>

const PositiveInt = Brand.fromConstructor<PositiveInt>(
  (n: number) => {
    if (n <= 0) {
      throw new Error(`Expected ${n} to be positive`)
    }
    if (!Number.isInteger(n)) {
      throw new Error(`Expected ${n} to be an integer`)
    }
    return n
  }
)

// Usage example

// Valid positive integer
const good: PositiveInt = PositiveInt(10)

// throws [ { message: 'Expected -5 to be positive' } ]
// const bad1: PositiveInt = PositiveInt(-5)

// throws [ { message: 'Expected 3.14 to be an integer' } ]
// const bad2: PositiveInt = PositiveInt(3.14)
```

--------------------------------

### Convert Configuration Keys to Constant Case (Effect-TS)

Source: https://effect.website/docs/configuration

Demonstrates the use of ConfigProvider.constantCase to transform configuration keys into uppercase with underscores. This is helpful for aligning configuration keys with environment variable naming conventions.

```typescript
import { Config, ConfigProvider, Effect } from "effect"

const program = Effect.gen(function* () {
  const port = yield* Config.number("Port") // Reads PORT
  const host = yield* Config.string("Host") // Reads HOST
  console.log(`Application started: ${host}:${port}`)
})

Effect.runPromise(
  Effect.withConfigProvider(
    program,
    ConfigProvider.fromEnv().pipe(
      ConfigProvider.constantCase()
    )
  )
)
```

--------------------------------

### Declare File Schema for Arbitrary Generation (TypeScript)

Source: https://effect.website/docs/schema/advanced-usage

Shows an example of declaring a schema for the `File` type intended for use with the `Arbitrary` compiler. This requires an `arbitrary` annotation, which is missing in this snippet, leading to an error. This highlights the need for compiler-specific annotations when defining custom schemas.

```typescript
import { Arbitrary, Schema } from "effect"

// Define a schema for the File type
const FileFromSelf = Schema.declare(
  (input: unknown): input is File => input instanceof File,
  {
    identifier: "FileFromSelf"
  }
)

// Try creating an Arbitrary instance for the schema
const arb = Arbitrary.make(FileFromSelf)
/*
throws:
Error: Missing annotation 
       details: Generating an Arbitrary for this schema requires an "arbitrary" ann
```

--------------------------------

### Async/Await Equivalence: Promise vs. Effect.gen

Source: https://effect.website/docs/additional-resources/effect-vs-promise

Compares the syntax and flow of Promise-based async/await with Effect.gen. While syntactically similar, Effect provides static error and context tracking.

```javascript
const increment = (x: number) => x + 1

const divide = (a: number, b: number): Promise => 
  b === 0 
  ? Promise.reject(new Error("Cannot divide by zero")) 
  : Promise.resolve(a / b)

const task1 = Promise.resolve(10)
const task2 = Promise.resolve(2)

const program = async function () {
  const a = await task1
  const b = await task2
  const n1 = await divide(a, b)
  const n2 = increment(n1)
  return `Result is: ${n2}`
}

program().then(console.log) // Output: "Result is: 6"
```

```typescript
import { Effect } from "effect"

const increment = (x: number) => x + 1

const divide = (a: number, b: number): Effect.Effect => 
  b === 0 
  ? Effect.fail(new Error("Cannot divide by zero")) 
  : Effect.succeed(a / b)

const task1 = Effect.promise(() => Promise.resolve(10))
const task2 = Effect.promise(() => Promise.resolve(2))

const program = Effect.gen(function* () {
  const a = yield* task1
  const b = yield* task2
  const n1 = yield* divide(a, b)
  const n2 = increment(n1)
  return `Result is: ${n2}`
})

Effect.runPromise(program).then(console.log)
// Output: "Result is: 6"
```

--------------------------------

### Create and Use an Assertion with Effect Schema

Source: https://effect.website/docs/schema/getting-started

Shows how to create an assertion function using Schema.asserts. This function validates an input against a schema and throws a detailed ParseError if the input does not conform. It's useful for runtime validation where non-conforming data should halt execution. The example defines a Person schema and uses Schema.asserts to create an `assertsPerson` function.

```typescript
import { Schema } from "effect"

// Define a schema for a Person object
const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

// Generate an assertion function from the schema
const assertsPerson: Schema.Schema.ToAsserts = Schema.asserts(Person)

try {
  // Attempt to assert that the input matches the Person schema
  assertsPerson({ name: "Alice", age: "30" })
} catch (e) {
  console.error("The input does not match the schema:")
  console.error(e)
}
/* 
throws:
The input does not match the schema:
{
  _id: 'ParseError',
  message: '{ readonly name: string; readonly age: number }\n' +
    '└─ ["age"]\n' +
    ' └─ Expected number, actual "30"'
}
*/

// This input matches the schema and will not throw an error
assertsPerson({ name: "Alice", age: 30 })
```

--------------------------------

### Dynamic Retry Delays with Retry-After Header using Effect.js

Source: https://effect.website/docs/scheduling/examples

This example demonstrates how to implement dynamic retry delays in Effect.js, particularly for handling '429 Too Many Requests' errors. It extracts the delay duration from a custom error's `retryAfter` property and uses it to configure the retry schedule, ensuring the application respects server-specified wait times.

```typescript
import { Duration, Effect, Schedule, Data } from "effect"

// Custom error class representing a "Too Many Requests" response
class TooManyRequestsError extends Data.TaggedError(
"TooManyRequestsError"
)<{ readonly retryAfter: number }> {}

let n = 1
const request = Effect.gen(function* () {
// Simulate failing a particular number of times
if (n < 3) {
const retryAfter = n * 500
console.log(`Attempt #${n++}, retry after ${retryAfter} millis...`)
// Simulate retrieving the retry-after header
return yield* Effect.fail(new TooManyRequestsError({ retryAfter }))
}
console.log("Done")
return "some result"
})

// Retry policy that extracts the retry delay from the error
const policy = Schedule.identity().pipe(
Schedule.addDelay((error) =>
error._tag === "TooManyRequestsError"
? // Wait for the specified retry-after duration
Duration.millis(error.retryAfter)
: Duration.zero
),
// Limit retries to 5 attempts
Schedule.intersect(Schedule.recurs(5))
)

const program = request.pipe(Effect.retry(policy))

Effect.runFork(program)
/* 
Output:
Attempt #1, retry after 500 millis...
Attempt #2, retry after 1000 millis...
Done 
*/
```

--------------------------------

### Load Config from Environment Variables with Custom Delimiters (Effect-TS)

Source: https://effect.website/docs/configuration

Shows how to configure ConfigProvider.fromEnv to use custom path and sequence delimiters for reading environment variables. This is essential when environment variable naming conventions differ from the defaults.

```typescript
import { Config, ConfigProvider, Effect } from "effect"

const program = Effect.gen(function* () {
  // Read SERVER_HOST and SERVER_PORT as nested configuration values
  const port = yield* Config.nested(Config.number("PORT"), "SERVER")
  const host = yield* Config.nested(Config.string("HOST"), "SERVER")
  console.log(`Application started: ${host}:${port}`)
})

Effect.runPromise(
  Effect.withConfigProvider(
    program,
    // Custom delimiters
    ConfigProvider.fromEnv({ pathDelim: "__", seqDelim: "|" })
  )
)
```

--------------------------------

### Handling Nested Configuration Values with Mocking (Effect-TS)

Source: https://effect.website/docs/configuration

Shows how to provide nested configuration values using ConfigProvider.fromMap with a dot notation separator. Useful for testing applications with nested configurations.

```typescript
import { Config, ConfigProvider, Effect } from "effect"

const config = Config.nested(Config.number("PORT"), "SERVER")

const program = Effect.gen(function* () {
  const port = yield* config
  console.log(`Server is running on port ${port}`)
})

// Mock configuration using '.' as the separator for nested keys
const mockConfigProvider = ConfigProvider.fromMap(
  new Map([["SERVER.PORT", "8080"]])
)

Effect.runPromise(Effect.withConfigProvider(program, mockConfigProvider))
```

--------------------------------

### Clamp Number within Range using Schema.transform (Strict with Type Assertion)

Source: https://effect.website/docs/schema/transformations

This example demonstrates clamping a number within a specified range using Schema.transform with strict type checking. To resolve the potential type mismatch issue where the clamped number might not strictly conform to the original type, a type assertion `as A` is used in the decode function. The encode function returns the value unchanged.

```typescript
import { Schema, Number } from "effect"

const clamp = <A extends number>( 
  minimum: number,
  maximum: number
) =>
(self: Schema.Schema<A, A>) =>
  Schema.transform<A, number>(
    // Source schema
    self,
    // Target schema: filter based on min/max range
    self.pipe(
      Schema.typeSchema,
      Schema.filter((a) => a <= minimum || a >= maximum)
    ),
    {
      strict: true,
      // Clamp the number within the specified range and assert type
      decode: (a) => Number.clamp(a, { minimum, maximum }) as A,
      encode: (a) => a
    }
  )
```

--------------------------------

### Merging JSON Schema Annotations from Multiple Refinements in Effect

Source: https://effect.website/docs/schema/json-schema

Illustrates how to combine JSON Schema annotations from multiple `Schema.filter` refinements in Effect. Each refinement can add its own `jsonSchema` fragment, which are then merged into the final generated schema. This example shows merging `minimum` and `maximum` constraints.

```typescript
import { JSONSchema, Schema } from "effect"

// Define a schema with a refinement for positive numbers
const Positive = Schema.Number.pipe(
  Schema.filter((n) => n > 0, {
    jsonSchema: { minimum: 0 }
  })
)

// Add an upper bound refinement to the schema
const schema = Positive.pipe(
  Schema.filter((n) => n <= 10, {
    jsonSchema: { maximum: 10 }
  })
)

const jsonSchema = JSONSchema.make(schema)

console.log(JSON.stringify(jsonSchema, null, 2))
```

--------------------------------

### Combine Multiple Branded Types (TypeScript)

Source: https://effect.website/docs/code-style/branded-types

This example demonstrates how to combine multiple branded types using `Brand.all` in Effect-TS. It defines `Int` and `Positive` branded types and then uses `Brand.all` to create a new constructor `PositiveInt` that enforces both integer and positive value constraints.

```typescript
import { Brand } from "effect"

type Int = number & Brand.Brand<"Int">

const Int = Brand.refined<number, "Int">( 
  (n) => Number.isInteger(n),
  (n) => Brand.error(`Expected ${n} to be an integer`)
)

type Positive = number & Brand.Brand<"Positive">

const Positive = Brand.refined<number, "Positive">( 
  (n) => n > 0,
  (n) => Brand.error(`Expected ${n} to be positive`)
)

// Combine the Int and Positive constructors 
// into a new branded constructor PositiveInt
const PositiveInt = Brand.all(Int, Positive)

// Extract the branded type from the PositiveInt constructor
type PositiveIntType = Brand.TypeOf<typeof PositiveInt>;

// Example usage:
// const validPositiveInt: PositiveIntType = PositiveInt(5);
// const invalidPositiveInt: PositiveIntType = PositiveInt(-2);
// const invalidFloat: PositiveIntType = PositiveInt(3.14);

```

--------------------------------

### Handle Full Queue with Effect.fork (TypeScript)

Source: https://effect.website/docs/concurrency/queue

Demonstrates handling a full queue by forking the `Queue.offer` operation. This prevents blocking the main fiber when the queue is at capacity.

```typescript
import { Effect, Queue, Fiber } from "effect"

const program = Effect.gen(function* () {
  const queue = yield* Queue.bounded(1)
  // Fill the queue with one item
  yield* Queue.offer(queue, 1)
  // Attempting to add a second item will suspend as the queue is full
  const fiber = yield* Effect.fork(Queue.offer(queue, 2))
  // Empties the queue to make space
  yield* Queue.take(queue)
  // Joins the fiber, completing the suspended offer
  yield* Fiber.join(fiber)
  // Returns the size of the queue after additions
  return yield* Queue.size(queue)
})

Effect.runPromise(program).then(console.log)
// Output: 1
```

--------------------------------

### Type Safety with Branded Identifiers (TypeScript)

Source: https://effect.website/docs/code-style/branded-types

This example illustrates the type safety provided by branded identifiers in TypeScript. It shows how attempting to assign a raw number or a `UserId` to a `ProductId` parameter results in a compile-time error, enforcing correct usage and preventing bugs.

```typescript
import { Brand } from "effect"

type UserId = number & Brand.Brand<"UserId">
const UserId = Brand.nominal<number, "UserId">()

const getUserById = (id: UserId) => {
  // Logic to retrieve user
}

type ProductId = number & Brand.Brand<"ProductId">
const ProductId = Brand.nominal<number, "ProductId">()

const getProductById = (id: ProductId) => {
  // Logic to retrieve product
}

// Correct usage
getProductById(ProductId(1))

// Incorrect, will result in an error
// getProductById(1)
// Error ts(2345) ― Argument of type 'number' is not assignable to parameter of type 'ProductId'.

// Also incorrect, will result in an error
// getProductById(UserId(1))
// Error ts(2345) ― Argument of type 'UserId' is not assignable to parameter of type 'ProductId'.

```

--------------------------------

### Daemon Fiber with Effect.forkDaemon in Effect.js

Source: https://effect.website/docs/concurrency/fibers

Demonstrates creating a daemon fiber using `Effect.forkDaemon`. This fiber runs in the global scope, independent of its parent, and continues execution until it completes naturally or the application terminates.

```typescript
// Example for Effect.forkDaemon would go here, demonstrating a long-running background task.
```

--------------------------------

### Run Finalizer in All Outcomes with Effect.ensuring

Source: https://effect.website/docs/resource-management/introduction

Demonstrates how `Effect.ensuring` guarantees a finalizer effect runs regardless of whether the main effect succeeds, fails, or is interrupted. This is crucial for ensuring cleanup actions like closing file handles or logging messages are always executed. The examples cover successful, failing, and interrupted scenarios.

```typescript
import { Console, Effect } from "effect"

// Define a cleanup effect
const handler = Effect.ensuring(Console.log("Cleanup completed"))

// Define a successful effect
const success = Console.log("Task completed").pipe(
    Effect.as("some result"),
    handler
)

Effect.runFork(success)
/*
Output:
Task completed
Cleanup completed
*/

// Define a failing effect
const failure = Console.log("Task failed").pipe(
    Effect.andThen(Effect.fail("some error")),
    handler
)

Effect.runFork(failure)
/*
Output:
Task failed
Cleanup completed
*/

// Define an interrupted effect
const interruption = Console.log("Task interrupted").pipe(
    Effect.andThen(Effect.interrupt),
    handler
)

Effect.runFork(interruption)
/*
Output:
Task interrupted

```

--------------------------------

### Recover from Specific Errors with Effect.catchIf (TypeScript < 5.5)

Source: https://effect.website/docs/error-management/expected-errors

Effect.catchIf allows recovery from errors based on a predicate function. This example demonstrates catching a specific HttpError using a predicate. Note that for TypeScript versions prior to 5.5, the error type is not altered by default.

```typescript
import { Data, Effect, Random } from "effect"

class HttpError extends Data.TaggedError("HttpError")<{}>

class ValidationError extends Data.TaggedError("ValidationError")<{}>

const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    return yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    return yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

const recovered = program.pipe(
  Effect.catchIf(
    // Only handle HttpError errors
    (error) => error._tag === "HttpError",
    () => Effect.succeed("Recovering from HttpError")
  )
)

// const recovered: Effect

```

--------------------------------

### Enforcing Type Safety with Branded Types in TypeScript

Source: https://effect.website/docs/code-style/branded-types

This example illustrates the type safety provided by branded types. It shows that a function expecting a `ProductId` will reject a plain `number` (or a `UserId` without the correct brand), as indicated by the TypeScript compile-time error.

```typescript
const BrandTypeId: unique symbol = Symbol.for("effect/Brand")

type ProductId = number & {
  readonly [BrandTypeId]: {
    readonly ProductId: "ProductId"
  }
}

const getProductById = (id: ProductId) => {
  // Logic to retrieve product
}

type UserId = number

const id: UserId = 1

getProductById(id)
// Error ts(2345) ― Argument of type 'number' is not assignable to parameter of type 'ProductId'.
// Type 'number' is not assignable to type '{ readonly [BrandTypeId]: { readonly ProductId: "ProductId"; }; }'.
// Type 'number' is not assignable to type '{ readonly [BrandTypeId]: { readonly ProductId: "ProductId"; }; }'.
```

--------------------------------

### Handle Various Error Types with Effect Micro

Source: https://effect.website/docs/micro/new-users

Demonstrates how to use Micro.sandbox and catchTag to handle different error types (Fail, Interrupt, Die) in an Effect, providing fallback results for each. It logs specific error details based on the caught error type.

```typescript
import { Micro } from "effect"

// Helper function to log a message
const log = (message: string) => Micro.sync(() => console.log(message))

// ┌─── Micro
// ▼
const task = Micro.fail(new Error("Oh uh!")).pipe(
  Micro.as("primary result")
)

// ┌─── Effect, never>
// ▼
const sandboxed = Micro.sandbox(task)

const program = sandboxed.pipe(
  Micro.catchTag("Fail", (cause) =>
    log(`Caught a defect: ${cause.error}`).pipe(
      Micro.as("fallback result on expected error")
    )
  ),
  Micro.catchTag("Interrupt", () =>
    log(`Caught a defect`).pipe(
      Micro.as("fallback result on fiber interruption")
    )
  ),
  Micro.catchTag("Die", (cause) =>
    log(`Caught a defect: ${cause.defect}`).pipe(
      Micro.as("fallback result on unexpected error")
    )
  )
)

Micro.runPromise(program).then(console.log)
/* 
Output:
Caught a defect: Error: Oh uh!
fallback result on expected error 
*/
```

--------------------------------

### Platform: KeyValueStore Interface

Source: https://context7_llms

Details on the KeyValueStore interface provided by @effect/platform, enabling asynchronous and consistent storage for key-value pairs across different backends.

```typescript
import * as KeyValueStore from "@effect/platform/KeyValueStore"
import * as Effect from "@effect/io/Effect"

// Assume an in-memory implementation
const store: KeyValueStore.KeyValueStore<string, string> = KeyValueStore.inMemory()

const putEffect = store.put("mykey", "myvalue")
const getEffect = store.get("mykey")

Effect.runSync(Effect.zip(putEffect, getEffect)) // [void, Maybe<string>]
```

--------------------------------

### Create Schedule from Cron Expression

Source: https://effect.website/docs/scheduling/cron

Creates an Effect Schedule from a cron expression or a Cron instance using `Schedule.cron`. This schedule triggers at the beginning of each interval defined by the cron. When triggered, it yields a tuple `[start, end]` representing the interval's timestamp range in milliseconds.

```typescript
import {
  Effect,
  Schedule,
  TestClock,
  Fiber,
  TestContext,
  Cron,
  Console
} from "effect"

// A helper function to log output at each interval of the schedule
const log = (
  action: Effect.Effect,
  schedule: Schedule.Schedule<[number, number], void>
): void => {
  let i = 0

  Effect.gen(function*() {
    const fiber: Fiber.RuntimeFiber<[[number, number], number]> = yield* Effect.gen(function*() {
      yield* action
      i++
    }).pipe(
      Effect.repeat(
        schedule.pipe(
          // Limit the number of iterations for the example
          Schedule.intersect(
            // ... rest of the code for the helper function ...
          )
        )
      )
    )
    yield* Console.log(fiber.result)
  }).pipe(Effect.provide(TestContext))
}

// Example usage would go here, calling the log helper with a schedule created from a cron expression.
```

--------------------------------

### Create an ExecutionPlan for LLM Interactions

Source: https://effect.website/docs/ai/planning-llm-interactions

Demonstrates the creation of an ExecutionPlan using the ExecutionPlan.make constructor. This plan is designed to handle LLM interactions, including potential errors, retries, and fallback strategies, in a declarative manner.

```typescript
import type { LanguageModel } from "@effect/ai"
import { OpenAiLanguageModel } from "@effect/ai-openai"
import { Data, Effect, ExecutionPla
```

--------------------------------

### Effect.all for Combining Effects in TypeScript

Source: https://effect.website/docs/getting-started/building-pipelines

Demonstrates using Effect.all to run multiple effects concurrently or sequentially and combine their results into a single structure like a tuple or object. If any effect fails, Effect.all short-circuits and propagates the error.

```typescript
import { Effect } from "effect"

// Simulated function to read configuration from a file
const webConfig = Effect.promise(() => 
  Promise.resolve({ dbConnection: "localhost", port: 8080 })
)

// Simulated function to check database status
const checkDatabase = Effect.promise(() => 
  Promise.resolve(true)
)

// Combining configuration and database check effects
const combinedEffects = Effect.all([
  webConfig,
  checkDatabase
])

// If webConfig was an object and checkDatabase was another object, you could use Effect.all with an object structure too:
// const combinedEffectsObject = Effect.all({
//   config: webConfig,
//   dbStatus: checkDatabase
// })

```

--------------------------------

### Manual Memoization with Layer.memoize (Effect-TS)

Source: https://effect.website/docs/requirements-management/layer-memoization

Shows how to manually memoize a layer using `Layer.memoize`. This function returns a scoped effect that, when evaluated, provides the lazily computed result of the layer. The example demonstrates that even when the memoized layer is provided multiple times locally, the underlying effect is only executed once, as evidenced by the single log message.

```typescript
import { Effect, Context, Layer } from "effect"

class A extends Context.Tag("A")() {}

const ALive = Layer.effect(
  A,
  Effect.succeed({ a: 5 }).pipe(
    Effect.tap(() => Effect.log("initialized"))
  )
)

const program = Effect.scoped(
  Layer.memoize(ALive).pipe(
    Effect.andThen((memoized) =>
      Effect.gen(function* () {
        yield* Effect.provide(A, memoized)
        yield* Effect.provide(A, memoized)
      })
    )
  )
)

Effect.runPromise(program)
```

--------------------------------

### Zip Streams with Custom Logic for Uneven Lengths (EffectJS)

Source: https://effect.website/docs/stream/operations

Demonstrates `Stream.zipAllWith` for zipping streams with custom logic that defines how to handle elements when one stream is shorter than the other. This provides fine-grained control over combining elements in all scenarios.

```typescript
import { Stream, Effect } from "effect"

const stream = Stream.zipAllWith(Stream.make(1, 2, 3, 4, 5, 6), {
  other: Stream.make("a", "b", "c"),
  onSelf: (n) => [n, "x"],
  onOther: (s) => [-1, s],
  onBoth: (n, s) => [n + 10, s + "!"]
})

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
```

--------------------------------

### Run Concurrent Fibonacci Calculation with Fiber Monitoring

Source: https://effect.website/docs/observability/supervisor

Executes a concurrent Fibonacci calculation using Effect-TS fibers. It forks two fibers for recursive calls, joins them to get results, and logs the final Fibonacci number. A monitor function is used to log the number of active fibers at different stages, illustrating the dynamic nature of concurrency.

```typescript
import * as Effect from "@effect/io/Effect";
import * as Fiber from "@effect/io/Fiber";
import * as Supervisor from "@effect/io/Supervisor";

// Program to orchestrate the Fibonacci calculation and monitoring
const program = Effect.gen(function* () {
  // Create a supervisor to manage fibers
  const supervisor = yield* Supervisor.track();

  // Start a monitor fiber that periodically logs the number of active fibers
  const monitorFiber = yield* Effect.fork(monitorFibers(supervisor));

  // Start the Fibonacci calculation fiber, supervised
  const fibFiber = yield* Effect.fork(fib(40).pipe(Effect.supervised(supervisor)));

  // Join the monitor and Fibonacci fibers to ensure they complete
  yield* Fiber.join(monitorFiber);
  const result = yield* Fiber.join(fibFiber);

  console.log(`fibonacci result: ${result}`);
});

// Function to monitor and log the number of active fibers
const monitorFibers = (supervisor: Supervisor.Supervisor) =>
  Effect.gen(function* () {
    // Loop indefinitely to monitor fibers
    for (let i = 0; i < 10; i++) {
      const fibers = yield* supervisor.value; // Get the current set of fibers
      console.log(`number of fibers: ${fibers.length}`);
      yield* Effect.sleep("500 millis"); // Wait before checking again
    }
  });

// Recursive Fibonacci calculation, spawning fibers for each recursive step
const fib = (n: number): Effect.Effect<number> =>
  Effect.gen(function* () {
    if (n <= 1) {
      return 1;
    }
    yield* Effect.sleep("500 millis"); // Simulate work by delaying

    // Fork two fibers for the recursive Fibonacci calls
    const fiber1 = yield* Effect.fork(fib(n - 2));
    const fiber2 = yield* Effect.fork(fib(n - 1));

    // Join the fibers to retrieve their results
    const v1 = yield* Fiber.join(fiber1);
    const v2 = yield* Fiber.join(fiber2);

    return v1 + v2; // Combine the results
  });

// Run the program
Effect.runPromise(program);
```

--------------------------------

### Handling Specific Errors with Effect.either (Part 2)

Source: https://effect.website/docs/error-management/expected-errors

This example extends the previous one by demonstrating how to handle both `HttpError` and `ValidationError` using `Effect.either`. After capturing the result with `Effect.either`, both error types are explicitly handled, resulting in the error channel of the `recovered` effect becoming `never`, indicating all errors are managed.

```typescript
import { Effect, Random, Either, Data } from "effect"

class HttpError extends Data.TaggedError("HttpError")<{}> {}
class ValidationError extends Data.TaggedError("ValidationError")<{}> {}

const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next
  if (n1 < 0.5) {
    return yield* Effect.fail(new HttpError())
  }
  if (n2 < 0.5) {
    return yield* Effect.fail(new ValidationError())
  }
  return "some result"
})

const recovered = Effect.gen(function* () {
  const failureOrSuccess = yield* Effect.either(program)
  if (Either.isLeft(failureOrSuccess)) {
    const error = failureOrSuccess.left
    // Handle both HttpError and ValidationError
    if (error._tag === "HttpError") {
      return "Recovering from HttpError"
    } else {
      return "Recovering from ValidationError"
    }
  } else {
    return failureOrSuccess.right
  }
})
```

--------------------------------

### Tapping Layer Acquisition Success and Failure (TypeScript)

Source: https://effect.website/docs/requirements-management/layers

This snippet illustrates using Layer.tap and Layer.tapError to perform side effects during layer acquisition. It logs a success message with the context upon successful acquisition and an error message if acquisition fails, without altering the layer's signature.

```typescript
import { Config, Context, Effect, Layer, Console } from "effect"

class HTTPServer extends Context.Tag("HTTPServer")() {}

// Simulating an HTTP server
const server = Layer.effect(
  HTTPServer,
  Effect.gen(function* () {
    const host = yield* Config.string("HOST")
    console.log(`Listening on http://localhost:${host}`)
  })
).pipe(
  // Log a message if the layer acquisition succeeds
  Layer.tap((ctx) =>
    Console.log(`layer acquisition succeeded with:\n${ctx}`)
  ),
  // Log a message if the layer acquisition fails
  Layer.tapError((err) =>
    Console.log(`layer acquisition failed with:\n${err}`)
  )
)

Effect.runFork(Layer.launch(server))
```

--------------------------------

### Configure Combined Console and File Logging in Effect-TS

Source: https://effect.website/docs/platform/platformlogger

This snippet demonstrates how to create a logger that writes to both the console (using a pretty format) and a file (using logfmt format). It utilizes Effect-TS's Layer system to provide the configured logger to the program. Dependencies include 'effect' and 'node:fs'.

```typescript
import { Effect, Layer, Logger } from "effect"
import * as PlatformLogger from "@effect/platform/Logger"
import * as NodeFileSystem from "@effect/platform-node/FileSystem"

const fileLogger = Logger.logfmtLogger.pipe(
  PlatformLogger.toFile("/tmp/log.txt")
)

const bothLoggers = Effect.map(fileLogger, (fileLogger) =>
  Logger.zip(Logger.prettyLoggerDefault, fileLogger)
)

const LoggerLive = Logger.replaceScoped(
  Logger.defaultLogger,
  bothLoggers
).pipe(Layer.provide(NodeFileSystem.layer))

const program = Effect.log("Hello")

// Run the program, writing logs to both the console (pretty format)
// and "/tmp/log.txt" (logfmt)
Effect.runFork(program.pipe(Effect.provide(LoggerLive)))
```

--------------------------------

### Define HTTP Service and RequestResolver with Context

Source: https://effect.website/docs/batching

Sets up an HTTP service using Effect.Context.Tag and defines a RequestResolver for fetching todos. The resolver uses Effect.andThen to access the HttpService and Effect.tryPromise for making the actual fetch call. It specifies the HttpService as part of the resolver's context dependencies.

```typescript
1 import { Effect, Context, RequestResolver, Request, Data } from "effect"
2 
3 // ------------------------------ 
4 // Model 
5 // ------------------------------ 
6 
19 collapsed lines 
7 interface User {
8 readonly _tag: "User"
9 readonly id: number
10 readonly name: string
11 readonly email: string
12 }
13 
14 class GetUserError extends Data.TaggedError("GetUserError")<{}> {}
15 
16 interface Todo {
17 readonly _tag: "Todo"
18 readonly id: number
19 readonly message: string
20 readonly ownerId: number
21 }
22 
23 class GetTodosError extends Data.TaggedError("GetTodosError")<{}> {}
24 
25 class SendEmailError extends Data.TaggedError("SendEmailError")<{}> {}
26 
27 // ------------------------------ 
28 // Requests 
29 // ------------------------------ 
30 
29 collapsed lines 
31 // Define a request to get multiple Todo items which might
32 // fail with a GetTodosError
33 interface GetTodos extends Request.Request, GetTodosError> {
34 readonly _tag: "GetTodos"
35 }
36 
37 // Create a tagged constructor for GetTodos requests
38 const GetTodos = Request.tagged("GetTodos")
39 
40 // Define a request to fetch a User by ID which might
41 // fail with a GetUserError
42 interface GetUserById extends Request.Request {
43 readonly _tag: "GetUserById"
44 readonly id: number
45 }
46 
47 // Create a tagged constructor for GetUserById requests
48 const GetUserById = Request.tagged("GetUserById")
49 
50 // Define a request to send an email which might
51 // fail with a SendEmailError
52 interface SendEmail extends Request.Request {
53 readonly _tag: "SendEmail"
54 readonly address: string
55 readonly text: string
56 }
57 
58 // Create a tagged constructor for SendEmail requests
59 const SendEmail = Request.tagged("SendEmail")
60 
61 // ------------------------------ 
62 // Resolvers With Context 
63 // ------------------------------ 
64 
65 class HttpService extends Context.Tag("HttpService")< 
66 HttpService,
67 { fetch: typeof fetch }
68 >()
69 
70 const GetTodosResolver =
71 // we create a normal resolver like we did before
72 RequestResolver.fromEffect((_: GetTodos) =>
73 Effect.andThen(HttpService, (http) =>
74 Effect.tryPromise({
75 try: () =>
76 http
77 .fetch("https://api.example.demo/todos")
78 .then((res) => res.json() as Promise<Array<Todo>>),
79 catch: () => new GetTodosError()
80 })
81 )
82 ).pipe(
83 // we list the tags that the resolver can access
84 RequestResolver.contextFromServices(HttpService)
85 )
```

--------------------------------

### Create and Use a Type Guard with Effect Schema

Source: https://effect.website/docs/schema/getting-started

Illustrates how to generate a type guard function using Schema.is. This function can be used at runtime to check if an unknown value conforms to a defined schema, effectively acting as a type guard for TypeScript. The example defines a Person schema and then uses Schema.is to create an `isPerson` type guard.

```typescript
import { Schema } from "effect"

// Define a schema for a Person object
const Person = Schema.Struct({
  name: Schema.String,
  age: Schema.Number
})

// Generate a type guard from the schema
const isPerson = Schema.is(Person)

// Test the type guard with various inputs
console.log(isPerson({ name: "Alice", age: 30 }))
// Output: true

console.log(isPerson(null))
// Output: false

console.log(isPerson({}))
// Output: false
```

--------------------------------

### Customize JSON Schema for Unsupported Types (Effect-TS)

Source: https://effect.website/docs/schema/json-schema

This example demonstrates how to handle unsupported types like 'bigint' during JSON Schema generation with Effect-TS. When a type lacks native JSON Schema support, an error occurs. This snippet shows how to resolve this by providing a custom 'jsonSchema' annotation to define the desired representation.

```typescript
import { JSONSchema, Schema } from "effect"

const schema = Schema.Struct({
  // Adding a custom JSON Schema annotation for the `bigint` type
  a_bigint_field: Schema.BigIntFromSelf.annotations({
    jsonSchema: {
      type: "some cus"
```

--------------------------------

### Mock Cache Service Directly

Source: https://effect.website/docs/requirements-management/layers

Demonstrates mocking the `Cache` service directly instead of its dependencies. A new instance of `Cache` is created with a custom `lookup` implementation that returns a hardcoded string.

```typescript
import { FileSystem } from "@effect/platform"
import { NodeFileSystem } from "@effect/platform-node"
import { Effect, Console } from "effect"

// Define a Cache service
class Cache extends Effect.Service()("app/Cache", {
  effect: Effect.gen(function* () {
    const fs = yield* FileSystem.FileSystem
    const lookup = (key: string) => fs.readFileString(`cache/${key}`)
    return { lookup } as const
  }),
  dependencies: [NodeFileSystem.layer]
}) {}

// Accessing the Cache Service
const program = Effect.gen(function* () {
  const cache = yield* Cache
  const data = yield* cache.lookup("my-key")
  console.log(data)
}).pipe(Effect.catchAllCause((cause) => Console.log(cause)))

// Create a mock implementation of Cache
const cache = new Cache({
  lookup: () => Effect.succeed("Cache Content...")
})

// Provide the mock Cache service
const runnable = program.pipe(Effect.provideService(Cache, cache))

Effect.runFork(runnable)
// Output: Cache Content...
```

--------------------------------

### Run Micro Effect and Handle Results with Micro.runPromise

Source: https://effect.website/docs/micro/new-users

This code shows how to execute a Micro effect and handle its success or failure using Micro.runPromise. This function converts the Micro effect back into a standard JavaScript Promise, allowing for the use of familiar .then() and .catch() methods for asynchronous operations. It logs the weather data or any errors encountered during the fetch.

```typescript
import { Micro } from "effect"

// Simulate fetching weather data
function fetchWeather(city: string): Promise {
  return new Promise((resolve, reject) => {
    setTimeout(() => {
      if (city === "London") {
        resolve("Sunny")
      } else {
        reject(new Error("Weather data not found for this location"))
      }
    }, 1_000)
  })
}

function getWeather(city: string) {
  return Micro.promise(() => fetchWeather(city))
}

const weatherEffect = getWeather("London")

Micro.runPromise(weatherEffect)
  .then((data) => console.log(`The weather in London is: ${data}`))
  .catch((error) =>
    console.error(`Failed to fetch weather data: ${error.message}`)
  )
```

--------------------------------

### Server-Client Model with SubscriptionRef - Effect

Source: https://effect.website/docs/state-management/subscriptionref

Illustrates a server-client pattern using SubscriptionRef. The server continuously updates a shared Ref, while clients subscribe to the 'changes' stream of a SubscriptionRef to react to these updates. This showcases real-time state synchronization.

```typescript
import { Ref, Effect } from "effect"

// Server function that increments a shared value forever
const server = (ref: Ref.Ref) => 
  Ref.update(ref, (n) => n + 1).pipe(Effect.forever)
```

```typescript
import { Ref, Effect, Stream, Random } from "effect"

// Server function that increments a shared value forever
const server = (ref: Ref.Ref) => 
  Ref.update(ref, (n) => n + 1).pipe(Effect.forever)

// Client function that observes changes
```

--------------------------------

### Specifying Error Paths for Form Validation in Effect Schema

Source: https://effect.website/docs/schema/filters

Illustrates how to associate specific error messages with particular fields or paths when validating structured data, such as forms, using Effect's Schema.filter. This example ensures that password fields match and specifies the error path for the 'confirm_password' field.

```typescript
import { Either, Schema, ParseResult } from "effect"

const Password = Schema.Trim.pipe(Schema.minLength(2))

const MyForm = Schema.Struct({
  password: Password,
  confirm_password: Password
}).pipe(
  // Add a filter to ensure that passwords match
  Schema.filter((input) => {
    if (input.password !== input.confirm_password) {
      // Return an error message associated
      // with the "confirm_password" field
      return {
        path: ["confirm_password"],
        message: "Passwords do not match"
      }
    }
  })
)

console.log(
  JSON.stringify(
    Schema.decodeUnknownEither(MyForm)({
      password: "abc",
      confirm_password: "abd" // Confirm password does not match
    }).pipe(
      Either.mapLeft((error) =>
        ParseResult.ArrayFormatter.formatErrorSync(error)
      )
    ),
    null,
    2
  )
)
/*
"_id": "Either",
"_tag": "Left",
"left": [
  {
    "_tag": "Type",
    "path": [
      "confirm_password"
    ],
    "message": "Passwords do not match"
  }
]
}
*/
```

--------------------------------

### Default Value When Field is Missing (Exact)

Source: https://effect.website/docs/schema/advanced-usage

This example demonstrates using the 'exact: true' option with 'optionalWith'. The default value (1) is applied only if the 'quantity' field is completely absent in the input. If 'quantity' is 'undefined', it results in a parsing error, as shown in the commented-out output.

```typescript
import { Schema } from "effect"

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    default: () => 1, // Default value for quantity
    exact: true // Only apply default if quantity is not provided
  })
})

// ┌─── { readonly quantity?: string; }
// ▼
type Encoded = typeof Product.Encoded

// ┌─── { readonly quantity: number; }
// ▼
type Type = typeof Product.Type

console.log(Schema.decodeUnknownSync(Product)({}))
// Output: { quantity: 1 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: "2" }))
// Output: { quantity: 2 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
/* 
throws:
ParseError: (Struct (Encoded side) <-> Struct (Type side))
└─ Encoded side transformation failure
└─ Struct (Encoded side)
└─ ["quantity"]
└─ NumberFromString
└─ Encoded side transformation failure
└─ Expected string, actual undefined
*/
```

--------------------------------

### Provide Combined Logger in Effect.js

Source: https://effect.website/docs/observability/logging

This snippet demonstrates how to replace the default logger with a combined logger in Effect.js. It utilizes Effect.provide to set up the logger context for the application. Ensure the `combined` logger is correctly instantiated before this step.

```typescript
Effect.provide(Logger.replace(Logger.defaultLogger, combined))
```

--------------------------------

### Handle results of concurrent tasks with Effect.raceWith

Source: https://effect.website/docs/concurrency/basic-concurrency

This example illustrates using Effect.raceWith to run two tasks concurrently and handle their results individually as they complete. The 'onSelfDone' and 'onOtherDone' callbacks in the finisher object allow for specific actions based on which task finishes first and its outcome. The program logs messages during task execution and upon the completion of either task.

```typescript
import { Effect, Console } from "effect"

const task1 = Effect.succeed("task1").pipe(
  Effect.delay("100 millis"),
  Effect.tap(Console.log("task1 done")),
  Effect.onInterrupt(() =>
    Console.log("task1 interrupted").pipe(Effect.delay("100 millis"))
  )
)

const task2 = Effect.succeed("task2").pipe(
  Effect.delay("200 millis"),
  Effect.tap(Console.log("task2 done")),
  Effect.onInterrupt(() =>
    Console.log("task2 interrupted").pipe(Effect.delay("100 millis"))
  )
)

const program = Effect.raceWith(task1, task2, {
  onSelfDone: (exit) => Console.log(`task1 exited with ${exit}`),
  onOtherDone: (exit) => Console.log(`task2 exited with ${exit}`)
})

Effect.runFork(program)
```

--------------------------------

### Define String Length Filter with Schema.filter

Source: https://effect.website/docs/schema/filters

This example demonstrates how to create a custom filter for a string schema using `Schema.filter`. It ensures that the input string is at least 10 characters long, providing a specific error message if the condition is not met. The filter adds a validation constraint without altering the original schema's type.

```typescript
import { Schema } from "effect"

// Define a string schema with a filter to ensure the string
// is at least 10 characters long
const LongString = Schema.String.pipe(
  Schema.filter(
    // Custom error message for strings shorter than 10 characters
    (s) => s.length >= 10 || "a string at least 10 characters long"
  )
)

// ┌─── string
// ▼
type Type = typeof LongString.Type

console.log(Schema.decodeUnknownSync(LongString)("a"))
/* 
throws: 
ParseError: { string | filter } 
└─ Predicate refinement failure 
└─ a string at least 10 characters long 
*/
```

--------------------------------

### Temporarily Overriding Clock Service with Effect.withClockScoped - Effect.js

Source: https://effect.website/docs/requirements-management/default-services

This example illustrates overriding the Clock service within a specific scope using `Effect.withClockScoped`. The custom Clock implementation is applied only within the scoped effect, and the original Clock service is automatically restored when the scope ends, ensuring predictable behavior.

```typescript
import { Effect, Clock, Console } from "effect"

// Assume customClock is an implementation of the Clock service
// const customClock = { currentTimeMillis: () => Effect.succeed(1678886400000) };

const program = Effect.gen(function* () {
  const now = yield* Clock.currentTimeMillis
  yield* Console.log(`Application started at ${new Date(now)}`)
})

// Effect.withClockScoped(customClock)(program)
```

--------------------------------

### Default Value When Field is Missing, Null, or Undefined (Nullable)

Source: https://effect.website/docs/schema/advanced-usage

This example uses the 'nullable: true' option with 'optionalWith'. The default value (1) is applied if the 'quantity' field is missing, 'null', or 'undefined'. This provides flexibility in handling various forms of absent or nullish input.

```typescript
import { Schema } from "effect"

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    default: () => 1, // Default value for quantity
    nullable: true // Apply default if quantity is null
  })
})

// ┌─── { readonly quantity?: string | null | undefined; }
// ▼
type Encoded = typeof Product.Encoded

// ┌─── { readonly quantity: number; }
// ▼
type Type = typeof Product.Type

console.log(Schema.decodeUnknownSync(Product)({}))
// Output: { quantity: 1 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
// Output: { quantity: 1 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: null }))
// Output: { quantity: 1 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: "2" }))
// Output: { quantity: 2 }
```

--------------------------------

### Define a Schema Class Without Fields (TypeScript)

Source: https://effect.website/docs/schema/classes

Shows how to define a schema class `NoArgs` using `Schema.Class` when no fields are required. It demonstrates creating instances using the default constructor and by explicitly passing an empty object.

```typescript
import { Schema } from "effect"

// Define a class with no fields
class NoArgs extends Schema.Class("NoArgs")({})

// Create an instance using the default constructor
const noargs1 = new NoArgs()

// Alternatively, create an instance by explicitly passing an empty object
const noargs2 = new NoArgs({})

```

--------------------------------

### HttpError with Tagged Discriminant - TypeScript

Source: https://effect.website/docs/error-management/expected-errors

This example illustrates the use of `Data.TaggedError` to define a custom error type. It shows how a `_tag` field is automatically added to instances of `HttpError`, serving as a discriminant for distinguishing between different error types, which is crucial for error handling mechanisms like `Effect.catchTag`.

```typescript
// Define a custom error type using Data.TaggedError
class HttpError extends Data.TaggedError("HttpError")<{}> {}

// This field serves as a discriminant for the error
console.log(new HttpError()._tag) // Output: "HttpError"
```

--------------------------------

### Broadcast Stream to Multiple Consumers with Stream.broadcast

Source: https://effect.website/docs/stream/operations

The Stream.broadcast operator duplicates a source stream, sending all its elements to multiple downstream consumers. It includes a 'maximumLag' parameter to manage backpressure, ensuring the upstream stream doesn't get too far ahead of the slowest consumer. This is useful for distributing stream data to parallel processing units.

```typescript
import { Effect, Stream, Console, Schedule, Fiber } from "effect"

const numbers = Effect.scoped(
  Stream.range(1, 20).pipe(
    Stream.tap((n) =>
      Console.log(`Emit ${n} element before broadcasting`)
    ),
    // Broadcast to 2 downstream consumers with max lag of 5
    Stream.broadcast(2, 5)
  )
)
```

--------------------------------

### Repeat Effect Result Stream using Effect TS

Source: https://effect.website/docs/stream/creating

Generates a stream by repeatedly evaluating an Effect. This is useful for creating streams of values produced by effectful operations, such as random number generation. The stream's results are collected into a Chunk. The example shows generating a stream of random integers.

```typescript
import { Stream, Effect, Random } from "effect"

const stream = Stream.repeatEffect(Random.nextInt)

Effect.runPromise(Stream.runCollect(stream.pipe(Stream.take(5)))).then(
  console.log
)
/* 
Example Output:
{
  _id: 'Chunk',
  values: [ 1666935266, 604851965, 2194299958, 3393707011, 4090317618 ]
}
*/
```

--------------------------------

### Importing Effect Schema Module

Source: https://effect.website/docs/schema/getting-started

Demonstrates how to import the Schema module from the 'effect' package, supporting both namespace and named imports.

```typescript
import * as Schema from "effect/Schema"

```

```typescript
import { Schema } from "effect"

```

--------------------------------

### Run Scheduled Task Until Another Completes with Effect.js

Source: https://effect.website/docs/scheduling/examples

This example illustrates how to run a periodic task using Effect.js until another, potentially longer-running task, finishes. It utilizes `Effect.race` to combine a repeating action with a delayed effect, ensuring the repeating action stops once the main task is complete. This pattern is useful for polling or periodic logging that should cease upon a specific event.

```typescript
import { Effect, Console, Schedule } from "effect"

// Define a long-running effect 
// (e.g., a task that takes 5 seconds to complete)
const longRunningEffect = Console.log("done").pipe(
Effect.delay("5 seconds")
)

// Define an action to run periodically
const action = Console.log("action...")

// Define a fixed interval schedule
const schedule = Schedule.fixed("1.5 seconds")

// Run the action repeatedly until the long-running task completes
const program = Effect.race(
Effect.repeat(action, schedule),
longRunningEffect
)

Effect.runPromise(program)
/* 
Output:
action...
action...
action...
action...
done 
*/
```

--------------------------------

### Sequencing Operations with Effect.andThen

Source: https://effect.website/docs/getting-started/building-pipelines

Illustrates Effect.andThen for executing operations sequentially, where the second operation can depend on the result of the first. It supports various types for the second operation, including values, Promises, and Effects, similar to Effect.as, Effect.map, and Effect.flatMap. This method is ideal for ordered computations.

```typescript
import { pipe, Effect } from "effect"

// Function to apply a discount safely to a transaction amount
const applyDiscount = (
  total: number,
  discountRate: number
): Effect.Effect =>
  discountRate === 0
    ? Effect.fail(new Error("Discount rate cannot be zero"))
    : Effect.succeed(total - (total * discountRate) / 100)

// Simulated asynchronous task to fetch a transaction amount from database
const fetchTransactionAmount = Effect.promise(() => Promise.resolve(100))

// Using Effect.map and Effect.flatMap for comparison
const result1 = pipe(
  fetchTransactionAmount,
  Effect.map((amount) => amount * 2),
  Effect.flatMap((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(result1).then(console.log) // Output: 190

// Using Effect.andThen for sequencing
const result2 = pipe(
  fetchTransactionAmount,
  Effect.andThen((amount) => amount * 2),
  Effect.andThen((amount) => applyDiscount(amount, 5))
)

Effect.runPromise(result2).then(console.log) // Output: 190
```

--------------------------------

### Effect.gen: Measure Elapsed Time with Effect.js

Source: https://effect.website/docs/code-style/do

This snippet shows how to measure the elapsed time of an Effect using the Effect.gen pattern, which leverages generator functions for a more concise and readable syntax. It binds start and end timestamps using yield* and calculates the duration. It requires the 'effect' library.

```typescript
import { Effect } from "effect"

// Get the current timestamp
const now = Effect.sync(() => new Date().getTime())

// Prints the elapsed time occurred to `self` to execute
const elapsed = (
  self: Effect.Effect
): Effect.Effect =>
Effect.gen(function* () {
  const startMillis = yield* now
  const result = yield* self
  const endMillis = yield* now
  // Calculate the elapsed time in milliseconds
  const elapsed = endMillis - startMillis
  // Log the elapsed time
  console.log(`Elapsed: ${elapsed}`)
  return result
})

// Simulates a successful computation with a delay of 200 milliseconds
const task = Effect.succeed("some task").pipe(Effect.delay("200 millis"))

const program = elapsed(task)

Effect.runPromise(program).then(console.log)
/* 
Output:
Elapsed: 204
some task 
*/
```

--------------------------------

### Repeat Effect with Termination using Effect TS

Source: https://effect.website/docs/stream/creating

Repeats the evaluation of an effect and allows for stream termination based on specific conditions. This function is suitable for scenarios where you need to process elements from an effectful source until a certain condition is met, such as draining an iterator. The example demonstrates draining an iterator.

```typescript
import { Stream, Effect, Option } from "effect"

const drainIterator = (it: Iterator): Stream.Stream<unknown, unknown, unknown> => 
  Stream.repeatEffectOption(
    Effect.sync(() => it.next())
  )
```

--------------------------------

### Define TodosService Layer in TypeScript

Source: https://effect.website/docs/batching

Defines a live implementation layer for 'TodosService'. This layer sets up the 'getTodos' functionality by using 'HttpService' to fetch data and returning an Effect that requests 'GetTodos'.

```typescript
class TodosService extends Context.Tag("TodosService")< 
  TodosService,
  { getTodos: Effect.Effect<Array, GetTodosError, TodosService> }
>() {}

const TodosServiceLive = Layer.effect(
  TodosService,
  Effect.gen(function* () {
    const http = yield* HttpService
    const resolver = RequestResolver.fromEffect((_: GetTodos) =>
      Effect.tryPromise({
        try: () =>
          http
            .fetch("https://api.example.demo/todos")
            .then((res) => res.json()),
        catch: () => new GetTodosError()
      })
    )
    return {
      getTodos: Effect.request(GetTodos({}), resolver)
    }
  })
)
```

--------------------------------

### Distinguish Stream Elements with Stream.orElseEither (JavaScript)

Source: https://effect.website/docs/stream/error-handling

This example showcases `Stream.orElseEither`, a variant of `Stream.orElse`, which uses the Either data type to clearly distinguish elements originating from the primary stream (`s1`) or the fallback stream (`s2`). This is useful when you need to differentiate the source of each element, especially after a potential failure. It requires the 'effect' library.

```javascript
import { Stream, Effect } from "effect"

const s1 = Stream.make(1, 2, 3).pipe(
  Stream.concat(Stream.fail("Oh! Error!")),
  Stream.concat(Stream.make(4, 5))
)

const s2 = Stream.make("a", "b", "c")

const stream = Stream.orElseEither(s1, () => s2)

Effect.runPromise(Stream.runCollect(stream)).then(console.log)
/* 
Output:
{
  _id: "Chunk",
  values: [
    {
      _id: "Either",
      _tag: "Left",
      left: 1
    },
    {
      _id: "Either",
      _tag: "Left",
      left: 2
    },
    {
      _id: "Either",
      _tag: "Left",
      left: 3
    },
    {
      _id: "Either",
      _tag: "Right",
      right: "a"
    },
    {
      _id: "Either",
      _tag: "Right",
      right: "b"
    },
    {
      _id: "Either",
      _tag: "Right",
      right: "c"
    }
  ]
}
*/
```

--------------------------------

### Extract Keys from Object Schema with Schema.keyof

Source: https://effect.website/docs/schema/basic-usage

The Schema.keyof operation generates a schema that represents the keys of an input object schema. This is helpful when you need to work with the names of properties within a schema, for example, to create a schema for a set of allowed property names. It takes an object schema and returns a new schema representing its keys.

```typescript
import { Schema } from "effect"

const schema = Schema.Struct({
  a: Schema.String,
  b: Schema.Number
})

const keys = Schema.keyof(schema)

// ┌─── "a" | "b"
// ▼
type Type = typeof keys.Type
```

--------------------------------

### MutableHashSet Constructors

Source: https://effect.website/docs/data-types/hash-set

Functions to create and initialize MutableHashSet instances.

```APIDOC
## MutableHashSet Constructors

### empty

Creates an empty MutableHashSet.

### Method

constructor

### Endpoint

N/A (Constructor)

### Parameters

None

### Request Example

```json
{}
```

### Response

#### Success Response (200)

- **MutableHashSet** - An empty mutable hash set.

### Response Example

```json
{
  "instance": "MutableHashSet"
}
```

## MutableHashSet Constructors

### fromIterable

Creates a set from an iterable.

### Method

constructor

### Endpoint

N/A (Constructor)

### Parameters

- **iterable** (Iterable<A>) - Required - An iterable collection of values.

### Request Example

```json
{
  "iterable": [
    1,
    2,
    3
  ]
}
```

### Response

#### Success Response (200)

- **MutableHashSet** - A mutable hash set initialized with values from the iterable.

### Response Example

```json
{
  "instance": "MutableHashSet"
}
```

## MutableHashSet Constructors

### make

Creates a set from multiple values.

### Method

constructor

### Endpoint

N/A (Constructor)

### Parameters

- **elements** (...A) - Required - A variable number of values to add to the set.

### Request Example

```json
{
  "elements": [
    1,
    2,
    3
  ]
}
```

### Response

#### Success Response (200)

- **MutableHashSet** - A mutable hash set initialized with the provided values.

### Response Example

```json
{
  "instance": "MutableHashSet"
}
```
```

--------------------------------

### Define a Command for Directory Listing

Source: https://effect.website/docs/platform/command

This snippet demonstrates how to create a command object using `Command.make`. The command object represents the process name and its arguments but does not execute the command. It includes properties like command, args, env, cwd, shell, gid, and uid.

```typescript
import { Command } from "@effect/platform"

const command = Command.make("ls", "-al")
console.log(command)
/*
{
_id: '@effect/platform/Command',
_tag: 'StandardCommand',
command: 'ls',
args: [ '-al' ],
env: {},
cwd: { _id: 'Option', _tag: 'None' },
shell: false,
gid: { _id: 'Option', _tag: 'None' },
uid: { _id: 'Option', _tag: 'None' }
}
*/
```

--------------------------------

### Handle Type Inference Error in Recursive Schemas

Source: https://effect.website/docs/schema/advanced-usage

Illustrates a common TypeScript error (ts(7022) and ts(7024)) that occurs when defining recursive schemas without explicit type annotations. This example shows the problematic code that leads to implicit 'any' types and incorrect inference.

```typescript
import { Schema } from "effect"

const Category = Schema.Struct({
  // Error ts(7022) — 'Category' implicitly has type 'any' because it does not have a type annotation and is referenced directly or indirectly in its own initializer.
  name: Schema.String,
  subcategories: Schema.Array(Schema.suspend(() => Category))
  // Error ts(7024) — Function implicitly has return type 'any' because it does not have a return type annotation and is referenced directly or indirectly in one of its return expressions.
})
```

--------------------------------

### Concurrent Execution: Promise.all vs. Effect

Source: https://effect.website/docs/additional-resources/effect-vs-promise

Compares running multiple asynchronous operations concurrently using Promise.all and Effect's concurrency primitives. Demonstrates handling of both success and failure in parallel tasks.

```javascript
const task1 = new Promise((resolve, reject) => {
  console.log("Executing task1...")
  setTimeout(() => {
    console.log("task1 done")
    resolve(1)
  }, 100)
})

const task2 = new Promise((resolve, reject) => {
  console.log("Executing task2...")
  setTimeout(() => {
    console.log("task2 done")
    reject("Uh oh!")
  }, 200)
})

const task3 = new Promise((resolve, reject) => {
  console.log("Executing task3...")
  setTimeout(() => {
    console.log("task3 done")
    resolve(3)
  }, 300)
})

const program = Promise.all([task1, task2, task3])

program.then(console.log, console.error)
/* 
Output:
Executing task1...
Executing task2...
Executing task3...
task1 done
task2 done
Uh oh!
task3 done 
*/
```

```typescript
import { Effect } from "effect"

const task1 = Effect.gen(function* () {
  console.log("Executing task1...")
  yield* Effect.sleep("100 millis")
  console.log("task1 done")
  return 1
})

const task2 = Effect.gen(function* () {
  console.log("Executing task2...")
  yield* Effect.sleep("200 millis")
  console.log("task2 done")
  return yield* Effect.fail("Uh oh!")
})

const task3 = Effect.gen(function* () {
  console.log("Executing task3...")
  yield* Effect.sleep("300 millis")
  console.log("task3 done")
  return 3
})

const program = Effect.all([task1, task2, task3])

Effect.runPromise(program).then(console.log).catch(console.error)
```

--------------------------------

### TypeScript: Handle Errors with Effect.either in Effect.js

Source: https://effect.website/docs/error-management/expected-errors

This example demonstrates how to use Effect.either to transform an Effect into one that returns an Either data type, encapsulating both success and failure. This allows for explicit handling of both outcomes within a generator function by pattern matching on the Either. It uses custom error types.

```typescript
import { Effect, Either, Random, Data } from "effect"

class HttpError extends Data.TaggedError("HttpError")<{}> {}

class ValidationError extends Data.TaggedError("ValidationError")<{}> {}

const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next

  if (n1 < 0.5) {
    return yield* Effect.fail(new HttpError())
  }

  if (n2 < 0.5) {
    return yield* Effect.fail(new ValidationError())
  }

  return "some result"
})

const handledProgram = Effect.either(program)

// handledProgram now returns Effect<Either<HttpError | ValidationError, string>, never, never>
```

--------------------------------

### Extracting Elements from Streams with take variations (TypeScript)

Source: https://effect.website/docs/stream/operations

Shows how to use various 'take' operations on streams: `take` for a fixed number of elements, `takeWhile` for elements meeting a condition, `takeUntil` for elements until a condition is met, and `takeRight` for elements from the end. These functions help in selectively extracting data from a stream.

```typescript
import { Stream, Effect } from "effect"

const stream = Stream.iterate(0, (n) => n + 1)

// Using `take` to extract a fixed number of elements:
const s1 = Stream.take(stream, 5)
Effect.runPromise(Stream.runCollect(s1)).then(console.log)
/*
Output:
{ _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }
*/

// Using `takeWhile` to extract elements while a condition is met:
const s2 = Stream.takeWhile(stream, (n) => n < 5)
Effect.runPromise(Stream.runCollect(s2)).then(console.log)
/*
Output:
{ _id: 'Chunk', values: [ 0, 1, 2, 3, 4 ] }
*/

// Using `takeUntil` to extract elements until a condition is met:
const s3 = Stream.takeUntil(stream, (n) => n === 5)
Effect.runPromise(Stream.runCollect(s3)).then(console.log)
/*
Output:
{ _id: 'Chunk', values: [ 0, 1, 2, 3, 4, 5 ] }
*/

// Using `takeRight` to take elements from the end of the stream:
const s4 = Stream.takeRight(s3, 3)
Effect.runPromise(Stream.runCollect(s4)).then(console.log)
/*
Output:
{ _id: 'Chunk', values: [ 3, 4, 5 ] }
*/
```

--------------------------------

### Using Generators for Effects

Source: https://context7_llms

Shows how to use generators within Effect for a more sequential and readable way to write effectful code, similar to async/await syntax.

```typescript
import * as Effect from "@effect/io/Effect"

const myGeneratorEffect = Effect.gen(function* (_) {
  const result1 = yield* _(Effect.succeed(10))
  const result2 = yield* _(Effect.succeed(20))
  return result1 + result2
})

Effect.runSync(myGeneratorEffect) // 30
```

--------------------------------

### Annotate Struct Properties for JSON Schema (Effect-TS)

Source: https://effect.website/docs/schema/json-schema

This example shows how to add annotations directly to struct property signatures in Effect-TS for more semantically accurate JSON Schema generation. This approach links metadata like 'title' specifically to the properties they describe. It generates a JSON schema for a 'Person' struct with 'firstName' and 'lastName' properties.

```typescript
import { JSONSchema, Schema } from "effect"

const Person = Schema.Struct({
  firstName: Schema.propertySignature(Schema.String).annotations({
    title: "First name"
  }),
  lastName: Schema.propertySignature(Schema.String).annotations({
    title: "Last Name"
  })
})

const jsonSchema = JSONSchema.make(Person)

console.log(JSON.stringify(jsonSchema, null, 2))
```

--------------------------------

### Add Custom Error Message to String Schema (Effect)

Source: https://effect.website/docs/schema/error-messages

Demonstrates how to define a string schema with a custom error message using `Schema.String.annotations({ message: ... })`. This custom message replaces the default error when decoding fails. The example shows decoding `null` against a string schema with and without a custom message.

```typescript
import { Schema } from "effect"

// Define a string schema without a custom message
const MyString = Schema.String

// Attempt to decode `null`, resulting in a default error message
// Schema.decodeUnknownSync(MyString)(null)
/* 
throws:
ParseError: Expected string, actual null 
*/

// Define a string schema with a custom error message
const MyStringWithMessage = Schema.String.annotations({
  message: () => "not a string"
})

// Decode with the custom schema, showing the new error message
// Schema.decodeUnknownSync(MyStringWithMessage)(null)
/* 
throws:
ParseError: not a string 
*/
```

--------------------------------

### Effect.js Custom Configuration Type Definition

Source: https://effect.website/docs/configuration

Shows how to define and use custom configuration types in Effect.js. It involves combining primitive configurations (like string and number) using `Config.all` and then mapping the combined values to a custom class instance.

```typescript
import { Config } from "effect"

class HostPort {
  constructor(readonly host: string, readonly port: number) {}
  get url() {
    return `${this.host}:${this.port}`
  }
}

// Combine the configuration for 'HOST' and 'PORT'
const both = Config.all([Config.string("HOST"), Config.number("PORT")])

// Map the configuration values into a HostPort instance
const config = Config.map(
  both,
  ([host, port]) => new HostPort(host, port)
)
```

--------------------------------

### Default Value When Field is Missing or Null (Exact and Nullable)

Source: https://effect.website/docs/schema/advanced-usage

This example combines both 'exact: true' and 'nullable: true' options. The default value (1) is applied if the 'quantity' field is missing or explicitly 'null'. However, if 'quantity' is set to 'undefined', it will result in a parsing error, enforcing stricter input validation.

```typescript
import { Schema } from "effect"

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    default: () => 1, // Default value for quantity
    exact: true, // Only apply default if quantity is not provided
    nullable: true // Apply default if quantity is null
  })
})

// ┌─── { readonly quantity?: string | null; }
// ▼
type Encoded = typeof Product.Encoded

// ┌─── { readonly quantity: number; }
// ▼
type Type = typeof Product.Type

console.log(Schema.decodeUnknownSync(Product)({}))
// Output: { quantity: 1 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: null }))
// Output: { quantity: 1 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: "2" }))
// Output: { quantity: 2 }

console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
/* 
throws:
ParseError: (Struct (Encoded side) <-> Struct (Type side))
└─ Encoded side transformation failure
└─ Struct (Encoded side)
└─ ["quantity"]
└─ NumberFromString
└─ Encoded side transformation failure
└─ Expected string, actual undefined
*/
```

--------------------------------

### Promise.allSettled() vs. Effect.forEach with Effect.either

Source: https://effect.website/docs/additional-resources/effect-vs-promise

This snippet showcases how to handle an array of asynchronous tasks, ensuring that all tasks complete regardless of their success or failure. It contrasts the native Promise.allSettled with the Effect library's approach using Effect.forEach and Effect.either for granular result handling.

```javascript
const task1 = new Promise((resolve, reject) => {
  console.log("Executing task1...")
  setTimeout(() => {
    console.log("task1 done")
    resolve(1)
  }, 100)
})

const task2 = new Promise((resolve, reject) => {
  console.log("Executing task2...")
  setTimeout(() => {
    console.log("task2 done")
    reject("Uh oh!")
  }, 200)
})

const task3 = new Promise((resolve, reject) => {
  console.log("Executing task3...")
  setTimeout(() => {
    console.log("task3 done")
    resolve(3)
  }, 300)
})

const program = Promise.allSettled([task1, task2, task3])

program.then(console.log, console.error)
/* 
Output:
Executing task1...
Executing task2...
Executing task3...
task1 done
task2 done
task3 done
[
  { status: 'fulfilled', value: 1 },
  { status: 'rejected', reason: 'Uh oh!' },
  { status: 'fulfilled', value: 3 }
]
*/
```

```typescript
import { Effect } from "effect"

const task1 = Effect.gen(function* () {
  console.log("Executing task1...")
  yield* Effect.sleep("100 millis")
  console.log("task1 done")
  return 1
})

const task2 = Effect.gen(function* () {
  console.log("Executing task2...")
  yield* Effect.sleep("200 millis")
  console.log("task2 done")
  return yield* Effect.fail("Uh oh!")
})

const task3 = Effect.gen(function* () {
  console.log("Executing task3...")
  yield* Effect.sleep("300 millis")
  console.log("task3 done")
  return 3
})

const program = Effect.forEach(
  [task1, task2, task3],
  (task) => Effect.either(task), // or Effect.exit 
  {
    concurrency: "unbounded"
  }
)

Effect.runPromise(program).then(console.log, console.error)
/* 
Output:
Executing task1...
Executing task2...
Executing task3...
task1 done
task2 done
[
  {
    _id: "Either",
    _tag: "Right",
    right: 1 
  }, {
    _id: "Either",
    _tag: "Left",
    left: "Uh oh!"
  }, {
    _id: "Either",
    _tag: "Right",
    right: 3 
  }
]
*/
```

--------------------------------

### Retry on Specific Error Codes with Effect.js

Source: https://effect.website/docs/scheduling/examples

This example shows how to configure Effect.js to retry an operation only when a specific error condition is met, such as an HTTP 401 Unauthorized response. It defines a custom error class and uses `Effect.retry` with a condition based on the error status. Errors not matching the condition will not trigger a retry.

```typescript
import { Console, Effect, Data } from "effect"

// Custom error class for handling status codes
class Err extends Data.TaggedError("Err")<{ 
readonly message: string 
readonly status: number 
}> {} 

// Function to make the API call
const getJson = (url: string) =>
Effect.tryPromise({
try: () =>
fetch(url).then((res) => {
if (!res.ok) {
console.log(res.status)
throw new Err({ message: res.statusText, status: res.status })
}
return res.json() as unknown
}),
catch: (e) => e as Err
})

// Program that retries only when the error status is 401 (Unauthorized)
const program = (url: string) =>
getJson(url).pipe(
Effect.retry({ while: (err) => err.status === 401 }),
Effect.catchAll(Console.error)
)

// Test case: API returns 401 (triggers multiple retries)
Effect.runFork(
program("https://dummyjson.com/auth/products/1?delay=1000")
)
/* 
Output:
401
401
401
401
... 
*/ 

// Test case: API returns 404 (no retries)
Effect.runFork(program("https://dummyjson.com/-"))
/* 
Output:
404
Err [Error]: Not Found 
*/
```

--------------------------------

### Define Person Schema and Generate Arbitrary Data with FastCheck (TypeScript)

Source: https://effect.website/docs/schema/arbitrary

This snippet defines a 'Person' schema including 'Name' and a constrained 'Age' (between 1 and 80). It then uses 'Arbitrary.make' to create an arbitrary generator for the 'Person' schema and samples it using 'FastCheck.sample'. The example output shows randomly generated person objects.

```typescript
const Age = Schema.Int.pipe(Schema.between(1, 80))
const Person = Schema.Struct({
  name: Name,
  age: Age
})

const arb = Arbitrary.make(Person)

console.log(FastCheck.sample(arb, 2))
```

--------------------------------

### Generate Recursive JSON Schema with Identifier (Effect-TS)

Source: https://effect.website/docs/schema/json-schema

This snippet illustrates how to create and generate JSON Schemas for recursive data structures using Effect-TS. It highlights the mandatory use of 'identifier' annotations to ensure correct self-references within the generated schema. The example defines a 'Category' schema that can contain an array of other categories.

```typescript
import { JSONSchema, Schema } from "effect"

// Define the interface representing a category structure 
interface Category {
  readonly name: string
  readonly categories: ReadonlyArray<Category>
}

// Define a recursive schema with a required identifier annotation 
const Category = Schema.Struct({
  name: Schema.String,
  categories: Schema.Array(
    // Recursive reference to the Category schema 
    Schema.suspend((): Schema.Schema => Category)
  )
}).annotations({ identifier: "Category" })

const jsonSchema = JSONSchema.make(Category)

console.log(JSON.stringify(jsonSchema, null, 2))
```

--------------------------------

### Effect Logging with prettyLogger in TypeScript

Source: https://effect.website/docs/observability/logging

This snippet illustrates the use of prettyLogger for enhanced readability with colors and indentation, ideal for development. The Effect program is set up to use Logger.pretty, producing visually appealing console output.

```typescript
import { Effect, Logger } from "effect"

const program = Effect.log("msg1", "msg2", ["msg3", "msg4"]).pipe(
  Effect.delay("100 millis"),
  Effect.annotateLogs({ key1: "value1", key2: "value2" }),
  Effect.withLogSpan("myspan")
)

Effect.runFork(program.pipe(Effect.provide(Logger.pretty)))
```

--------------------------------

### TypeScript: Automatically Track Union Error Types in Effect

Source: https://effect.website/docs/error-management/expected-errors

This example demonstrates how Effect.js automatically tracks multiple potential error types as a union. It defines custom error classes for HTTP and validation errors and shows how Effect.gen composes operations that can fail with these distinct errors, making error handling more predictable.

```typescript
import { Effect, Random, Data } from "effect"

class HttpError extends Data.TaggedError("HttpError")<{}> {}

class ValidationError extends Data.TaggedError("ValidationError")<{}> {}

const program = Effect.gen(function* () {
  const n1 = yield* Random.next
  const n2 = yield* Random.next

  if (n1 < 0.5) {
    return yield* Effect.fail(new HttpError())
  }

  if (n2 < 0.5) {
    return yield* Effect.fail(new ValidationError())
  }

  return "some result"
})

// The inferred type of 'program' will be Effect<string, HttpError | ValidationError, never>
```

--------------------------------

### Effect Logging Utilities

Source: https://context7_llms

Overview of Effect's logging capabilities, including dynamic log levels, custom output destinations, and fine-grained control over log messages.

```typescript
import * as Logger from "@effect/io/Logger"
import * as Effect from "@effect/io/Effect"

const myLogger = Logger.make(({ message }) => {
  console.log(`[INFO] ${message}`)
})

const logEffect = Logger.log("Hello from Effect logging!")

Effect.provide(logEffect, Logger.using(myLogger))
// Output: [INFO] Hello from Effect logging!
```

--------------------------------

### Zoned Constructors

Source: https://effect.website/docs/data-types/datetime

Provides methods for creating Zoned DateTimes, which include epoch milliseconds and a TimeZone.

```APIDOC
## Zoned Constructors

A `Zoned` includes `epochMillis` along with a `TimeZone`, allowing you to represent a specific point in time with an associated time zone.

### unsafeMakeZoned

Creates a `Zoned` by combining a DateTime.Input with an optional `TimeZone`. The time zone can be provided as a `TimeZone` object, a string identifier (e.g., `"Europe/London"`), or a numeric offset in milliseconds. Throws `IllegalArgumentException` if the input or time zone is invalid.

#### Parameters

- **input** (Date | string | { year: number, month?: number, date?: number, hours?: number, minutes?: number, seconds?: number, milliseconds?: number }) - Required - The input value to create a Zoned DateTime from.
- **options** (object) - Optional - Configuration options.
  - **timeZone** (TimeZone | string | number) - The time zone to associate with the Zoned DateTime.
  - **adjustForTimeZone** (boolean) - If true, interprets the input date as being in the specified time zone. Defaults to false.

#### Request Example (System's Local Time Zone)

```javascript
import { DateTime } from "effect"

// Assuming execution in Italy (CET timezone, UTC+1 in January)
const zoned = DateTime.unsafeMakeZoned(new Date("2025-01-01 04:00:00"))
console.log(zoned)
// Output: DateTime.Zoned(2025-01-01T04:00:00.000+01:00)
console.log(zoned.zone)
// Output: TimeZone.Offset(+01:00)
```

#### Request Example (Specified Named Time Zone)

```javascript
import { DateTime } from "effect"

// Assuming execution in Italy (CET timezone)
const zoned = DateTime.unsafeMakeZoned(new Date("2025-01-01 04:00:00"), {
  timeZone: "Europe/Rome"
})
console.log(zoned)
// Output: DateTime.Zoned(2025-01-01T04:00:00.000+01:00[Europe/Rome])
console.log(zoned.zone)
// Output: TimeZone.Named(Europe/Rome)
```

#### Request Example (Adjusting for Time Zone Interpretation)

```javascript
import { DateTime } from "effect"

// Assuming execution in Italy (CET timezone)
const zoned = DateTime.unsafeMakeZoned(new Date("2025-01-01 04:00:00"), {
  timeZone: "Europe/Rome",
  adjustForTimeZone: true
})
console.log(zoned)
// Output: DateTime.Zoned(2025-01-01T03:00:00.000+01:00[Europe/Rome])
console.log(zoned.zone)
// Output: TimeZone.Named(Europe/Rome)
```

### makeZoned

Works like `unsafeMakeZoned` but returns an `Option`. Returns `None` if the input is invalid, otherwise returns `Some` containing the `Zoned` DateTime.

#### Parameters

- **input** (Date | string | { year: number, month?: number, date?: number, hours?: number, minutes?: number, seconds?: number, milliseconds?: number }) - Required - The input value to create a Zoned DateTime from.
- **options** (object) - Optional - Configuration options.
  - **timeZone** (TimeZone | string | number) - The time zone to associate with the Zoned DateTime.
  - **adjustForTimeZone** (boolean) - If true, interprets the input date as being in the specified time zone. Defaults to false.

#### Request Example

```javascript
import { DateTime, Option } from "effect"

const zoned = DateTime.makeZoned(new Date("2025-01-01 04:00:00"), {
  timeZone: "Europe/Rome"
})

if (Option.isSome(zoned)) {
  console.log("The DateTime is valid")
}
```

### makeZonedFromString

Creates a `Zoned` by parsing a string in the format `YYYY-MM-DDTHH:mm:ss.sss+HH:MM[IANA timezone identifier]`. Returns `Some` with the `Zoned` if valid, otherwise returns `None`.

#### Parameters

- **input** (string) - Required - The string to parse.

#### Request Example

```javascript
import { DateTime, Option } from "effect"

// Example of a valid zoned string
const zonedFromString = DateTime.makeZonedFromString("2025-01-01T04:00:00.000+01:00[Europe/Rome]")

if (Option.isSome(zonedFromString)) {
  console.log("Successfully parsed Zoned DateTime from string.")
}
```
```

--------------------------------

### Using Identifiers for Schema Clarity (TypeScript)

Source: https://effect.website/docs/schema/error-messages

This snippet demonstrates how to use the 'identifier' annotation to provide clear names for schema components like 'Name', 'Age', and 'Person'. This improves the readability of error messages when decoding fails, making it easier to pinpoint the source of the issue. It shows examples of decoding null, an empty object, and an object with null values, all resulting in specific 'ParseError' messages.

```typescript
import { Schema } from "effect"

const Name = Schema.String.annotations({ identifier: "Name" })

const Age = Schema.Number.annotations({ identifier: "Age" })

const Person = Schema.Struct({
    name: Name,
    age: Age
}).annotations({ identifier: "Person" })

// Example of decoding null
// Schema.decodeUnknownSync(Person)(null)
/* 
throws:
ParseError: Expected Person, actual null 
*/ 

// Example of decoding an empty object
// Schema.decodeUnknownSync(Person)({}, { errors: "all" })
/* 
throws:
ParseError: Person 
└─ ["name"]
   └─ is missing
└─ ["age"]
   └─ is missing
*/ 

// Example of decoding an object with null values
// Schema.decodeUnknownSync(Person)(
//     { name: null, age: null },
//     { errors: "all" }
// )
/* 
throws:
ParseError: Person 
├─ ["name"]
│  └─ Expected Name, actual null
└─ ["age"]
   └─ Expected Age, actual null
*/
```

--------------------------------

### Demonstrate Nested Scope Closure with Effect.forkIn

Source: https://effect.website/docs/concurrency/fibers

Illustrates the behavior of nested scopes and child fibers when using Effect.forkIn. It shows how a child fiber continues to run even after its inner scope is closed, until the outer scope is also closed. Dependencies include Effect.forkIn, Effect.sleep, and Effect.runFork.

```typescript
import { Effect, Fiber, Scope, Console } from "effect"

const program = Effect.gen(function* () {
  const outerScope = yield* Scope.make
  const child = yield* Effect.gen(function* () {
    yield* Effect.addFinalizer(() =>
      Console.log("The inner scope is about to be closed!")
    )
    yield* Effect.sleep("100 millis")
    Console.log("child: still running!")
  })

  yield* outerScope.addFinalizer(yield* Effect.gen(function* () {
    yield* Effect.sleep("100 millis")
    Console.log("The outer scope is about to be closed!")
  }))

  // Fork the child fiber in the outer scope
  yield* Effect.forkIn(child, outerScope)
  yield* Effect.sleep("3 seconds")
})

Effect.runFork(program)
```

--------------------------------

### Configure Optional Field with Exactness as Option in TypeScript

Source: https://effect.website/docs/schema/advanced-usage

This example uses optionalWith with exact: true to ensure Option.none() only on missing fields, treating undefined as an error. Requires the Effect library for parsing, handling string-to-number conversion, and throwing ParseError for undefined inputs. Outputs Option types or errors, limited by strict exactness that disallows undefined values.

```typescript
import { Schema } from "effect"

const Product = Schema.Struct({
  quantity: Schema.optionalWith(Schema.NumberFromString, {
    as: "Option",
    exact: true
  })
})

// ┌─── { readonly quantity?: string; }
// ▼
type Encoded = typeof Product.Encoded

// ┌─── { readonly quantity: Option; }
// ▼
type Type = typeof Product.Type

console.log(Schema.decodeUnknownSync(Product)({}))
// Output: { quantity: { _id: 'Option', _tag: 'None' } }

console.log(Schema.decodeUnknownSync(Product)({ quantity: "2" }))
// Output: { quantity: { _id: 'Option', _tag: 'Some', value: 2 } }

console.log(Schema.decodeUnknownSync(Product)({ quantity: undefined }))
/*
throws:
ParseError: (Struct (Encoded side) <-> Struct (Type side))
└─ Encoded side transformation failure
└─ Struct (Encoded side)
└─ ["quantity"]
└─ NumberFromString
└─ Encoded side transformation failure
└─ Expected string, actual undefined
*/
```

--------------------------------

### Export Traces via OTLP to OpenTelemetry Backend (TypeScript)

Source: https://effect.website/docs/observability/tracing

This snippet demonstrates how to configure Effect-TS to export application traces to an OpenTelemetry backend using the OTLP format over HTTP. It utilizes NodeSdk, BatchSpanProcessor, and OTLPTraceExporter. The program defines a recursive task structure with logging and sleep operations, then runs it with the OpenTelemetry SDK layer provided.

```typescript
import { Effect } from "effect"
import { NodeSdk } from "@effect/opentelemetry"
import { BatchSpanProcessor } from "@opentelemetry/sdk-trace-base"
import { OTLPTraceExporter } from "@opentelemetry/exporter-trace-otlp-http"

// Function to simulate a task with possible subtasks
const task = (
  name: string,
  delay: number,
  children: ReadonlyArray<Effect.Effect<any, any, any>> = []
) =>
  Effect.gen(function* () {
    yield* Effect.log(name)
    yield* Effect.sleep(`${delay} millis`)
    for (const child of children) {
      yield* child
    }
    yield* Effect.sleep(`${delay} millis`)
  }).pipe(Effect.withSpan(name))

const poll = task("/poll", 1)

// Create a program with tasks and subtasks
const program = task("client", 2, [
  task("/api", 3, [
    task("/authN", 4, [task("/authZ", 5)]),
    task("/payment Gateway", 6, [
      task("DB", 7),
      task("Ext. Merchant", 8)
    ]),
    task("/dispatch", 9, [
      task("/dispatch/search", 10),
      Effect.all([poll, poll, poll], { concurrency: "inherit" }),
      task("/pollDriver/{id}", 11)
    ])
  ])
])

const NodeSdkLive = NodeSdk.layer(() => ({
  resource: { serviceName: "example" },
  spanProcessor: new BatchSpanProcessor(new OTLPTraceExporter())
}))

Effect.runPromise(
  program.pipe(
    Effect.provide(NodeSdkLive),
    Effect.catchAllCause(Effect.logError)
  )
)
```

--------------------------------

### Providing Multiple Services to an Effect

Source: https://effect.website/docs/requirements-management/services

Shows how to provide implementations for multiple services (Random and Logger) to an effect using chained Effect.provideService calls. Each service is provided individually.

```typescript
import { Effect, Context } from "effect"

class Random extends Context.Tag("MyRandomService")<Random, {
  readonly next: Effect.Effect
}>() {}

class Logger extends Context.Tag("MyLoggerService")<Logger, {
  readonly log: (message: string) => Effect.Effect
}>() {}

const program = Effect.gen(function* () {
  const random = yield* Random
  const logger = yield* Logger
  const randomNumber = yield* random.next
  return yield* logger.log(String(randomNumber))
})

// Provide service implementations for 'Random' and 'Logger'
const runnable = program.pipe(
  Effect.provideService(Random, {
    next: Effect.sync(() => Math.random())
  }),
  Effect.provideService(Logger, {
    log: (message) => Effect.sync(() => console.log(message))
  })
)
```

--------------------------------

### Sum Stream Elements Using Fold Left (Effect-TS)

Source: https://effect.website/docs/sink/creating

The Sink.foldLeft function reduces a stream to a single cumulative value by applying a given operation sequentially to each element, starting with an initial value. This is efficient for operations like summing or concatenating. Dependencies include Stream, Sink, and Effect from 'effect'. Input is a stream and an initial value with an accumulator function; output is the final reduced value.

```typescript
import { Stream, Sink, Effect } from "effect"

const stream = Stream.make(1, 2, 3, 4)

Effect.runPromise(
  Stream.run(
    stream,
    // Use foldLeft to sequentially add each element, starting with 0
    Sink.foldLeft(0, (a, b) => a + b)
  )
).then(console.log)
// Output: 10
```

--------------------------------

### Measure Elapsed Time of Effect with pipe

Source: https://effect.website/docs/code-style/do

This code snippet demonstrates how to measure the elapsed time of an Effect using the standard 'pipe' method. It shows the initial approach which can lead to excessive nesting and verbosity. The function 'elapsed' wraps another Effect, recording the start and end times to calculate and log the duration.

```typescript
import { Effect, Console } from "effect"

// Get the current timestamp
const now = Effect.sync(() => new Date().getTime())

// Prints the elapsed time occurred to `self` to execute
const elapsed = (
  self: Effect.Effect
): Effect.Effect =>
  now.pipe(
    Effect.andThen((startMillis) =>
      self.pipe(
        Effect.andThen((result) =>
          now.pipe(
            Effect.andThen((endMillis) => {
              // Calculate the elapsed time in milliseconds
              const elapsed = endMillis - startMillis
              // Log the elapsed time
              return Console.log(`Elapsed: ${elapsed}`).pipe(
                Effect.map(() => result)
              )
            })
          )
        )
      )
    )
  )

// Simulates a successful computation with a delay of 200 milliseconds
const task = Effect.succeed("some task").pipe(Effect.delay("200 millis"))

const program = elapsed(task)

Effect.runPromise(program).then(console.log)
/* 
Output:
Elapsed: 204 
some task 
*/
```

--------------------------------

### Handle Failure: Promise vs. Effect

Source: https://effect.website/docs/additional-resources/effect-vs-promise

Illustrates how to create and handle a failed asynchronous operation using Promise.reject and Effect.fail respectively. Both methods signal an unsuccessful outcome.

```javascript
const failure = Promise.reject("Uh oh!")
```

```typescript
import { Effect } from "effect"

const failure = Effect.fail("Uh oh!")
```

--------------------------------

### Stream Command stdout Directly to Process stdout

Source: https://effect.website/docs/platform/command

Explains how to pipe a command's standard output directly to the parent process's standard output using `Command.stdout("inherit")`. This is efficient for commands that produce large amounts of output.

```typescript
import { Command } from "@effect/platform"
import { NodeContext, NodeRuntime } from "@effect/platform-node"
import { Effect } from "effect"

// Create a command to run `cat` on a file and inherit stdout
const program = Command.make("cat", "./some-file.txt").pipe(
  Command.stdout("inherit"), // Stream stdout to process.stdout
  Command.exitCode // Get the exit code
)

NodeRuntime.runMain(program.pipe(Effect.provide(NodeContext.layer)))
```

--------------------------------

### FileSystem Operations

Source: https://effect.website/docs/platform/file-system

This section details various file system operations available through the Effect Platform's FileSystem API.

```APIDOC
## FileSystem API Operations

### Description
Provides a collection of functions to interact with the file system, including reading, writing, removing, and managing files and directories.

### Core Operations

*   **copy** (fromPath, toPath, options?): Copies a file or directory.
*   **createDir** (path): Creates a directory.
*   **deleteDir** (path, recursive?): Deletes a directory. If `recursive` is set to `true`, it will recursively delete nested directories.
*   **exists** (path): Checks if a file or directory exists at the specified path.
*   **glob** (pattern, options?): Returns a list of files matching the glob pattern.
*   **list** (directory, recursive?): Lists the contents of a directory. Recursively lists the contents of nested directories by setting the `recursive` option.
*   **mkdir** (path): Creates a directory.
*   **move** (fromPath, toPath): Moves a file or directory.
*   **read** (path): Reads the contents of a file.
*   **readFile** (path, encoding?): Reads the contents of a file.
*   **readFileString** (path, encoding?): Reads the contents of a file as a string.
*   **readLink** (path): Reads the destination of a symbolic link.
*   **realPath** (path): Resolves a path to its canonicalized absolute pathname.
*   **remove** (path, recursive?): Removes a file or directory. By setting the `recursive` option to `true`, you can recursively remove nested directories.
*   **rename** (fromPath, toPath): Renames a file or directory.
*   **sink** (path): Creates a writable `Sink` for the specified `path`.
*   **stat** (path): Gets information about a file at `path`.
*   **stream** (path): Creates a readable `Stream` for the specified `path`.
*   **symlink** (fromPath, toPath): Creates a symbolic link from `fromPath` to `toPath`.
*   **truncate** (path, length?): Truncates a file to a specified length. If the `length` is not specified, the file will be truncated to length `0`.
*   **utimes** (path, atime, mtime): Changes the file system timestamps of the file at `path`.
*   **watch** (path): Watches a directory or file for changes.
*   **writeFile** (path, data, encoding?): Writes data to a file at `path`.
*   **writeFileString** (path, data, encoding?): Writes a string to a file at `path`.
```

--------------------------------

### Create Branded Values with Effect Schema

Source: https://effect.website/docs/schema/default-constructors

Shows how to use `Schema.brand` to add metadata to a value, creating a branded type in Effect Schema. It illustrates successful branding and how validation rules defined before branding are still enforced.

```typescript
import { Schema } from "effect"

const BrandedNumberSchema = Schema.Number.pipe(
  Schema.between(1, 10),
  Schema.brand("MyNumber")
)

// Successful creation
const n = BrandedNumberSchema.make(5)

// This will throw an error because the number is outside the valid range
BrandedNumberSchema.make(20)
/* 
throws 
ParseError: a number between 1 and 10 & Brand<"MyNumber">
└─ Predicate refinement failure
└─ Expected a number between 1 and 10 & Brand<"MyNumber">, actual 20
*/

// Bypasses validation
BrandedNumberSchema.make(20, { disableValidation: true })
```

--------------------------------

### Custom Message on Last Refinement in Chain (Effect)

Source: https://effect.website/docs/schema/error-messages

Demonstrates applying a custom error message to the last refinement in a chain of schema refinements using `pipe` and `annotations`. The custom message is only triggered if the final refinement (`maxLength` in this case) fails. The example includes scenarios for different decoding failures (`null`, empty string, string exceeding max length).

```typescript
import { Schema } from "effect"

const MyString = Schema.String.pipe(
  Schema.minLength(1),
  Schema.maxLength(2)
).annotations({
  // This message is displayed only if the last filter (`maxLength`) fails
  message: () => "my custom message"
})

const decode = Schema.decodeUnknownSync(MyString)

try {
  decode(null)
} catch (e: any) {
  console.log(e.message)
  /* 
  minLength(1) & maxLength(2) 
  └─ From side refinement failure 
  └─ minLength(1) 
  └─ From side refinement failure 
  └─ Expected string, actual null 
  */
}

try {
  decode("")
} catch (e: any) {
  console.log(e.message)
  /* 
  minLength(1) & maxLength(2) 
  └─ From side refinement failure 
  └─ minLength(1) 
  └─ Predicate refinement failure 
  └─ Expected a string at least 1 character(s) long, actual "" 
  */
}

try {
  decode("abc")
} catch (e: any) {
  console.log(e.message)
  // "my custom message"
}
```

--------------------------------

### Create a Non-Empty Chunk using Chunk.make

Source: https://effect.website/docs/data-types/chunk

Illustrates how to create a non-empty Chunk with specific values using the `Chunk.make` static method. The resulting Chunk is typed as `NonEmptyChunk`.

```typescript
import { Chunk } from "effect"

// ┌─── NonEmptyChunk
// ▼
const chunk = Chunk.make(1, 2, 3)
```

--------------------------------

### Handling Refinement Errors in Effect Schemas (TypeScript)

Source: https://effect.website/docs/schema/error-messages

This example illustrates how Effect Schemas report errors when data fails refinement checks. It distinguishes between 'From side failure', occurring when the initial data type is incorrect (e.g., null instead of string), and 'Predicate refinement failure', where the data conforms to the initial type but violates the refinement condition (e.g., an empty string when a non-empty string is required).

```typescript
import { Schema } from "effect"

const Name = Schema.NonEmptyString.annotations({ identifier: "Name" })

const Age = Schema.Positive.pipe(Schema.int({ identifier: "Age" }))

const Person = Schema.Struct({
    name: Name,
    age: Age
}).annotations({ identifier: "Person" })

// From side failure
// Schema.decodeUnknownSync(Person)({ name: null, age: 18 })
/* 
throws:
ParseError: Person
└─ ["name"]
   └─ Name
   └─ From side refinement failure
   └─ Expected string, actual null
*/ 

// Predicate refinement failure
// Schema.decodeUnknownSync(Person)({ name: "", age: 18 })
/* 
throws:
ParseError: Person
└─ ["name"]
   └─ Name
   └─ Predicate refinement failure
   └─ Expected a non empty string, actual ""
*/
```

--------------------------------

### Create Struct Instances with Effect Schema

Source: https://effect.website/docs/schema/default-constructors

Demonstrates how to create instances of a struct schema using the make function. Shows successful creation and validation failure when constraints are violated. Includes ParseError details for empty string validation failures.

```typescript
import { Schema } from "effect"

const Struct = Schema.Struct({
  name: Schema.NonEmptyString
})

// Successful creation
Struct.make({ name: "a" })

// This will throw an error because the name is empty
Struct.make({ name: "" })
/*
throws
ParseError: { readonly name: NonEmptyString }
└─ ["name"]
  └─ NonEmptyString
    └─ Predicate refinement failure
      └─ Expected NonEmptyString, actual ""
*/
```

--------------------------------

### Custom Error Message for Union Schema with Override (Effect)

Source: https://effect.website/docs/schema/error-messages

Illustrates how to apply a custom error message to a union schema using `Schema.Union(...).annotations({ message: ... })`. The `override: true` option ensures this custom message replaces all nested or default error messages when decoding fails. The example decodes `null` against a union of string and number.

```typescript
import { Schema } from "effect"

// Define a union schema without a custom message
const MyUnion = Schema.Union(Schema.String, Schema.Number)

// Decode `null`, resulting in default union error messages
// Schema.decodeUnknownSync(MyUnion)(null)
/* 
throws:
ParseError: string | number 
├─ Expected string, actual null 
└─ Expected number, actual null 
*/

// Define a union schema with a custom message and override flag
const MyUnionWithMessage = Schema.Union(
  Schema.String,
  Schema.Number
).annotations({
  message: () => ({
    message: "Please provide a string or a number",
    // Ensures this message replaces all nested messages
    override: true
  })
})

// Decode with the custom schema, showing the new error message
// Schema.decodeUnknownSync(MyUnionWithMessage)(null)
/* 
throws:
ParseError: Please provide a string or a number 
*/
```

--------------------------------

### Basic Effect Creation

Source: https://context7_llms

Demonstrates the fundamental way to create an Effect in TypeScript. Effects represent lazy, immutable computations that can encapsulate success, failure, and side effects.

```typescript
import * as Effect from "@effect/io/Effect"

const myEffect = Effect.sync(() => {
  console.log("This is a side effect!")
  return 42
})

console.log(myEffect) // Effect { _id: "Effect", ... }
```
